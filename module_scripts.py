from header_common import *
from header_operations import *
from module_constants import *
from header_parties import *
from header_skills import *
from header_mission_templates import *
from header_items import *
from header_triggers import *
from header_terrain_types import *
from header_music import *
from header_map_icons import *
from header_sounds import *
import header_debug as dbg
import header_lazy_evaluation as lazy
import math

####################################################################################################################
# scripts is a list of script records.
# Each script record contns the following two fields:
# 1) Script id: The prefix "script_" will be inserted when referencing scripts.
# 2) Operation block: This must be a valid operation block. See header_operations.py for reference.
####################################################################################################################

scripts = []
scripts.extend([

	("game_start", []), # single player only, not used

	("game_get_use_string", # clients: called by the game when the local player is aiming at a usable scene prop
	 [(store_script_param, ":instance_id", 1),

		(try_begin),
			(multiplayer_is_server),
			(get_player_agent_no, ":my_agent_id"),
			(assign, ":stock_count_update_time", 0),
		(else_try), # if the targeted prop has a stock count and enough time has passed since the last update, request the current count from the server
			(multiplayer_get_my_player, ":my_player_id"),
			(player_is_active, ":my_player_id"),
			(player_get_agent_id, ":my_agent_id", ":my_player_id"),
			(scene_prop_get_slot, ":stock_count_update_time", ":instance_id", slot_scene_prop_stock_count_update_time),
			(neq, "$g_game_type", "mt_quick_battle"),
			(neq, ":stock_count_update_time", 0),
			(store_mission_timer_a, ":current_time"),
			(gt, ":current_time", ":stock_count_update_time"),
			(val_add, ":current_time", stock_count_check_interval),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_stock_count_update_time, ":current_time"),
			(multiplayer_send_int_to_server, client_event_request_stock_count, ":instance_id"),
		(try_end),

		(scene_prop_get_slot, ":item_id", ":instance_id", slot_scene_prop_item_id),
		(scene_prop_get_slot, ":use_string", ":instance_id", slot_scene_prop_use_string),
		(try_begin), # if the targeted prop is an item stockpile
			(is_between, ":item_id", all_items_begin, all_items_end),
			(call_script, "script_scene_prop_get_gold_value", ":instance_id", ":item_id", 0),
			(assign, ":gold_value", reg0),
			(assign, ":gold_multiplier", reg1),

			(try_begin),
				(gt, ":use_string", 0),
				(try_begin), # for banners, get the associated faction name
					(eq, ":use_string", "str_buy_banner_faction"),
					(call_script, "script_scene_prop_get_owning_faction", ":instance_id"),
					(str_store_faction_name, s1, reg0),
					(str_store_string, s0, ":use_string"),
				(else_try), # for the export stations in the feudalism game type, display the castle that will benefit
					(eq, "$g_game_type", "mt_feudalism"),
					(eq, ":use_string", "str_export"),
					(call_script, "script_scene_prop_get_owning_faction", ":instance_id"),
					(gt, reg1, -1),
					(call_script, "script_str_store_castle_name", s1, reg1),
					(str_store_string, s0, "str_export_for_s1"),
				(else_try), # for props with a custom use string set
					(str_store_item_name, s1, ":item_id"),
					(assign, reg1, ":gold_value"),
					(str_store_string, s0, ":use_string"),
				(try_end),
			(else_try), # for props with a stock count
				(neq, ":stock_count_update_time", 0),
				(try_begin),
					(eq, "$g_game_type", "mt_quick_battle"),
					(str_store_string, s0, "str_buy_sell"),
				(else_try),
					(eq, "$g_game_type", "mt_no_money"),
					(str_store_string, s0, "str_take_put_craft"),
				(else_try),
					(str_store_string, s0, "str_buy_sell_craft"),
				(else_try),
				(try_end),
			(else_try), # for unlimited buying stations
				(try_begin),
					(eq, "$g_game_type", "mt_no_money"),
					(str_store_string, s0, "str_take"),
				(else_try),
					(str_store_string, s0, "str_buy"),
				(try_end),
			(try_end),

			(try_begin), # store extra information for script game_get_item_extra_text, called by the show_item_details operation
				(neq, ":stock_count_update_time", 0),
				(try_begin),
					(neq, "$g_game_type", "mt_quick_battle"),
					(scene_prop_get_slot, "$g_extra_item_details_1_value", ":instance_id", slot_scene_prop_stock_count),
					(assign, "$g_extra_item_details_1_string_id", "str_stock_count_reg0"),
					(assign, "$g_extra_item_details_1_color", 0xFF8888DD),
					(try_begin), # if a crafting stockpile, calculate the extra reward
						(neq, "$g_game_type", "mt_no_money"),
						(scene_prop_slot_eq, ":instance_id", slot_scene_prop_is_resource_stockpile, 0),
						(call_script, "script_scene_prop_get_item_crafting_refund_reward", ":instance_id"),
						(assign, "$g_extra_item_details_2_value", reg1),
						(assign, "$g_extra_item_details_2_value_2", reg2),
						(try_begin),
							(neq, "$g_game_type", "mt_feudalism"),
							(assign, "$g_extra_item_details_2_string_id", "str_crafting_refund_reg0_reward_reg1"),
						(else_try),
							(assign, "$g_extra_item_details_2_string_id", "str_crafting_reward_reg1"),
						(try_end),
						(try_begin),
							(gt, "$g_extra_item_details_2_value_2", 0),
							(assign, "$g_extra_item_details_2_color", 0xFFAADD11),
						(else_try),
							(assign, "$g_extra_item_details_2_color", 0xFF888888),
						(try_end),
					(else_try), # otherwise if a resource stockpile, check if full or nearly so
						(scene_prop_slot_eq, ":instance_id", slot_scene_prop_is_resource_stockpile, 1),
						(prop_instance_get_variation_id_2, ":stock_limit", ":instance_id"),
						(val_div, ":stock_limit", 10),
						(val_mul, ":stock_limit", 100),
						(try_begin),
							(eq, ":stock_limit", 0),
						(else_try),
							(ge, "$g_extra_item_details_1_value", ":stock_limit"),
							(str_store_string, s0, "str_stockpile_full"),
						(else_try),
							(val_mul, ":stock_limit", 9),
							(val_div, ":stock_limit", 10),
							(ge, "$g_extra_item_details_1_value", ":stock_limit"),
							(str_store_string, s0, "str_stockpile_nearly_full"),
						(try_end),
					(try_end),
				(try_end),
				(try_begin), # calculate the selling price
					(neq, "$g_game_type", "mt_no_money"),
					(this_or_next|neq, "$g_game_type", "mt_feudalism"),
					(scene_prop_slot_eq, ":instance_id", slot_scene_prop_is_resource_stockpile, 0),
					(call_script, "script_calculate_stockpile_taxed_price", ":instance_id", ":gold_value"),
					(assign, "$g_extra_item_details_3_value", reg0),
					(assign, "$g_extra_item_details_3_string_id", "str_selling_price_reg0"),
					(assign, "$g_extra_item_details_3_color", 0xFFAA7777),
				(try_end),
				#GGG:get materials
				(try_begin),
					(scene_prop_get_slot, "$g_extra_item_details_4_string_id_1", ":instance_id", slot_scene_prop_itm_material_1),
					(scene_prop_get_slot, "$g_extra_item_details_4_string_id_2", ":instance_id", slot_scene_prop_itm_material_2),
					(scene_prop_get_slot, "$g_extra_item_details_4_string_id_3", ":instance_id", slot_scene_prop_itm_material_3),
					(scene_prop_get_slot, "$g_extra_item_details_4_string_id_4", ":instance_id", slot_scene_prop_itm_material_4),
					(assign, "$g_extra_item_details_4_color", 0xFF77AA77),
				(try_end),
				#
			(try_end),

			(agent_get_look_position, pos3, ":my_agent_id"),
			(position_get_screen_projection, pos4, pos3),
			(show_item_details, ":item_id", pos4, ":gold_multiplier"),

		(else_try), # if the targeted prop is a training station, display all the stats
			(scene_prop_get_slot, ":troop_id", ":instance_id", slot_scene_prop_troop_id),
			(is_between, ":troop_id", playable_troops_begin, playable_troops_end),
			(str_store_troop_name_plural, s1, ":troop_id"),
			(call_script, "script_scene_prop_get_owning_faction", ":instance_id"),
			(assign, ":faction_id", reg0),
			(str_store_faction_name, s2, ":faction_id"),
			(try_begin),
				(gt, ":use_string", 0),
				(str_store_string, s0, ":use_string"),
			(else_try),
				(str_store_string, s0, "str_troop_train"),
			(try_end),
			(multiplayer_get_my_player, ":player_id"),
			(try_begin),
				(call_script, "script_cf_can_change_faction", ":player_id", ":faction_id"),
				(call_script, "script_cf_player_can_use_troop", ":player_id", ":troop_id"),
			(else_try),
				(str_store_string, s0, "str_troop_not_available"),
			(try_end),
			(try_begin),
				(neq, "$g_game_type", "mt_no_money"),
				(scene_prop_get_slot, ":gold_cost", ":instance_id", slot_scene_prop_gold_value),
				(gt, ":gold_cost", 0),
				(assign, reg10, ":gold_cost"),
				(str_store_string, s0, "str_troop_cost"),
			(try_end),
			(store_attribute_level, reg10, ":troop_id", ca_strength),
			(store_attribute_level, reg11, ":troop_id", ca_agility),
			(str_store_string, s0, "str_troop_strength_agility"),
			(call_script, "script_store_troop_skills_description", ":troop_id"),
			(store_proficiency_level, reg10, ":troop_id", wpt_one_handed_weapon),
			(store_proficiency_level, reg11, ":troop_id", wpt_two_handed_weapon),
			(store_proficiency_level, reg12, ":troop_id", wpt_polearm),
			(store_proficiency_level, reg13, ":troop_id", wpt_archery),
			(store_proficiency_level, reg14, ":troop_id", wpt_crossbow),
			(store_proficiency_level, reg15, ":troop_id", wpt_throwing),
			(str_store_string, s0, "str_troop_weapon_proficiencies"),
		(else_try), # for winches, select action string depending on relative position
			(this_or_next|eq, ":use_string", "str_winch_lower"),
			(eq, ":use_string", "str_winch_drop"),
			(call_script, "script_winch_get_direction", ":my_agent_id", ":instance_id"),
			(gt, reg0, 0),
			(str_store_string, s0, "str_winch_raise"),
		(else_try), # for carts, select action string depending on relative position
			(eq, ":use_string", "str_attach"),
			(call_script, "script_cart_choose_action", ":my_agent_id", ":instance_id"),
			(try_begin),
				(eq, reg0, 1),
				(str_store_string, s0, "str_access"),
			(else_try),
				(eq, reg0, 0),
				(str_store_string, s0, "str_not_close_enough"),
			(else_try),
				(str_store_string, s0, "str_attach"),
			(try_end),
		(else_try), # for item destroying piles, adjust string for attached carts or wielded items
			(eq, ":use_string", "str_destroy_s1"),
			(agent_get_horse, ":attach_agent_id", ":my_agent_id"),
			(try_begin),
				(le, ":attach_agent_id", -1),
				(assign, ":attach_agent_id", ":my_agent_id"),
			(try_end),
			(agent_get_attached_scene_prop, ":attached_instance_id", ":attach_agent_id"),
			(try_begin),
				(prop_instance_is_valid, ":attached_instance_id"),
				(str_store_string, s0, "str_destroy_all_items_cart"),
			(else_try),
				(agent_get_wielded_item, ":wielded_item_id", ":my_agent_id", 0),
				(try_begin),
					(is_between, ":wielded_item_id", all_items_begin, all_items_end),
					(str_store_item_name, s1, ":wielded_item_id"),
				(else_try),
					(agent_get_wielded_item, ":shield_item_id", ":my_agent_id", 1),
					(is_between, ":shield_item_id", all_items_begin, all_items_end),
					(str_store_item_name, s1, ":shield_item_id"),
				(else_try),
					(str_clear, s1),
				(try_end),
				(str_store_string, s0, ":use_string"),
			(try_end),

		(else_try), # for custom use strings, store the gold value and stock count slots for insertion into it
			(gt, ":use_string", 0),
			(scene_prop_get_slot, reg1, ":instance_id", slot_scene_prop_gold_value),
			(scene_prop_get_slot, reg2, ":instance_id", slot_scene_prop_stock_count),
			(str_store_string, s0, ":use_string"),

		(else_try), # for castle signs, calculate the name to display
			(prop_instance_get_scene_prop_kind, ":scene_prop_id", ":instance_id"),
			(eq, ":scene_prop_id", "spr_pw_castle_sign"),
			(call_script, "script_scene_prop_get_owning_faction", ":instance_id"),
			(try_begin),
				(gt, reg1, -1),
				(call_script, "script_str_store_castle_name", s0, reg1),
				(str_store_faction_name, s1, reg0),
				(str_store_string, s0, "str_s0__s1_"),
			(else_try),
				(prop_instance_get_variation_id_2, ":name_string_id", ":instance_id"),
				(val_add, ":name_string_id", castle_names_begin),
				(val_min, ":name_string_id", castle_names_end),
				(str_store_string, s0, ":name_string_id"),
			(try_end),

		(else_try), # -1 clears the use string
			(eq, ":use_string", -1),
			(str_clear, s0),
		(else_try), # otherwise fall back to the default string
			(str_store_string, s0, "str_use"),
		(try_end),

		(try_begin), # find the base scene prop a linked prop is targeted
			(scene_prop_slot_eq, ":instance_id", slot_scene_prop_show_linked_hit_points, 1),
			(scene_prop_get_slot, "$g_show_hit_points_instance_id", ":instance_id", slot_scene_prop_linked_scene_prop),
			(prop_instance_is_valid, "$g_show_hit_points_instance_id"),
		(else_try),
			(assign, "$g_show_hit_points_instance_id", ":instance_id"),
		(try_end),
		(scene_prop_get_slot, "$g_scene_prop_full_hit_points", "$g_show_hit_points_instance_id", slot_scene_prop_full_hit_points),
		(try_begin), # set values to display the hit points bar presentation
			(gt, "$g_scene_prop_full_hit_points", 0),
			(scene_prop_get_hit_points, "$g_scene_prop_hit_points", "$g_show_hit_points_instance_id"),
			(gt, "$g_scene_prop_hit_points", "$g_scene_prop_full_hit_points"),
			(assign, "$g_scene_prop_full_hit_points", "$g_scene_prop_hit_points"),
			(scene_prop_set_slot, "$g_show_hit_points_instance_id", slot_scene_prop_full_hit_points, "$g_scene_prop_hit_points"),
		(try_end),
		]),

	("store_troop_skills_description", []), # dynamically generate a string listing a troop's skills
	("initialize_item_slots", []), # save or calculate item attributes into item slots, for use in calculations in scripts while the game is running

	("game_quick_start", # called by the game when starting multiplayer mode, before connecting to a server; used to setup static module data
	 [
		(call_script, "script_initialize_troop_equipment_slots"),
		(call_script, "script_initialize_item_slots"),
		(call_script, "script_initialize_banner_info"),
		(call_script, "script_initialize_game_rules"),
		(call_script, "script_initialize_animation_menu_strings"),
		(call_script, "script_initialize_animation_durations"),
		(call_script, "script_store_profile_troop_equipment"),
		]),

	("game_set_multiplayer_mission_end", # called when the mission ends
	 [
		(assign, "$g_game_ended", 1),
		(assign, "$g_stats_chart_opened_manually", 0),
		(try_begin),
			(neg|is_presentation_active, "prsnt_tabbed_stats_chart"),
			(start_presentation, "prsnt_tabbed_stats_chart"),
		(try_end),
		]),

	("game_enable_cheat_menu", []),

	("game_get_console_command", # server: called when console commands are entered (other than hard coded ones)
	 [(store_script_param, ":command", 1),
		(store_script_param, ":value", 2),

		(try_begin),
			(call_script, "script_cf_execute_command", ":command", ":value"),
			(call_script, "script_store_command_string", ":command", reg1),
		(else_try),
			(str_store_string, s0, reg0),
		(try_end),
		]),

	("game_event_party_encounter", []),
	("game_event_simulate_battle", []),
	("game_event_battle_end", []),
	("game_get_item_buy_price_factor", []),
	("game_get_item_sell_price_factor", []),
	("game_event_buy_item", []),
	("game_event_sell_item", []),
	("game_get_troop_wage", []),
	("game_get_total_wage", []),
	("game_get_join_cost", []),
	("game_get_upgrade_xp", []),
	("game_get_upgrade_cost", []),
	("game_get_prisoner_price", []),
	("game_check_prisoner_can_be_sold", []),
	("game_get_morale_of_troops_from_faction", []),
	("game_event_detect_party", []),
	("game_event_undetect_party", []),
	("game_get_statistics_line", []),
	("game_get_date_text", []),
	("game_get_money_text", []),
	("game_get_party_companion_limit", []),
	("game_reset_player_party_name", []),
	("game_get_troop_note", []),
	("game_get_center_note", []),
	("game_get_faction_note", []),
	("game_get_quest_note", []),
	("game_get_info_page_note", []),

	("game_get_scene_name", # return scene names for display in the server list
	 [(store_script_param, ":scene_no", 1),
		(try_begin),
			(multiplayer_is_dedicated_server), # on clients return nothing, so the server will always be asked in case of custom names
			(is_between, ":scene_no", scenes_begin, scenes_end),
			(store_sub, ":string_id", ":scene_no", scenes_begin),
			(val_add, ":string_id", scene_names_begin),
			(str_store_string, s0, ":string_id"),
		(try_end),
		]),

	("game_get_mission_template_name",
	 [(store_script_param, ":mission_template_no", 1),
		(try_begin),
			(is_between, ":mission_template_no", game_type_mission_templates_begin, game_type_mission_templates_end),
			(store_add, ":string_id", ":mission_template_no", game_type_names_begin),
			(str_store_string, s0, ":string_id"),
		(try_end),
		]),

	("cf_shutdown_process", #WIP
	[
		# jetzt noch schnell url requests schicken, wir brauchen ja keine antwort
		# (send_message_to_url, "@http://localhost/pw/changestatus.php?playeruid=ALL"),
		(server_add_message_to_log, "@Illuminati - Server Shutdown Process"),
		(server_add_message_to_log, "@Shutdown Process: - CHANGED ALL STATUSES TO OFFLINE"),
		(server_add_message_to_log, "@Shutdown Process: - SAVED ALL CHESTS"),
		(server_add_message_to_log, "@Shutdown Process: - RESTORED BANK VALUES"),
		(server_add_message_to_log, "@Shutdown Process: - KICKED ALL PLAYERS"),
		(server_add_message_to_log, "@Shutdown Process... Shutdown..."),
	]),
	
#	("cf_refresh_stocks", #WIP
#	[
#(try_for_range, ":stock_id", ":min_stocks", ":max_stocks"),
#	(scene_prop_slot_eq, ":stock_id", slot_scene_prop_is_resource_stockpile, 1),
#	#set stockcount to 20
#	(try_end),
#	]),
	
 #GGG:save faction
	("cf_save_faction", #server: saves faction
	[(store_script_param, ":faction_id", 1),
	 (faction_get_slot, reg4, ":faction_id", slot_faction_military_strength),
	 (faction_get_slot, reg3, ":faction_id", slot_faction_banner_mesh),
	 (assign, reg2, ":faction_id"),
	 (send_message_to_url, "@http://localhost/backendDsDvC/savefaction.php?faction={reg2}&banner={reg3}&military={reg4}"),

	 (server_add_message_to_log, "@Saved faction: {reg2} with {reg3} flag have {reg4} military succesfully into the database."),
	]),

 #GGG:skill menu
	("cf_update_player_skills",
	[(store_script_param, ":player_id", 1),

	(player_get_unique_id, reg1, ":player_id"),
	(player_get_slot, reg2, ":player_id", slot_player_troop_strength),
	(player_get_slot, reg3, ":player_id", slot_player_troop_agility),
	(player_get_slot, reg4, ":player_id", slot_player_troop_ironflesh),
	(player_get_slot, reg5, ":player_id", slot_player_troop_power_strike),
	(player_get_slot, reg6, ":player_id", slot_player_troop_power_draw),
	(player_get_slot, reg7, ":player_id", slot_player_troop_power_throw),
	(player_get_slot, reg8, ":player_id", slot_player_troop_shield),
	(player_get_slot, reg9, ":player_id", slot_player_troop_athletics),
	(player_get_slot, reg10, ":player_id", slot_player_troop_riding),
	(player_get_slot, reg11, ":player_id", slot_player_troop_engineer),
	(player_get_slot, reg12, ":player_id", slot_player_troop_wound_treatment),
	(player_get_slot, reg13, ":player_id", slot_player_troop_labouring),
	(player_get_slot, reg14, ":player_id", slot_player_troop_looting),
	(player_get_slot, reg15, ":player_id", slot_player_troop_sailing),
	(player_get_slot, reg16, ":player_id", slot_player_troop_tailoring),
	(player_get_slot, reg17, ":player_id", slot_player_troop_herding),
	(player_get_slot, reg18, ":player_id", slot_player_troop_one_handed_weapon),
	(player_get_slot, reg19, ":player_id", slot_player_troop_two_handed_weapon),
	(player_get_slot, reg20, ":player_id", slot_player_troop_polearm),
	(player_get_slot, reg21, ":player_id", slot_player_troop_archery),
	(player_get_slot, reg22, ":player_id", slot_player_troop_crossbow),
	(player_get_slot, reg23, ":player_id", slot_player_troop_throwing),
	(player_get_slot, reg24, ":player_id", slot_player_used_skill_points),
	(player_get_slot, reg25, ":player_id", slot_player_unused_skill_points),

	(str_store_string, s21, "@skills={reg2}|{reg3}|{reg4}|{reg5}|{reg6}|{reg7}|{reg8}|{reg9}|{reg10}|{reg11}|{reg12}|{reg13}|{reg14}|{reg15}|{reg16}|{reg17}|{reg18}|{reg19}|{reg20}|{reg21}|{reg22}|{reg23}|{reg24}|{reg25}"),

	(send_message_to_url, "@http://localhost/backendDsDvC/saveskills.php?playeruid={reg1}&{s21}"),
	(server_add_message_to_log, "@Guid {reg1} save skill: strength: {reg2}|agility: {reg3}|ironflesh: {reg4}|power_strike: {reg5}|power_draw: {reg6}|power_throw: {reg7}|shield: {reg8}|athletics: {reg9}|riding: {reg10}|engineer: {reg11}|wound_treatment: {reg12}|labouring: {reg13}|looting: {reg14}|sailing: {reg15}|tailoring: {reg16}|herding: {reg17}|one_handed: {reg18}|two_handed: {reg19}|polearm: {reg20}|archery: {reg21}|crossbow: {reg22}|throwing: {reg23}|skills: {reg24}|unused: {reg25}"),

	(assign, reg26, ":player_id"),
	(send_message_to_url, "@http://localhost/backendDsDvC/loadskills.php?playerid={reg26}&playeruid={reg1}"),
	]),

 #GGG:house chest
	("cf_save_all_chests", #server: save all chests
	[(scene_prop_get_num_instances, ":max_instances", "spr_pw_item_chest_a"),
	 (val_add, ":max_instances", 1),
	 (try_for_range, ":current_instance", 0, ":max_instances"),
			(scene_prop_get_instance, ":chest_instance", "spr_pw_item_chest_a", ":current_instance"),
			(prop_instance_is_valid, ":chest_instance"),
			(prop_instance_get_variation_id_2, ":chest_id", ":chest_instance"),
			(gt, ":chest_id", 0),
			(call_script, "script_cf_save_chest_content", ":chest_id", ":chest_instance"),
	 (try_end),
	]),
	
	("cf_save_chest_content", #server: saves chest content
	[(store_script_param, ":chest_id", 1),
	(store_script_param, ":instance_id", 2),
	 
	(prop_instance_is_valid, ":instance_id"),
	(assign, reg54, ":chest_id"),
	 
	(scene_prop_get_slot, reg1, ":instance_id", slot_scene_prop_inventory_begin + 0),
	(scene_prop_get_slot, reg2, ":instance_id", slot_scene_prop_inventory_begin + 1),
	(scene_prop_get_slot, reg3, ":instance_id", slot_scene_prop_inventory_begin + 2),
	(scene_prop_get_slot, reg4, ":instance_id", slot_scene_prop_inventory_begin + 3),
	(scene_prop_get_slot, reg5, ":instance_id", slot_scene_prop_inventory_begin + 4),
	(scene_prop_get_slot, reg6, ":instance_id", slot_scene_prop_inventory_begin + 5),
	(scene_prop_get_slot, reg7, ":instance_id", slot_scene_prop_inventory_begin + 6),
	(scene_prop_get_slot, reg8, ":instance_id", slot_scene_prop_inventory_begin + 7),
	(scene_prop_get_slot, reg9, ":instance_id", slot_scene_prop_inventory_begin + 8),
	(scene_prop_get_slot, reg10, ":instance_id", slot_scene_prop_inventory_begin + 9),
	(scene_prop_get_slot, reg11, ":instance_id", slot_scene_prop_inventory_begin + 10),
	(scene_prop_get_slot, reg12, ":instance_id", slot_scene_prop_inventory_begin + 11),
	(scene_prop_get_slot, reg13, ":instance_id", slot_scene_prop_inventory_begin + 12),
	(scene_prop_get_slot, reg14, ":instance_id", slot_scene_prop_inventory_begin + 13),
	(scene_prop_get_slot, reg15, ":instance_id", slot_scene_prop_inventory_begin + 14),
	(scene_prop_get_slot, reg16, ":instance_id", slot_scene_prop_inventory_begin + 15),
	(scene_prop_get_slot, reg17, ":instance_id", slot_scene_prop_inventory_begin + 16),
	(scene_prop_get_slot, reg18, ":instance_id", slot_scene_prop_inventory_begin + 17),
	(scene_prop_get_slot, reg19, ":instance_id", slot_scene_prop_inventory_begin + 18),
	(scene_prop_get_slot, reg20, ":instance_id", slot_scene_prop_inventory_begin + 19),
	(scene_prop_get_slot, reg21, ":instance_id", slot_scene_prop_inventory_begin + 20),
	(scene_prop_get_slot, reg22, ":instance_id", slot_scene_prop_inventory_begin + 21),
	(scene_prop_get_slot, reg23, ":instance_id", slot_scene_prop_inventory_begin + 22),
	(scene_prop_get_slot, reg24, ":instance_id", slot_scene_prop_inventory_begin + 23),
	(scene_prop_get_slot, reg25, ":instance_id", slot_scene_prop_inventory_begin + 24),
	(scene_prop_get_slot, reg26, ":instance_id", slot_scene_prop_inventory_begin + 25),
	(scene_prop_get_slot, reg27, ":instance_id", slot_scene_prop_inventory_begin + 26),
	(scene_prop_get_slot, reg28, ":instance_id", slot_scene_prop_inventory_begin + 27),
	(scene_prop_get_slot, reg29, ":instance_id", slot_scene_prop_inventory_begin + 28),
	(scene_prop_get_slot, reg30, ":instance_id", slot_scene_prop_inventory_begin + 29),
	(scene_prop_get_slot, reg31, ":instance_id", slot_scene_prop_inventory_begin + 30),
	(scene_prop_get_slot, reg32, ":instance_id", slot_scene_prop_inventory_begin + 31),
	(scene_prop_get_slot, reg33, ":instance_id", slot_scene_prop_inventory_begin + 32),
	(scene_prop_get_slot, reg34, ":instance_id", slot_scene_prop_inventory_begin + 33),
	(scene_prop_get_slot, reg35, ":instance_id", slot_scene_prop_inventory_begin + 34),
	(scene_prop_get_slot, reg36, ":instance_id", slot_scene_prop_inventory_begin + 35),
	(scene_prop_get_slot, reg37, ":instance_id", slot_scene_prop_inventory_begin + 36),
	(scene_prop_get_slot, reg38, ":instance_id", slot_scene_prop_inventory_begin + 37),
	(scene_prop_get_slot, reg39, ":instance_id", slot_scene_prop_inventory_begin + 38),
	(scene_prop_get_slot, reg40, ":instance_id", slot_scene_prop_inventory_begin + 39),
	(scene_prop_get_slot, reg41, ":instance_id", slot_scene_prop_inventory_begin + 40),
	(scene_prop_get_slot, reg42, ":instance_id", slot_scene_prop_inventory_begin + 41),
	(scene_prop_get_slot, reg43, ":instance_id", slot_scene_prop_inventory_begin + 42),
	(scene_prop_get_slot, reg44, ":instance_id", slot_scene_prop_inventory_begin + 43),
	(scene_prop_get_slot, reg45, ":instance_id", slot_scene_prop_inventory_begin + 44),
	(scene_prop_get_slot, reg46, ":instance_id", slot_scene_prop_inventory_begin + 45),
	(scene_prop_get_slot, reg47, ":instance_id", slot_scene_prop_inventory_begin + 46),
	(scene_prop_get_slot, reg48, ":instance_id", slot_scene_prop_inventory_begin + 47),
	 
	(str_store_string, s21, "@item={reg1}|{reg2}|{reg3}|{reg4}|{reg5}|{reg6}|{reg7}|{reg8}|{reg9}|{reg10}|{reg11}|{reg12}|{reg13}|{reg14}|{reg15}|{reg16}|{reg17}|{reg18}|{reg19}|{reg20}|{reg21}|{reg22}|{reg23}|{reg24}|{reg25}|{reg26}|{reg27}|{reg28}|{reg29}|{reg30}|{reg31}|{reg32}|{reg33}|{reg34}|{reg35}|{reg36}|{reg37}|{reg38}|{reg39}|{reg40}|{reg41}|{reg42}|{reg43}|{reg44}|{reg45}|{reg46}|{reg47}|{reg48}"),

	(send_message_to_url, "@http://localhost/backendDsDvC/savechest.php?instance={reg54}&{s21}"),
	(server_add_message_to_log, "@Saved chest: {reg54} items {s21} succesfully into the database."),
	]),

	("cf_load_all_chests", #server: load all chests
	[(scene_prop_get_num_instances, ":max_instances", "spr_pw_item_chest_a"),
	(val_add, ":max_instances", 1),
	(try_for_range, ":current_instance", 0, ":max_instances"),
		(scene_prop_get_instance, ":chest_instance", "spr_pw_item_chest_a", ":current_instance"),
		(prop_instance_is_valid, ":chest_instance"),
		(prop_instance_get_variation_id_2, ":chest_id_searched", ":chest_instance"),
		(gt, ":chest_id_searched", 0),
		(assign, reg54, ":chest_id_searched"),
		(send_message_to_url, "@http://localhost/backendDsDvC/loadchest.php?instance={reg54}"),  
	(try_end),
	]),
 
 ###GGG:new bank
 ("cf_withdraw_bank",
	[(store_script_param, ":agent", 1),
	 (agent_get_player_id, ":player_id", ":agent"),
	 (player_is_active, ":player_id"),
		
		(try_begin),
			#(assign, ":transaction", 5000),
			(assign, reg0, ":player_id"),
			#(player_get_unique_id, reg2, ":player_id"),
			#(assign, reg1, ":transaction"),
			#(player_get_gold, ":original_player_gold", ":player_id"),
			#(assign, reg8, ":original_player_gold"),
			(send_message_to_url, "@http://localhost/backendDsDvC/amountwithdraw.php?playerid={reg0}"),
			#(str_store_player_username, s0, ":player_id"),
		(try_end),
	]),
	
 ("cf_deposit_bank",
	[(store_script_param, ":agent", 1),
	 (agent_get_player_id, ":player_id", ":agent"),
	 (player_is_active, ":player_id"),
		
		(try_begin),
			#(assign, ":transaction", 5000),
			(assign, reg0, ":player_id"),
			#(player_get_unique_id, reg2, ":player_id"),
			#(assign, reg1, ":transaction"),
			#(player_get_gold, ":original_player_gold", ":player_id"),
			#(assign, reg8, ":original_player_gold"),
			(send_message_to_url, "@http://localhost/backendDsDvC/amountdeposit.php?playerid={reg0}"),
			#(str_store_player_username, s0, ":player_id"),
		(try_end),
	]),
	###	

	("cf_economy_bonus",
	[(store_script_param, ":player_id", 1), #must be valid
	
	(try_begin), #Check if its 10, if not then add 1
		(player_get_slot, ":ecbonus", ":player_id", slot_player_economy_bonus),
		(ge, ":ecbonus", 9),
		(player_set_slot, ":player_id", slot_player_economy_bonus, 0), #Set it to zero + give reward
		(player_get_gold, ":original_player_gold", ":player_id"),
		(val_add, ":original_player_gold", 1500),
		(player_set_gold, ":player_id", ":original_player_gold"),
		(str_store_string, s0, "@You reached the economy reward! Have fun with +1500 gold!"),		
		(multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),
	 #Add Sound
		(assign, ":sound", "snd_money_paid"),
		(player_get_agent_id, ":agent_id", ":player_id"),
		(gt, ":agent_id", -1),
		(agent_is_alive, ":agent_id"),
		(agent_play_sound, ":agent_id", ":sound"),
	(else_try), #its not bigger than 10 so add 1
		(player_get_slot, ":ecbonus", ":player_id", slot_player_economy_bonus),
		(val_add, ":ecbonus", 1),
		(player_set_slot, ":player_id", slot_player_economy_bonus, ":ecbonus"), #set +1
		
		(assign, reg5, ":ecbonus"),
		(assign, reg6, 10),
		(val_sub, reg6, ":ecbonus"),
		(str_store_string, s1, "@Craft/Make {reg6} more to get the economy bonus!"),		
		(multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s1),
	(try_end),
	]),
	
	("player_get_armor", # server: check the player name and unique id with the name server, if enabled
	 [(store_script_param, ":player_id", 1), # must be valid
		(try_begin),
			(eq, "$g_name_server_enabled", 1), # this is set upon reply to a test message sent at server start
			(assign, reg1, ":player_id"),
			(try_begin),
				(player_get_slot, ":spawnedonce", ":player_id", slot_player_spawnedonce),
				(neq, ":spawnedonce", 1), #Player ist schon einmal gespawnt = keine ruestung holen
				(player_get_unique_id, reg2, ":player_id"),
				(str_store_player_username, s3, ":player_id"),
				(str_encode_url, s3),
				(str_store_string, s0, "@http://localhost/backendDsDvC/getarmor.php?playerid={reg1}&playeruid={reg2}"),
				(try_begin),
					(player_is_admin, ":player_id"),
					(str_store_string, s0, "str_http_s0_admin"),
				(try_end),
				(send_message_to_url, s0),
				(server_add_message_to_log, s0), #Arthur debug
				(player_set_slot, ":player_id", slot_player_spawnedonce, 1), #server sagen das player schonmal gespawnt ist und nicht mehr ruestung oder pos abrufen soll
			(try_end),
		(try_end),
		]),
	
	("player_death_update", #updates if the player died
	[(store_script_param, ":player_id", 1), #must be valid
	
	(player_get_unique_id, reg1, ":player_id"),
	(send_message_to_url, "@http://localhost/backendDsDvC/remove.php?playeruid={reg1}"),
	
	]),
	
	("player_carriedgold_update", #updates if the player switches some states
	[(store_script_param, ":player_id", 1), #must be valid
	
	(player_get_unique_id, reg1, ":player_id"),
	(player_get_gold, reg2, ":player_id"),
	
	(send_message_to_url, "@http://localhost/backendDsDvC/carriedupdate.php?playeruid={reg1}&gold={reg2}"),

	(server_add_message_to_log, "@Saved carriedgold: {reg1} succesfully save {reg2} dnr into the database."),
	]),

###GGG:# check if the agent needs to lose hunger and thirst
	("check_agent_hunger_and_thirst", 
	 [(store_script_param, ":agent_id", 1), # must be valid

		(try_begin),
			(agent_is_active, ":agent_id"),
			(agent_is_alive, ":agent_id"),
			
			(agent_get_player_id, ":player_id", ":agent_id"),
			(player_is_active, ":player_id"),
			#import slot and health
			(agent_get_slot, ":food_amount", ":agent_id", slot_agent_food_amount),
			(store_agent_hit_points, ":agent_hp", ":agent_id", 0),

			(try_begin),  # Hunger System new
				(gt, ":agent_id", 0),
				(agent_is_human, ":agent_id"),
				(agent_get_player_id, ":player_id", ":agent_id"),
				(player_is_active, ":player_id"),
				(agent_get_slot, ":food_amount", ":agent_id", slot_agent_food_amount),
				
				 (try_begin),
						 (gt, ":food_amount", 0), #wenn fressen mehr als 0 dann nehme essens bar
						 (try_begin), #prevents maths error
							 (gt, ":food_amount", 1),
							 (val_sub, ":food_amount", 1), #zieht das Fressen weg
						 (else_try),
							 (le, ":food_amount", 1),
							 (assign, ":food_amount", 0), #zieht das Fressen weg
						 (try_end),
						 (agent_set_slot, ":agent_id", slot_agent_food_amount, ":food_amount"), #setze essen
				 (try_end),
				 (try_begin),  #falls kein essen
							(eq, ":food_amount", 0), #Wenn das Fressen weg ist dann 2 Leben nehmen
							(store_agent_hit_points, ":health", ":agent_id", 1),
							(str_store_string, s0, "@You are hungery now, you get a slowly decreasing blood buff, please eat some food."),
							(multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),
							(try_begin),
								(neq, ":health", 1),
								(val_sub, ":health", 1),
								(agent_set_hit_points, ":agent_id", ":health", 1),
							###
							#(else_try),
								#(eq, ":health", 1),
								#(agent_deliver_damage_to_agent, ":agent_id", ":agent_id"),
								#(str_store_player_username, s9, ":player_id"),
								#(server_add_message_to_log, "@{s9} died because he didn't eat"),
							###
							(try_end),
				 (else_try),
							(gt, ":food_amount", 0),
							(store_agent_hit_points, ":agent_hp", ":agent_id"),
							(agent_get_slot, ":food_amount", ":agent_id", slot_agent_food_amount),
							(try_begin),
								(ge, ":food_amount", 1),
								(ge, ":agent_hp", 1),
								(lt, ":agent_hp", 100), #do not increase if already max
								(store_add, ":new_hp", ":agent_hp", 1),
								(val_sub, ":food_amount", 1),
								(agent_set_hit_points, ":agent_id", ":new_hp"),
								(agent_set_slot, ":agent_id", slot_agent_food_amount, ":food_amount"),
							(try_end),                    
				 (try_end),
				 (store_mod, ":remainder", ":food_amount", 2),
				 (eq, ":remainder", 0), # only send food bar updates to the player's client about every 5% used
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_agent_set_slot, ":agent_id", slot_agent_food_amount, ":food_amount"),
			(try_end),
			##GGG:thirst system
			(try_begin),
				(gt, ":agent_id", 0),
				(agent_is_human, ":agent_id"),
				(agent_get_player_id, ":player_id", ":agent_id"),
				(player_is_active, ":player_id"),
				(agent_get_slot, ":water_amount", ":agent_id", slot_agent_water_amount),

				(try_begin),
					 (gt, ":water_amount", 0), 
					 (try_begin), 
						 (gt, ":water_amount", 1),
						 (val_sub, ":water_amount", 1), 
					 (else_try),
						 (le, ":water_amount", 1),
						 (assign, ":water_amount", 0), 
					 (try_end),
					 (agent_set_slot, ":agent_id", slot_agent_water_amount, ":water_amount"), 
				(try_end),
				(try_begin),
					#arthur cancel water
					(eq, 1, 2),
					 #(eq, ":water_amount", 0),
					 (store_agent_hit_points, ":health", ":agent_id", 1),
					 (str_store_string, s0, "@You are thirsty now, please empty-handed press F on the well or have a drink."),
					 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),
					 (try_begin),
							(neq, ":health", 1),
							(val_sub, ":health", 1),
							(agent_set_hit_points, ":agent_id", ":health", 1),
					 (try_end),
				 (else_try),
				 			(eq, 1, 2),
							(gt, ":water_amount", 0),
							(store_agent_hit_points, ":agent_hp", ":agent_id", 1),
							(agent_get_slot, ":water_amount", ":agent_id", slot_agent_water_amount),
							(try_begin),
								(ge, ":water_amount", 1),
								(ge, ":agent_hp", 1),
								(lt, ":agent_hp", 100), #do not increase if already max
								(store_add, ":new_hp", ":agent_hp", 1),
								(val_sub, ":water_amount", 1),
								(agent_set_hit_points, ":agent_id", ":new_hp", 1),
								(agent_set_slot, ":agent_id", slot_agent_water_amount, ":water_amount"),
							(try_end),        
				(try_end),

				#(store_mod, ":remainder", ":water_amount", 2),
				#(eq, ":remainder", 0),
				#(multiplayer_send_3_int_to_player, ":player_id", server_event_agent_set_slot, ":agent_id", slot_agent_water_amount, ":water_amount"),
			(try_end),
			###    
		(try_end), 
		]),
	
	("game_receive_url_response", # called by the game when a response is received from a web server, if used
	 [(store_script_param, ":integer_count", 1),
		(store_script_param, ":string_count", 2), 

		###GGG:new bank
		(try_begin),
			(eq, ":integer_count", 2),
			(eq, ":string_count", 1),
			
			(assign, ":check_num", reg0),
			(assign, ":player_id", reg1),
			
			(player_is_active, ":player_id"),

			(try_begin),
				(eq, ":check_num", 99),
				(player_set_slot, ":player_id", slot_player_must_enter_amount, 1),
				(multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),
			(else_try),
				(eq, ":check_num", 98),
				(player_set_slot, ":player_id", slot_player_must_enter_amount, 2),
				(multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),
			(try_end),
		(try_end),
		###

		(assign, "$g_name_server_enabled", 1),
	
		(try_begin),
			(ge, ":integer_count", 1), #SPIELER JOINT - not needed
			(assign, ":return_code", reg0),
		
	#Hier jetzt alle Return Codes ueberpruefen
			(try_begin),
				 (eq, ":return_code", 0), #Lade Gold.
				 (assign, ":player_id", reg1),
				 ###Arthur begins
				 (player_set_slot, ":player_id", slot_player_initialized, 1),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_initialized, 1),
				 ###
				# (assign, ":unique_id", reg2),
				 (assign, ":faction", reg13),
				 (assign, ":troop", reg14),
				 (assign, ":gold", reg15),
				# (assign, ":bankgold", reg16),
				 (assign, ":title_number", reg17),

				 (player_is_active, ":player_id"), #GGG:debug
				 #GGG:title
				 (player_set_slot, ":player_id", slot_player_title, ":title_number"),
				 (get_max_players, ":max_players"),
				 (try_for_range, ":cur_player", 1, ":max_players"),
						(player_is_active, ":cur_player"),
						(multiplayer_send_3_int_to_player, ":cur_player", server_event_player_set_slot, ":player_id", slot_player_title, ":title_number"),
					(try_end),
				 #

				 (str_store_string, s0, "@Welcome to our Server. Your GUID is: {reg2} and you currently have {reg16} gold in your bank."),
				 (str_store_string, s1, "@Please visit: http://bbs.mountblade.com.cn/thread-516827-1-1.html for the rules, enjoy your stay!"),    
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s1), 

				 (call_script, "script_player_adjust_gold", ":player_id", ":gold", 0),
				 (player_get_unique_id, reg25, ":player_id"),
				 (assign, reg26, ":player_id"),
				 #(player_set_troop_id, ":player_id", ":troop"),
					###GGG:skill
					(try_begin),
						(is_between, ":troop", hero_begin, hero_end),
						(assign, ":hero_end", "trp_hero_end"),
						(try_for_range, ":hero_troop", "trp_hero_1", ":hero_end"),
							(get_max_players, ":max_players"),
							(try_for_range, ":cur_player", 1, ":max_players"),
								(player_is_active, ":cur_player"),
								(neq, ":cur_player", ":player_id"),
								(player_get_troop_id, ":cur_troop", ":cur_player"),
								(eq, ":hero_troop", ":cur_troop"),
								(troop_set_slot, ":hero_troop", slot_troop_hero_is_used, 1),
							(try_end),
							(troop_slot_eq, ":hero_troop", slot_troop_hero_is_used, 0), #
							(assign, ":hero_end", ":hero_troop"), #
							(player_set_troop_id, ":player_id", ":hero_troop"), #
							(send_message_to_url, "@http://localhost/backendDsDvC/loadskills.php?playerid={reg1}&playeruid={reg2}"), #
						(try_end),
						#(assign, ":hero_start", "trp_hero_1"),
						#(try_for_range, ":hero_troop", ":hero_start", "trp_hero_end"),
						#  (troop_slot_eq, ":hero_troop", slot_troop_hero_is_used, 0),
						#  (assign, ":hero_start", ":hero_troop"),
						#  (player_set_troop_id, ":player_id", ":hero_troop"),
						#  (send_message_to_url, "@http://localhost/backendDsDvC/loadskills.php?playerid={reg1}&playeruid={reg2}"),
						#(try_end),
					(else_try),
						(player_set_troop_id, ":player_id", ":troop"),
					(try_end),
					#
	
				 (try_begin),
						(eq, ":faction", 0),
				 (else_try),
						(call_script, "script_change_faction", ":player_id", ":faction", change_faction_type_respawn),
				 (try_end),

				 (try_begin),
				 	(gt, reg18, 340),
				 	(player_add_spawn_item, ":player_id", ek_horse, reg18),
				 (try_end),
			 
				 (try_begin), # if the player is admin give him the admin thing
						(ge, ":integer_count", 19), #If there are more than 18 Integers then the player has ADMIN PERMISSIONS
						(player_is_admin, ":player_id"),
						(assign, ":admin_permissions", reg19),
						(val_max, ":admin_permissions", 0),
						(call_script, "script_player_set_admin_permissions", ":player_id", ":admin_permissions"),
						(multiplayer_send_int_to_player, ":player_id", server_event_admin_set_permissions, ":admin_permissions"),
				 (try_end),

			(else_try),
				 (eq, ":return_code", 3), #response das server daten gespeichert hat

			(else_try),
				 (eq, ":return_code", 2), #Lade Ruestung und Waffen aber nur wenn spawnedonce auf 0 ist
				 (assign, ":player_id", reg1),
				 ###Arthur begins
				 (player_set_slot, ":player_id", slot_player_initialized, 1),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_initialized, 1),
				 ###
				 (assign, ":head", reg2),
				 (assign, ":body", reg3),
				 (assign, ":gloves", reg4),
				 (assign, ":foot", reg5),
				 (assign, ":item0", reg6),
				 (assign, ":item1", reg7),
				 (assign, ":item2", reg8),
				 (assign, ":item3", reg9),
				 (assign, ":health", reg10),
				# (assign, ":faction", reg11),
				# (assign, ":troop", reg12), #x, y, z
				 (assign, ":coordinate_x", reg13),
				 (assign, ":coordinate_y", reg14),
				 (assign, ":coordinate_z", reg15),
				 (assign, ":food_amount", reg16),
				 (assign, ":horse", reg17),
				 (assign, ":water_amount", reg18),###GGG:thirst system
				 (assign, ":outlaw_rating", reg19),###GGG:outlaw rating
				 #Arthur no global chat
				(try_begin),
					(neg|player_is_admin, ":player_id"),
					#(player_set_is_muted, ":player_id", 1, 1), 
				(try_end),
				 #Get Agent ID
				 (player_get_agent_id, ":agent_id", reg1),
				 (assign, reg40, ":agent_id"),
				 (neq, ":agent_id", -1),
				 (agent_is_active, ":agent_id"), #is the player even on the server?
				 (agent_is_alive, ":agent_id"),

				# Set position
				 (try_begin), #if the player has no legit spawn point, spawn him standard
						(gt, ":coordinate_x", 0),
						(gt, ":coordinate_y", 0),
						(gt, ":coordinate_z", 0),
						(init_position, pos2),
						(position_set_x, pos2, ":coordinate_x"),
						(position_set_y, pos2, ":coordinate_y"),
						(position_set_z, pos2, ":coordinate_z"),
						(call_script, "script_cf_teleport_agent_to_pos", ":agent_id", pos2),
						#(agent_set_position, ":agent_id", pos2),
					# Spawn horse
						#(try_begin),
						#	(gt, ":horse", 340),
							#pferd existiert jetzt spawnen etc
						#	(spawn_horse, ":horse"),
						#	(player_set_slot, ":player_id", slot_player_equip_horse, ":horse"),
						#	(agent_set_position, reg0, pos2),
						#	(agent_set_slot, reg0, slot_agent_horse_last_rider, ":agent_id"),
						#	(agent_set_slot, ":agent_id", slot_agent_last_horse_ridden, reg0),
						#(try_end),
				 (try_end),
	 
				 ### Health + Food ###
				 (agent_set_hit_points, ":agent_id", ":health", 0),
				 (agent_set_slot, ":agent_id", slot_agent_food_amount, ":food_amount"),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_agent_set_slot, ":agent_id", slot_agent_food_amount, ":food_amount"),
				 ###GGG:thirst system
				 (agent_set_slot, ":agent_id", slot_agent_water_amount, ":water_amount"),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_agent_set_slot, ":agent_id", slot_agent_water_amount, ":water_amount"),
				 ###GGG:outlaw rating
				 (player_set_slot, ":player_id", slot_player_outlaw_rating, ":outlaw_rating"),
				 (multiplayer_send_3_int_to_server, client_event_player_set_slot, ":player_id", slot_player_outlaw_rating, ":outlaw_rating"),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_outlaw_rating, ":outlaw_rating"),

				 ### Set Items 1-4 ### ueberpruefen ob weniger als 0 da -1 kein item ist aber so gespeichert wird.
				 (try_begin),
						 (gt, ":item0", 0),
						 (agent_equip_item, ":agent_id", ":item0"),
				 (try_end),
				 
				 (try_begin),
						 (gt, ":item1", 0),
						 (agent_equip_item, ":agent_id", ":item1"),
				 (try_end),
				 
				 (try_begin),
						 (gt, ":item2", 0),
						 (agent_equip_item, ":agent_id", ":item2"),
				 (try_end),
				 
				 (try_begin),
						 (gt, ":item3", 0),
						 (agent_equip_item, ":agent_id", ":item3"),
				 (try_end),
				 
						### Set Armor ###
					(try_begin),
							(gt, ":head", 0),
							(call_script, "script_change_armor", ":agent_id", ":head"),
							(player_set_slot, ":player_id", slot_player_equip_head, ":head"),
					(try_end),
					
					(try_begin),
							(gt, ":body", 0),
							(call_script, "script_change_armor", ":agent_id", ":body"),
							(player_set_slot, ":player_id", slot_player_equip_body, ":body"),
					(try_end),
					
					(try_begin),
							(gt, ":gloves", 0),
							(call_script, "script_change_armor", ":agent_id", ":gloves"),
							(player_set_slot, ":player_id", slot_player_equip_gloves, ":gloves"),
					(try_end),
					
					(try_begin),
							(gt, ":foot", 0),
							(call_script, "script_change_armor", ":agent_id", ":foot"),
							(player_set_slot, ":player_id", slot_player_equip_foot, ":foot"),
					(try_end),
		
				 #Load item bank
				 #(player_get_unique_id, reg25, ":player_id"),
				 #(send_message_to_url, "@http://localhost/backendDsDvC/getbank.php?guid={reg25}&playerid={reg1}"),

			(else_try),
				 (eq, ":return_code", 1), #Player benutzt Namen von einem anderen.
				 (assign, ":player_id", reg1),

				 (player_get_unique_id, reg1, ":player_id"),
				 (str_store_string, s0, "@Your GUID is {reg1}, Kicked cause wrong name"),
				 (multiplayer_send_string_to_player, ":player_id", server_event_admin_chat_announce, s0),
				 (store_mission_timer_a, ":time"), # kick the player after a short delay to try ensure they see the rejection message
				 (val_add, ":time", name_server_kick_delay_interval),
				 (player_set_slot, ":player_id", slot_player_kick_at_time, ":time"),
				 (server_add_message_to_log, "str_name_server_log_s10"),
	 
			(else_try),
				 (eq, ":return_code", -3),
				 (assign, "$g_name_server_enabled", 0),
				 (assign, ":player_id", reg1),
				 (str_store_string, s0, "@Kicked cause invalid server"),
				 (multiplayer_send_string_to_player, ":player_id", server_event_admin_chat_announce, s0),
				 (store_mission_timer_a, ":time"), # kick the player after a short delay to try ensure they see the rejection message
				 (val_add, ":time", name_server_kick_delay_interval),
				 (player_set_slot, ":player_id", slot_player_kick_at_time, ":time"),

			###GGG:ban global chat
			(else_try),
				 (eq, ":return_code", -2),
				 (assign, ":player_id", reg1),
				 (assign, ":faction", reg13),
				 (assign, ":troop", reg14),
				 (assign, ":gold", reg15),
				 (assign, ":title_number", reg17),
				 ###Arthur begins
				 (player_set_slot, ":player_id", slot_player_initialized, 1),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_initialized, 1),
				 ###
				 #Arthur no global chat
				(try_begin),
					(neg|player_is_admin, ":player_id"),
					#(player_set_is_muted, ":player_id", 1, 1), 
				(try_end),
				 #GGG:title
				 (player_set_slot, ":player_id", slot_player_title, ":title_number"),
				 (get_max_players, ":max_players"),
				 (try_for_range, ":cur_player", 1, ":max_players"),
						(player_is_active, ":cur_player"),
						(multiplayer_send_3_int_to_player, ":cur_player", server_event_player_set_slot, ":player_id", slot_player_title, ":title_number"),
					(try_end),
				 #

				 (str_store_string, s0, "@Welcome to our Server. Your GUID is: {reg2} and you currently have {reg16} gold in your bank."),
				 (str_store_string, s1, "@Please visit: http://bbs.mountblade.com.cn/thread-516827-1-1.html for the rules, enjoy your stay!"),    
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s1),                       

				 (str_store_string, s0, "@You have been silent."),
				 (multiplayer_send_string_to_player, ":player_id", server_event_admin_chat_announce, s0),

				 (call_script, "script_player_adjust_gold", ":player_id", ":gold", 0),
				 (player_get_unique_id, reg25, ":player_id"),
				 (assign, reg26, ":player_id"),
				 #(player_set_troop_id, ":player_id", ":troop"),
					###GGG:skill
					(try_begin),
						(is_between, ":troop", hero_begin, hero_end),
						(assign, ":hero_end", "trp_hero_end"),
						(try_for_range, ":hero_troop", "trp_hero_1", ":hero_end"),
							(get_max_players, ":max_players"),
							(try_for_range, ":cur_player", 1, ":max_players"),
								(player_is_active, ":cur_player"),
								(neq, ":cur_player", ":player_id"),
								(player_get_troop_id, ":cur_troop", ":cur_player"),
								(eq, ":hero_troop", ":cur_troop"),
								(troop_set_slot, ":hero_troop", slot_troop_hero_is_used, 1),
							(try_end),
							(troop_slot_eq, ":hero_troop", slot_troop_hero_is_used, 0), #
							(assign, ":hero_end", ":hero_troop"), #
							(player_set_troop_id, ":player_id", ":hero_troop"), #
							(send_message_to_url, "@http://localhost/backendDsDvC/loadskills.php?playerid={reg1}&playeruid={reg2}"), #
						(try_end),
					(else_try),
						(player_set_troop_id, ":player_id", ":troop"),
					(try_end),
					#
				#Arthur no global chat
				(try_begin),
					(neg|player_is_admin, ":player_id"),
					#(player_set_is_muted, ":player_id", 1, 1), 
				(try_end),
				 (try_begin),
						(eq, ":faction", 0),
				 (else_try),
						(call_script, "script_change_faction", ":player_id", ":faction", change_faction_type_respawn),
				 (try_end),

			###GGG:prisoner
			(else_try),
				 (eq, ":return_code", -2),
				 (assign, ":player_id", reg1),
				 (assign, ":faction", reg13),
				 (assign, ":troop", reg14),
				 (assign, ":gold", reg15),
				 (assign, ":title_number", reg17),
				 ###Arthur begins
				 (player_set_slot, ":player_id", slot_player_initialized, 1),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_initialized, 1),
				 ###
				 #Arthur no global chat
				(try_begin),
					(neg|player_is_admin, ":player_id"),
					#(player_set_is_muted, ":player_id", 1, 1), 
				(try_end),
				 #GGG:title
				 (player_set_slot, ":player_id", slot_player_title, ":title_number"),
				 (get_max_players, ":max_players"),
				 (try_for_range, ":cur_player", 1, ":max_players"),
						(player_is_active, ":cur_player"),
						(multiplayer_send_3_int_to_player, ":cur_player", server_event_player_set_slot, ":player_id", slot_player_title, ":title_number"),
					(try_end),
				 #

				 (str_store_string, s0, "@Welcome to our Server. Your GUID is: {reg2} and you currently have {reg16} gold in your bank."),
				 (str_store_string, s1, "@Please visit: http://bbs.mountblade.com.cn/thread-516827-1-1.html for the rules, enjoy your stay!"),    
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s1),                       

				 (str_store_string, s0, "@You have been convicted as a prisoner."),
				 (multiplayer_send_string_to_player, ":player_id", server_event_admin_chat_announce, s0),

				 (call_script, "script_player_adjust_gold", ":player_id", ":gold", 0),
				 (player_get_unique_id, reg25, ":player_id"),
				 (assign, reg26, ":player_id"),
				 (is_between, ":troop", playable_troops_begin, playable_troops_end),
				 (player_set_troop_id, ":player_id", "trp_prisoner"),
				 (player_set_slot, ":player_id", slot_player_is_prisoner, 1),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_is_prisoner, 1),

				 (try_begin),
						(eq, ":faction", 0),
				 (else_try),
						(call_script, "script_change_faction", ":player_id", ":faction", change_faction_type_respawn),
				 (try_end),

			###GGG:register system
			(else_try),
				 (eq, ":return_code", -4),
				 (assign, ":player_id", reg1),
				 (assign, ":faction", reg13),
				 (assign, ":troop", reg14),
				 (assign, ":gold", reg15),
				 (assign, ":title_number", reg17),
				 ###Arthur begins
				 (player_set_slot, ":player_id", slot_player_initialized, 1),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_initialized, 1),
				 ###
				 #Arthur no global chat
				(try_begin),
					(neg|player_is_admin, ":player_id"),
					#(player_set_is_muted, ":player_id", 1, 1), 
				(try_end),
				 #GGG:title
				 (player_set_slot, ":player_id", slot_player_title, ":title_number"),
				 (get_max_players, ":max_players"),
				 (try_for_range, ":cur_player", 1, ":max_players"),
						(player_is_active, ":cur_player"),
						(multiplayer_send_3_int_to_player, ":cur_player", server_event_player_set_slot, ":player_id", slot_player_title, ":title_number"),
					(try_end),
				 #

				 (str_store_string, s0, "@Welcome to our Server. Your GUID is: {reg2} and you currently have {reg16} gold in your bank."),
				 (str_store_string, s1, "@Please visit: http://bbs.mountblade.com.cn/thread-516827-1-1.html for the rules, enjoy your stay!"),    
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s1),                       

				 (str_store_string, s0, "@register success, you can enter cn_x_pw now."),
				 (multiplayer_send_string_to_player, ":player_id", server_event_admin_chat_announce, s0),

				 (call_script, "script_player_adjust_gold", ":player_id", ":gold", 0),
				 (player_get_unique_id, reg25, ":player_id"),
				 (assign, reg26, ":player_id"),
				 #(player_set_troop_id, ":player_id", ":troop"),
					###GGG:skill
					#(try_begin),
					#  (is_between, ":troop", hero_begin, hero_end),
					#  (assign, ":loot_end", "trp_hero_end"),
					#  (try_for_range, ":hero_troop", "trp_hero_1", ":loot_end"),
					#    (get_max_players, ":max_players"),
					#    (try_for_range, ":cur_player", 1, ":max_players"),
					#        (player_is_active, ":cur_player"),
					#        (neq, ":cur_player", ":player_id"),
					#        (player_get_troop_id, ":cur_troop", ":cur_player"),
					#        (neq, ":hero_troop", ":cur_troop"),
					#        (assign, ":loot_end", ":hero_troop"),
					#    (try_end),
					#    (player_set_troop_id, ":player_id", ":hero_troop"),
					#    (send_message_to_url, "@http://localhost/backendDsDvC/loadskills.php?playerid={reg1}&playeruid={reg2}"),
					#  (try_end),
					#(else_try),
					#  (player_set_troop_id, ":player_id", ":troop"),
					#(try_end),
					#
					###GGG:skill
					(try_begin),
						(is_between, ":troop", hero_begin, hero_end),
						(assign, ":hero_end", "trp_hero_end"),
						(try_for_range, ":hero_troop", "trp_hero_1", ":hero_end"),
							(get_max_players, ":max_players"),
							(try_for_range, ":cur_player", 1, ":max_players"),
								(player_is_active, ":cur_player"),
								(neq, ":cur_player", ":player_id"),
								(player_get_troop_id, ":cur_troop", ":cur_player"),
								(eq, ":hero_troop", ":cur_troop"),
								(troop_set_slot, ":hero_troop", slot_troop_hero_is_used, 1),
							(try_end),
							(troop_slot_eq, ":hero_troop", slot_troop_hero_is_used, 0), #
							(assign, ":hero_end", ":hero_troop"), #
							(player_set_troop_id, ":player_id", ":hero_troop"), #
							(send_message_to_url, "@http://localhost/backendDsDvC/loadskills.php?playerid={reg1}&playeruid={reg2}"), #
						(try_end),
						#(assign, ":hero_start", "trp_hero_1"),
						#(try_for_range, ":hero_troop", ":hero_start", "trp_hero_end"),
						#  (troop_slot_eq, ":hero_troop", slot_troop_hero_is_used, 0),
						#  (assign, ":hero_start", ":hero_troop"),
						#  (player_set_troop_id, ":player_id", ":hero_troop"),
						#  (send_message_to_url, "@http://localhost/backendDsDvC/loadskills.php?playerid={reg1}&playeruid={reg2}"),
						#(try_end),
					(else_try),
						(player_set_troop_id, ":player_id", ":troop"),
					(try_end),
					#

				 (try_begin),
						(eq, ":faction", 0),
				 (else_try),
						(call_script, "script_change_faction", ":player_id", ":faction", change_faction_type_respawn),
				 (try_end),

				(try_begin),
				 	(gt, reg18, 340),
				 	(player_add_spawn_item, ":player_id", ek_horse, reg18),
				 (try_end),
			 
				 (try_begin), # if the player is admin give him the admin thing
						(ge, ":integer_count", 19), #If there are more than 18 Integers then the player has ADMIN PERMISSIONS
						(player_is_admin, ":player_id"),
						(assign, ":admin_permissions", reg19),
						(val_max, ":admin_permissions", 0),
						(call_script, "script_player_set_admin_permissions", ":player_id", ":admin_permissions"),
						(multiplayer_send_int_to_player, ":player_id", server_event_admin_set_permissions, ":admin_permissions"),
				 (try_end),
	 
				###
			(else_try),
				 (eq, ":return_code", -9),
				 (assign, ":player_id", reg1),
				 (assign, ":faction", reg13),
				 (assign, ":troop", reg14),
				 (assign, ":gold", reg15),
				 (assign, ":title_number", reg17),
				 ###Arthur begins
				 (player_set_slot, ":player_id", slot_player_initialized, 1),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_initialized, 1),
				 ###
				 #Arthur no global chat
				(try_begin),
					(neg|player_is_admin, ":player_id"),
					#(player_set_is_muted, ":player_id", 1, 1), 
				(try_end),
				 #GGG:title
				 (player_set_slot, ":player_id", slot_player_title, ":title_number"),
				 (get_max_players, ":max_players"),
				 (try_for_range, ":cur_player", 1, ":max_players"),
						(player_is_active, ":cur_player"),
						(multiplayer_send_3_int_to_player, ":cur_player", server_event_player_set_slot, ":player_id", slot_player_title, ":title_number"),
					(try_end),
				 #

				 (str_store_string, s0, "@Welcome to our Server. Your GUID is: {reg2} and you currently have {reg16} gold in your bank."),
				 (str_store_string, s1, "@Please visit: http://bbs.mountblade.com.cn/thread-516827-1-1.html for the rules, enjoy your stay!"),    
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s1),                       

				 (str_store_string, s0, "@Change your ID success."),
				 (multiplayer_send_string_to_player, ":player_id", server_event_admin_chat_announce, s0),

				 (call_script, "script_player_adjust_gold", ":player_id", ":gold", 0),
				 (player_get_unique_id, reg25, ":player_id"),
				 (assign, reg26, ":player_id"),
				 #(player_set_troop_id, ":player_id", ":troop"),
					###GGG:skill
					(try_begin),
						(is_between, ":troop", hero_begin, hero_end),
						(assign, ":hero_end", "trp_hero_end"),
						(try_for_range, ":hero_troop", "trp_hero_1", ":hero_end"),
							(get_max_players, ":max_players"),
							(try_for_range, ":cur_player", 1, ":max_players"),
								(player_is_active, ":cur_player"),
								(neq, ":cur_player", ":player_id"),
								(player_get_troop_id, ":cur_troop", ":cur_player"),
								(eq, ":hero_troop", ":cur_troop"),
								(troop_set_slot, ":hero_troop", slot_troop_hero_is_used, 1),
							(try_end),
							(troop_slot_eq, ":hero_troop", slot_troop_hero_is_used, 0), #
							(assign, ":hero_end", ":hero_troop"), #
							(player_set_troop_id, ":player_id", ":hero_troop"), #
							(send_message_to_url, "@http://localhost/backendDsDvC/loadskills.php?playerid={reg1}&playeruid={reg2}"), #
						(try_end),
					(else_try),
						(player_set_troop_id, ":player_id", ":troop"),
					(try_end),
					#

				 (try_begin),
						(eq, ":faction", 0),
				 (else_try),
						(call_script, "script_change_faction", ":player_id", ":faction", change_faction_type_respawn),
				 (try_end),
			 	
			 	(try_begin),
				 	(gt, reg18, 340),
				 	(player_add_spawn_item, ":player_id", ek_horse, reg18),
				 (try_end),

				 (try_begin), # if the player is admin give him the admin thing
						(ge, ":integer_count", 19), #If there are more than 18 Integers then the player has ADMIN PERMISSIONS
						(player_is_admin, ":player_id"),
						(assign, ":admin_permissions", reg19),
						(val_max, ":admin_permissions", 0),
						(call_script, "script_player_set_admin_permissions", ":player_id", ":admin_permissions"),
						(multiplayer_send_int_to_player, ":player_id", server_event_admin_set_permissions, ":admin_permissions"),
				 (try_end),

			#(else_try),
			#   (eq, ":return_code", -4),
			#   (assign, ":player_id", reg1),
			#   (str_store_string, s0, "@register success, you can enter cn_x_pw now."),
			#   (multiplayer_send_string_to_player, ":player_id", server_event_admin_chat_announce, s0),
			#   (store_mission_timer_a, ":time"),
			#   (val_add, ":time", name_server_kick_delay_interval),
			#   (player_set_slot, ":player_id", slot_player_kick_at_time, ":time"),

			(else_try),
				 (eq, ":return_code", -5),
				 (assign, ":player_id", reg1),
				 (player_get_unique_id, reg1, ":player_id"),
				 (str_store_string, s0, "@Your GUID is {reg1}, The key has been registered, if has any question, please contract admin."),
				 (multiplayer_send_string_to_player, ":player_id", server_event_admin_chat_announce, s0),
				 (store_mission_timer_a, ":time"),
				 (val_add, ":time", name_server_kick_delay_interval),
				 (player_set_slot, ":player_id", slot_player_kick_at_time, ":time"),      

			(else_try),
				 (eq, ":return_code", -7),
				 (assign, ":player_id", reg1),
				 (player_get_unique_id, reg1, ":player_id"),
				 (str_store_string, s0, "@Your GUID is {reg1}, It's seem you enter a wrong name, please contact admin."),
				 (multiplayer_send_string_to_player, ":player_id", server_event_admin_chat_announce, s0),
				 (store_mission_timer_a, ":time"),
				 (val_add, ":time", name_server_kick_delay_interval),
				 (player_set_slot, ":player_id", slot_player_kick_at_time, ":time"),

			(else_try),
				 (eq, ":return_code", -8),
				 (assign, ":player_id", reg1),
				 (player_get_unique_id, reg1, ":player_id"),
				 (str_store_string, s0, "@Your GUID is {reg1}, The key has been registered too many names."),
				 (multiplayer_send_string_to_player, ":player_id", server_event_admin_chat_announce, s0),
				 (store_mission_timer_a, ":time"),
				 (val_add, ":time", name_server_kick_delay_interval),
				 (player_set_slot, ":player_id", slot_player_kick_at_time, ":time"),     

			#(else_try),
			#   (eq, ":return_code", -9),
			#   (assign, ":player_id", reg1),
			#   (str_store_string, s0, "@Change your ID success."),
			#   (multiplayer_send_string_to_player, ":player_id", server_event_admin_chat_announce, s0),
			#   (store_mission_timer_a, ":time"),
			#   (val_add, ":time", name_server_kick_delay_interval),
			#   (player_set_slot, ":player_id", slot_player_kick_at_time, ":time"),           
			###   

			(else_try),
				 (eq, ":return_code", -6), #Player ist gebannt
				 (assign, ":player_id", reg1),
				 (player_get_unique_id, reg1, ":player_id"),
				 (str_store_string, s0, "@Your GUID is {reg1}, You are banned on this server please check our forums or contact an admin!"),
				 (multiplayer_send_string_to_player, ":player_id", server_event_admin_chat_announce, s0),
				 (store_mission_timer_a, ":time"), # kick the player after a short delay to try ensure they see the rejection message
				 (val_add, ":time", name_server_kick_delay_interval),
				 (player_set_slot, ":player_id", slot_player_kick_at_time, ":time"),

			(else_try),
				 (eq, ":return_code", 9),
				 #recorded punishment, alles ok

			(else_try),
				 (eq, ":return_code", 4), #Player hebt Geld von Bank ab
				 (assign, ":player_id", reg1),
				 (assign, ":goldbekommen", reg2), #was wir bekommen
				 (gt, ":goldbekommen", 0),
				 (call_script, "script_player_adjust_gold", ":player_id", ":goldbekommen", 1),
			#Add Sound
				 (assign, ":sound", "snd_money_received"),
				 (player_get_agent_id, ":agent_id", ":player_id"),
				 (gt, ":agent_id", -1),
				 (agent_is_alive, ":agent_id"),
				 (agent_play_sound, ":agent_id", ":sound"),
	 
				 (str_store_string, s0, "@Withdrawn: {reg2} gold from your bank, new bank value: {reg3} gold"),
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),

			###GGG:new bank
				 (player_set_slot, ":player_id", slot_player_must_enter_amount, 0),

			(else_try),
				 (eq, ":return_code", 5), #Player tut Geld auf Bank drauf
				 (assign, ":player_id", reg1),
				 (assign, ":goldbekommen", reg2),
				 (assign, ":newcarriedgold", reg4),
				 (call_script, "script_player_adjust_gold", ":player_id", ":newcarriedgold", 0),
			#Add Sound
				 (assign, ":sound", "snd_money_paid"),
				 (player_get_agent_id, ":agent_id", ":player_id"),
				 (gt, ":agent_id", -1),
				 (agent_is_alive, ":agent_id"),
				 (agent_play_sound, ":agent_id", ":sound"),
	 
				 (str_store_string, s0, "@Deposited: {reg2} gold to your bank, new bank value: {reg3} gold"),
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),

				 ###GGG:new bank
				 (player_set_slot, ":player_id", slot_player_must_enter_amount, 0),
	 
			(else_try),
				 (eq, ":return_code", 6), # Player doesnt have money to deposit or the bank is empty and he cant take out
				 # Do nothing
			
			###GGG:new bank
			(else_try),
				 (eq, ":return_code", 7),
				 (assign, ":player_id", reg1),
				 (player_is_active, ":player_id"),

				 (player_get_slot, ":old_gold", ":player_id", slot_player_gold_give_back),
				 (call_script, "script_player_adjust_gold", ":player_id", ":old_gold", 0),
				 (player_set_slot, ":player_id", slot_player_gold_give_back, 0),

				 (str_store_string, s0, "str_no_number_entered_error"),
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),
				 (player_set_slot, ":player_id", slot_player_must_enter_amount, 0),

			(else_try),
				 (eq, ":return_code", 8),
				 (assign, ":player_id", reg1),
				 (player_is_active, ":player_id"),

				 (player_get_slot, ":old_gold", ":player_id", slot_player_gold_give_back),
				 (call_script, "script_player_adjust_gold", ":player_id", ":old_gold", 0),
				 (player_set_slot, ":player_id", slot_player_gold_give_back, 0),

				 (str_store_string, s0, "str_cannot_deposit_too_little_gold"),
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),
				 (player_set_slot, ":player_id", slot_player_must_enter_amount, 0),

			(else_try),
				 (eq, ":return_code", 10),
				 (assign, ":player_id", reg1),
				 (player_is_active, ":player_id"),

				 (str_store_string, s0, "str_cannot_withdraw_too_little_gold"),
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),

				 (player_set_slot, ":player_id", slot_player_must_enter_amount, 0),

			(else_try),
				 (eq, ":return_code", 11),
				 (assign, ":player_id", reg1),
				 (player_is_active, ":player_id"),
				
				 (str_store_string, s0, "str_cannot_deposit_negative_amount"),
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),

				 (player_set_slot, ":player_id", slot_player_must_enter_amount, 0),
				
				 (player_get_slot, ":old_gold", ":player_id", slot_player_gold_give_back),
				 (call_script, "script_player_adjust_gold", ":player_id", ":old_gold", 0),

			(else_try),
				 (eq, ":return_code", 12),
				 (assign, ":player_id", reg1),
				 (player_is_active, ":player_id"),
				
				 (str_store_string, s0, "str_cannot_withdraw_negative_amount"),
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),

				 (player_set_slot, ":player_id", slot_player_must_enter_amount, 0),

			(else_try),
				 (eq, ":return_code", 13),
				 (assign, ":player_id", reg1),
				 (player_is_active, ":player_id"),

				 (player_set_slot, ":player_id", slot_player_gold_give_back, 0),
				 
				 (str_store_string, s0, "str_no_number_entered_error"),
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),
				 (player_set_slot, ":player_id", slot_player_must_enter_amount, 0),

			###GGG:skill
			(else_try),
				 (eq, ":return_code", 87),
				 (assign, ":player_id", reg1),
				 (player_is_active, ":player_id"),
				 (player_get_troop_id, ":troop_id", ":player_id"),
				 (is_between, ":troop_id", hero_begin, hero_end),

				 (troop_raise_attribute, ":troop_id", ca_strength, -20),
				 (troop_raise_attribute, ":troop_id", ca_agility, -20),
				 (troop_raise_skill, ":troop_id", skl_ironflesh, -10),
				 (troop_raise_skill, ":troop_id", skl_power_strike, -10),
				 (troop_raise_skill, ":troop_id", skl_power_draw, -10),
				 (troop_raise_skill, ":troop_id", skl_power_throw, -10),
				 (troop_raise_skill, ":troop_id", skl_shield, -10),
				 (troop_raise_skill, ":troop_id", skl_athletics, -10),
				 (troop_raise_skill, ":troop_id", skl_riding, -10),
				 (troop_raise_skill, ":troop_id", skl_engineer, -10),
				 (troop_raise_skill, ":troop_id", skl_wound_treatment, -10),
				 (troop_raise_skill, ":troop_id", skl_labouring, -10),
				 (troop_raise_skill, ":troop_id", skl_looting, -10),
				 (troop_raise_skill, ":troop_id", skl_sailing, -10),
				 (troop_raise_skill, ":troop_id", skl_tailoring, -10),
				 (troop_raise_skill, ":troop_id", skl_herding, -10),
				 (troop_raise_proficiency_linear, ":troop_id", wpt_one_handed_weapon, -200),
				 (troop_raise_proficiency_linear, ":troop_id", wpt_two_handed_weapon, -200),
				 (troop_raise_proficiency_linear, ":troop_id", wpt_polearm, -200),
				 (troop_raise_proficiency_linear, ":troop_id", wpt_archery, -200),
				 (troop_raise_proficiency_linear, ":troop_id", wpt_crossbow, -200),
				 (troop_raise_proficiency_linear, ":troop_id", wpt_throwing, -200),

				 (troop_raise_attribute, ":troop_id", ca_strength, reg2),
				 (troop_raise_attribute, ":troop_id", ca_agility, reg3),
				 (troop_raise_skill, ":troop_id", skl_ironflesh, reg4),
				 (troop_raise_skill, ":troop_id", skl_power_strike, reg5),
				 (troop_raise_skill, ":troop_id", skl_power_draw, reg6),
				 (troop_raise_skill, ":troop_id", skl_power_throw, reg7),
				 (troop_raise_skill, ":troop_id", skl_shield, reg8),
				 (troop_raise_skill, ":troop_id", skl_athletics, reg9),
				 (troop_raise_skill, ":troop_id", skl_riding, reg10),
				 (troop_raise_skill, ":troop_id", skl_engineer, reg11),
				 (troop_raise_skill, ":troop_id", skl_wound_treatment, reg12),
				 (troop_raise_skill, ":troop_id", skl_labouring, reg13),
				 (troop_raise_skill, ":troop_id", skl_looting, reg14),
				 (troop_raise_skill, ":troop_id", skl_sailing, reg15),
				 (troop_raise_skill, ":troop_id", skl_tailoring, reg16),
				 (troop_raise_skill, ":troop_id", skl_herding, reg17),
				 (troop_raise_proficiency_linear, ":troop_id", wpt_one_handed_weapon, reg18),
				 (troop_raise_proficiency_linear, ":troop_id", wpt_two_handed_weapon, reg19),
				 (troop_raise_proficiency_linear, ":troop_id", wpt_polearm, reg20),
				 (troop_raise_proficiency_linear, ":troop_id", wpt_archery, reg21),
				 (troop_raise_proficiency_linear, ":troop_id", wpt_crossbow, reg22),
				 (troop_raise_proficiency_linear, ":troop_id", wpt_throwing, reg23),
				 (player_set_slot, ":player_id", slot_player_used_skill_points, reg24),
				 (player_set_slot, ":player_id", slot_player_unused_skill_points, reg25),

				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_troop_strength, reg2),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_troop_agility, reg3),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_troop_ironflesh, reg4),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_troop_power_strike, reg5),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_troop_power_draw, reg6),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_troop_power_throw, reg7),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_troop_shield, reg8),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_troop_athletics, reg9),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_troop_riding, reg10),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_troop_engineer, reg11),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_troop_wound_treatment, reg12),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_troop_labouring, reg13),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_troop_looting, reg14),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_troop_sailing, reg15),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_troop_tailoring, reg16),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_troop_herding, reg17),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_troop_one_handed_weapon, reg18),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_troop_two_handed_weapon, reg19),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_troop_polearm, reg20),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_troop_archery, reg21),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_troop_crossbow, reg22),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_troop_throwing, reg23),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_used_skill_points, reg24),
				 (multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_unused_skill_points, reg25),
				 
			###GGG:house chest
			(else_try),
				 (eq, ":return_code", 88),
				 (assign, ":chest_id", reg1),
				 (assign, ":found_chest", 0), 
				 (scene_prop_get_num_instances, ":max_instances", "spr_pw_item_chest_a"),
				 (val_add, ":max_instances", 1),
				 (try_for_range, ":current_instance", 0, ":max_instances"),
					(eq, ":found_chest", 0),
					(scene_prop_get_instance, ":chest_instance", "spr_pw_item_chest_a", ":current_instance"),
					(prop_instance_is_valid, ":chest_instance"),
					(prop_instance_get_variation_id_2, ":chest_id_searched", ":chest_instance"),
					(eq, ":chest_id_searched", ":chest_id"),
					(assign, ":instance_id", ":chest_instance"),
					(assign, ":found_chest", 1),
				 (try_end),

				 (eq, ":found_chest", 1),
				 (prop_instance_is_valid, ":instance_id"),

				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, reg2),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 1, reg3),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 2, reg4),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 3, reg5),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 4, reg6),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 5, reg7),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 6, reg8),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 7, reg9),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 8, reg10),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 9, reg11),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 10, reg12),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 11, reg13),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 12, reg14),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 13, reg15),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 14, reg16),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 15, reg17),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 16, reg18),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 17, reg19),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 18, reg20),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 19, reg21),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 20, reg22),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 21, reg23),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 22, reg24),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 23, reg25),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 24, reg26),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 25, reg27),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 26, reg28),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 27, reg29),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 28, reg30),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 29, reg31),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 30, reg32),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 31, reg33),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 32, reg34),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 33, reg35),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 34, reg36),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 35, reg37),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 36, reg38),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 37, reg39),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 38, reg40),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 39, reg41),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 40, reg42),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 41, reg43),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 42, reg44),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 43, reg45),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 44, reg46),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 45, reg47),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 46, reg48),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 47, reg49),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 48, reg50),

				 (assign, reg52, ":chest_id"),
				 (str_store_string, s21, "@{reg2}|{reg3}|{reg4}|{reg5}|{reg6}|{reg7}|{reg8}|{reg9}|{reg10}|{reg11}|{reg12}|{reg13}|{reg14}|{reg15}|{reg16}|{reg17}|{reg18}|{reg19}|{reg20}|{reg21}|{reg22}|{reg23}|{reg24}|{reg25}|{reg26}|{reg27}|{reg28}|{reg29}|{reg30}|{reg31}|{reg32}|{reg33}|{reg34}|{reg35}|{reg36}|{reg37}|{reg38}|{reg39}|{reg40}|{reg41}|{reg42}|{reg43}|{reg44}|{reg45}|{reg46}|{reg47}|{reg48}|{reg49}|{reg50}"),
				 (server_add_message_to_log, "@Loaded chest: {reg52} items {s21} succesfully into the game."),

			#GGG:item chest
			(else_try),
				 (eq, ":return_code", 89),
				 (assign, ":player_id", reg1),
				 (player_get_unique_id, ":player_guid", ":player_id"),

				 (player_get_slot, ":instance_id", ":player_id", slot_player_last_instance_id),

				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, reg2),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 1, reg3),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 2, reg4),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 3, reg5),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 4, reg6),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 5, reg7),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 6, reg8),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 7, reg9),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 8, reg10),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 9, reg11),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 10, reg12),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 11, reg13),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 12, reg14),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 13, reg15),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 14, reg16),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 15, reg17),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 16, reg18),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 17, reg19),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 18, reg20),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 19, reg21),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 20, reg22),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 21, reg23),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 22, reg24),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 23, reg25),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 24, reg26),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 25, reg27),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 26, reg28),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 27, reg29),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 28, reg30),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 29, reg31),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 30, reg32),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 31, reg33),
				 (scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 32, reg34),

				 (str_store_string, s0, "@You have accessed your item bank."),
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),

				 (assign, reg52, ":player_guid"),
				 (str_store_string, s21, "@{reg2}|{reg3}|{reg4}|{reg5}|{reg6}|{reg7}|{reg8}|{reg9}|{reg10}|{reg11}|{reg12}|{reg13}|{reg14}|{reg15}|{reg16}|{reg17}|{reg18}|{reg19}|{reg20}|{reg21}|{reg22}|{reg23}|{reg24}|{reg25}|{reg26}|{reg27}|{reg28}|{reg29}|{reg30}|{reg31}|{reg32}|{reg33}|{reg34}"),
				 (server_add_message_to_log, "@Loaded private chest: {reg52} items {s21} succesfully into the game."),

	###GGG:igcommand
			#(else_try),
			#    (eq, ":return_code", 10), #failbankchange

			(else_try),
				 (eq, ":return_code", 20),
				 (assign, ":player_id", reg1),
				 (player_get_unique_id, ":guid", ":player_id"),
				 (assign, reg1, ":guid"),
				 (str_store_string, s1, "@your guid is {reg1}"),
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s1),

			(else_try),
				 (eq, ":return_code", 21),
				 (assign, ":player_id", reg1),
				 (str_store_string, s1, "@your invitation code is {reg2}"),
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s1),          

			(else_try),
				 (eq, ":return_code", 22),
				 (assign, ":player_id", reg1),
				 (str_store_string, s1, "@you have {reg2} dnr in bank"),
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s1),

			#(else_try),
			#    (eq, ":return_code", 24),
			#    (assign, ":player_id", reg1),
			#    (player_is_admin, ":player_id"),
			#    (try_begin),
			#      (eq, "$no_global_chat", 0),
			#      (assign, "$no_global_chat", 1),
			#      (str_store_string, s1, "@all the players is muted now"),
			#      (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s1),
			#    (else_try),
			#      (eq, "$no_global_chat", 1),
			#      (assign, "$no_global_chat", 0),          
			#      (str_store_string, s1, "@all the players lift muted now"),
			#      (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s1),
			#    (try_end),

	###
	#GGG:checkchest
	#   (else_try),
	#        (eq, ":return_code", 101),
	#        (assign, ":player_id", reg1),
	#        (player_is_active, ":player_id"),
	#         
	#        (str_store_string, s0, "@You can open your house chest!"),
	#        (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),
	#        (assign, ":loop_stop", 0),
	#        (scene_prop_get_num_instances, ":max_instances", "spr_pw_item_chest_a"),
	#        (val_add, ":max_instances", 1),
	#        
	#        (try_for_range, ":current_door", 0, ":max_instances"),
	#          (eq, ":loop_stop", 0),
	#          (scene_prop_get_instance, ":current_instance", "spr_pw_item_chest_a", ":current_door"),
	#          (prop_instance_is_valid, ":current_instance"),
	#          (prop_instance_get_variation_id_2, ":var_2", ":current_instance"),
	#          (eq, ":var_2", reg2),
	#          (assign, ":loop_stop", 1),
	#        (try_end),
	#        
	#        (call_script, "script_cf_open_chest", ":current_instance", 0),
	#
	#    (else_try),
	#        (eq, ":return_code", 102),
	#        (assign, ":player_id", reg1),
	#        (player_is_active, ":player_id"),
	#        
	#        (str_store_string, s0, "@This is not your house chest!"),
	#        (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),
	#    (try_end),
	##
			(else_try),
				 (eq, ":return_code", 101), #faction load
				 (assign, ":faction_id", reg1),
				 (assign, ":banner_mesh", reg2),
				 (assign, ":military_strength", reg3),
				 (faction_set_name, ":faction_id", s0),
				 (faction_set_slot, ":faction_id", slot_faction_name_is_custom, 1),
				 (faction_set_slot, ":faction_id", slot_faction_banner_mesh, ":banner_mesh"),
				 (call_script, "script_faction_set_color_from_banner", ":faction_id", ":banner_mesh"),
				 (faction_set_slot, ":faction_id", slot_faction_military_strength, ":military_strength"),

			(else_try),
				 (eq, ":return_code", 103), #its his house
				 (assign, ":player_id", reg1),
				 (player_is_active, ":player_id"),
					#reg 2 is house id
				(str_store_player_username, s98, ":player_id"),
				(server_add_message_to_log, "@{s98} opened door number {reg2}"),
				 (str_store_string, s0, "@Welcome home!"),
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),
				 (assign, ":loop_stop", 0),
				 (scene_prop_get_num_instances, ":max_instances", "spr_pw_door_rotate_dungeon_b"), #GGG:spr_pw_door_rotate_dungeon_cell_b
				 (val_add, ":max_instances", 1),
					
				 (try_for_range, ":current_door", 0, ":max_instances"),
						(eq, ":loop_stop", 0),
						(scene_prop_get_instance, ":current_instance", "spr_pw_door_rotate_dungeon_b", ":current_door"),#GGG:spr_pw_door_rotate_dungeon_cell_b
						(prop_instance_is_valid, ":current_instance"),
						(prop_instance_get_variation_id_2, ":var_2", ":current_instance"),
						(eq, ":var_2", reg2),
						(assign, ":loop_stop", 1),
				 (try_end),
					
				 (call_script, "script_cf_rotate_door", ":current_instance", 0),
	
			(else_try),
				 (eq, ":return_code", 104), #not his house
				 (assign, ":player_id", reg1),
				 (player_is_active, ":player_id"),
					#reg 2 is house id
					
				 (str_store_string, s0, "@This is not your house!"),
				 (str_store_player_username, s98, ":player_id"),
				 (server_add_message_to_log, "@{s98} failed to open door number {reg2}"),
				 (multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),
			(try_end),

		(else_try), #Falls kein Code aufeinander passt wird der Nameserver gefickt sein
			(server_add_message_to_log, "str_name_server_invalid_response"),
		(try_end),
		]),

	("game_get_cheat_mode", []),

	("game_receive_network_message", # called by the game whenever a custom network message is received, both clients and servers
	 [(store_script_param, ":sender_player_id", 1),
		(store_script_param, ":event_type", 2),

		(try_begin), # section of events received by clients from the server
			(neg|multiplayer_is_server),
			(try_begin), # displays preset messages sent from the server as a module string id, rather than the actual text
				(eq, ":event_type", server_event_preset_message),
				(store_script_param, ":string_id", 3),
				(store_script_param, ":flags", 4),
				(store_script_param, ":value_1", 5),
				(store_script_param, ":value_2", 6),
				(call_script, "script_preset_message", ":string_id", ":flags", ":value_1", ":value_2"),
			(else_try),
				#Arthur begins
				(eq, ":event_type", server_event_player_exit_return),
				(store_script_param, ":result", 3),
				(try_begin),
					(eq, ":result", 0),
					(display_message, "@You have nearby enemies! Please retreat to a safe area and try again!", 0xFFFF22),
				(else_try),
					(display_message, "@Disconnecting...", 0xFFFF22),
					(finish_mission, 0),
				(try_end),
			(else_try),
				(eq, ":event_type", server_event_player_set_cam),
				(store_script_param, ":x", 3),
				(store_script_param, ":y", 4),
				(store_script_param, ":z", 5),
				(try_begin),
					(eq, ":x", 5123), #reset cam
					(mission_cam_set_mode, 0, 0),
				(else_try),
					(init_position, pos0),
					(position_set_x, pos0, ":x"),
					(position_set_y, pos0, ":y"),
					(position_set_z, pos0, ":z"),
					(position_move_z, pos0, 1000),
				    (position_rotate_x, pos0, -90),
				    (mission_cam_set_mode, 1, 0),
				    (mission_cam_animate_to_position, pos0, 2000),
				(try_end),
			(else_try), # play a non 3D interface sound
				(eq, ":event_type", server_event_play_sound),
				(store_script_param, ":sound_id", 3),
				(try_begin),
					(is_between, ":sound_id", 0, "snd_sounds_end"),
					(play_sound, ":sound_id"),
				(try_end),
			(else_try), # play a sound at the location of a scene prop
				(eq, ":event_type", server_event_scene_prop_play_sound),
				(store_script_param, ":instance_id", 3),
				(assign, ":sound_id", ":instance_id"),
				(val_rshift, ":sound_id", net_sound_shift), # sound id is the higher bits
				(val_and, ":instance_id", net_sound_mask), # instance id is lower bits
				(try_begin),
					(is_between, ":sound_id", 0, "snd_sounds_end"),
					(prop_instance_is_valid, ":instance_id"),
					(prop_instance_get_position, pos1, ":instance_id"),
					(play_sound_at_position, ":sound_id", pos1),
				(try_end),
			(else_try), # play a sound at a position, the coordinate values packed into one integer for a smaller network message
				(eq, ":event_type", server_event_play_sound_at_position),
				(store_script_param, ":sound_id", 3),
				(store_script_param, ":packed_position", 4),
				(try_begin), # extract sound id and position x,y,z from one number
					(is_between, ":sound_id", 0, "snd_sounds_end"),
					(assign, ":pos_x", ":packed_position"),
					(val_and, ":pos_x", net_pack_3_mask_1),
					(assign, ":pos_y", ":packed_position"),
					(val_and, ":pos_y", net_pack_3_mask_2),
					(val_rshift, ":pos_y", net_pack_3_shift_2),
					(assign, ":pos_z", ":packed_position"),
					(val_and, ":pos_z", net_pack_3_mask_3),
					(val_rshift, ":pos_z", net_pack_3_shift_3),
					(val_sub, ":pos_z", net_pack_3_value_upper_bound / 2),
					(set_fixed_point_multiplier, 1),
					(position_set_x, pos1, ":pos_x"),
					(position_set_y, pos1, ":pos_y"),
					(position_set_z, pos1, ":pos_z"),
					(set_fixed_point_multiplier, 100),
					(play_sound_at_position, ":sound_id", pos1),
				(try_end),
			(else_try), # equip the visual armor mesh on an agent
				(eq, ":event_type", server_event_agent_equip_armor),
				(store_script_param, ":agent_id", 3),
				(store_script_param, ":item_id", 4),
				(try_begin),
					(agent_is_active, ":agent_id"),
					(agent_is_alive, ":agent_id"),
					(try_begin),
						(gt, ":item_id", -1),
						(call_script, "script_agent_equip_armor", ":agent_id", ":item_id"),
					(else_try),
						(call_script, "script_agent_clean_blood", ":agent_id"),
					(try_end),
				(try_end),
			(else_try), # set a player slot on the client, from the server
				(eq, ":event_type", server_event_player_set_slot),
				(store_script_param, ":player_id", 3),
				(store_script_param, ":slot_no", 4),
				(store_script_param, ":value", 5),
				(try_begin),
					(player_is_active, ":player_id"),
					(player_set_slot, ":player_id", ":slot_no", ":value"),
					(multiplayer_get_my_player, ":my_player_id"),
					(try_begin), # if the player's faction is changed, reset other related slots
						(eq, ":slot_no", slot_player_faction_id),
						(player_set_slot, ":player_id", slot_player_is_lord, 0),
						(player_set_slot, ":player_id", slot_player_has_faction_door_key, 0),
						(player_set_slot, ":player_id", slot_player_has_faction_money_key, 0),
						(player_set_slot, ":player_id", slot_player_has_faction_item_key, 0),
						(player_set_slot, ":player_id", slot_player_can_faction_announce, 0),
						(store_script_param, ":change_faction_type", 6),
						(try_begin),
							(eq, ":change_faction_type", change_faction_type_outlawed),
							(try_begin),
								(eq, ":player_id", ":my_player_id"),
								(call_script, "script_preset_message", "str_you_have_been_outlawed", preset_message_faction|preset_message_log, ":value", 0),
								(music_set_situation, mtf_sit_town_infiltrate),
							(else_try),
								(str_store_player_username, s0, ":player_id"),
								(faction_get_color, ":color", "fac_outlaws"),
								(display_message, "str_s0_has_been_outlawed", ":color"),
							(try_end),
						(else_try),
							(eq, ":player_id", ":my_player_id"),
							(call_script, "script_preset_message", "str_joined_the_s1", preset_message_faction|preset_message_log, ":value", 0),
						(try_end),
						(try_begin), # if changing faction without changing troop (respawning), re-equip armor to trigger redrawing heraldry
							(eq, ":change_faction_type", change_faction_type_no_respawn),
							(call_script, "script_player_redraw_heraldic_items", ":player_id"),
						(try_end),
						(try_begin), # adjust the music style for commoners, outlaws, factions
							(eq, ":player_id", ":my_player_id"),
							(try_begin),
								(ge, ":value", castle_factions_begin),
								(music_set_culture, mtf_culture_3),
							(else_try),
								(eq, ":value", "fac_outlaws"),
								(music_set_culture, mtf_culture_2),
							(else_try),
								(music_set_culture, mtf_culture_1),
							(try_end),
						(try_end),
					(else_try),
						(eq, ":slot_no", slot_player_outlaw_rating),
						(eq, ":player_id", ":my_player_id"),
						(faction_get_color, ":color", "fac_outlaws"),
						(assign, reg1, ":value"),
						(display_message, "str_your_outlaw_rating_now_reg1", ":color"),
					(else_try),
						(eq, ":slot_no", slot_player_is_lord),
						(eq, ":value", 1),
						(player_get_slot, ":faction_id", ":player_id", slot_player_faction_id),
						(get_max_players, ":max_players"),
						(try_for_range, ":other_player_id", 1, ":max_players"), # remove the status of any previous lord of the faction
							(neq, ":other_player_id", ":player_id"),
							(player_is_active, ":other_player_id"),
							(player_slot_eq, ":other_player_id", slot_player_faction_id, ":faction_id"),
							(player_set_slot, ":other_player_id", slot_player_is_lord, 0),
						(try_end),
						(try_begin), # if the local player is now lord of their faction, set various slots that have already been set on the server
							(eq, ":player_id", ":my_player_id"),
							(call_script, "script_preset_message", "str_you_are_now_lord_of_s1", preset_message_faction|preset_message_log|preset_message_big, ":faction_id", 0),
							(player_set_slot, ":my_player_id", slot_player_has_faction_door_key, 1),
							(player_set_slot, ":player_id", slot_player_has_faction_money_key, 1),
							(player_set_slot, ":player_id", slot_player_has_faction_item_key, 1),
							(player_set_slot, ":player_id", slot_player_can_faction_announce, 1),
							(player_set_slot, ":player_id", slot_player_faction_chat_muted, 0),
						(else_try), # for other players, just display an announcement
							(eq, "$g_preset_message_display_enabled", 1),
							(str_store_player_username, s10, ":player_id"),
							(call_script, "script_preset_message", "str_s10_now_lord_of_s1", preset_message_faction|preset_message_log|preset_message_big, ":faction_id", 0),
						(try_end),
					(try_end),
				(try_end),
			(else_try), # set a troop slot on the client, from the server
				(eq, ":event_type", server_event_troop_set_slot),
				(store_script_param, ":troop_id", 3),
				(store_script_param, ":slot_no", 4),
				(store_script_param, ":value", 5),
				(troop_get_slot, ":old_value", ":troop_id", ":slot_no"),
				(troop_set_slot, ":troop_id", ":slot_no", ":value"),
				(try_begin),
					(eq, ":troop_id", "trp_mission_data"),
					(eq, "$g_preset_message_display_enabled", 1),
					(is_between, ":slot_no", slot_mission_data_castle_owner_faction_begin, slot_mission_data_castle_owner_faction_end),
					(call_script, "script_preset_message", "str_s1_captured_s2", preset_message_faction_castle|preset_message_big|preset_message_log, ":value", ":slot_no"),
					(multiplayer_get_my_player, ":my_player_id"),
					(player_is_active, ":my_player_id"),
					(player_get_slot, ":my_faction_id", ":my_player_id", slot_player_faction_id),
					(try_begin),
						(eq, ":value", ":my_faction_id"),
						(music_set_situation, mtf_sit_victorious),
					(else_try),
						(eq, ":old_value", ":my_faction_id"),
						(music_set_situation, mtf_sit_encounter_hostile),
					(try_end),
				(try_end),
			(else_try), # set a scene prop slot on the client, from the server
				(eq, ":event_type", server_event_scene_prop_set_slot),
				(store_script_param, ":instance_id", 3),
				(store_script_param, ":slot_no", 4),
				(store_script_param, ":value", 5),
				(store_script_param, ":slot_range_end", 6),
				(try_begin),
					(prop_instance_is_valid, ":instance_id"),
					(try_begin),
						(ge, ":slot_no", 0),
						(scene_prop_set_slot, ":instance_id", ":slot_no", ":value"),
						(is_between, ":slot_range_end", slot_scene_prop_inventory_begin, slot_scene_prop_inventory_end),
						(store_add, ":slot_range_begin", ":slot_no", 1), # messages to change inventory slots can be ranges of repeated values, for efficiency
						(ge, ":slot_range_begin", slot_scene_prop_inventory_begin),
						(try_for_range, ":current_slot_no", ":slot_range_begin", ":slot_range_end"),
							(scene_prop_set_slot, ":instance_id", ":current_slot_no", ":value"),
						(try_end),
					(try_end), # if the scene prop updated is the inventory currently being accessed, store the changed slots for refreshing the presentation
					(eq, ":instance_id", "$g_show_inventory_instance_id"),
					(try_begin), # negative numbers mark removed items
						(le, ":slot_range_end", -1),
						(store_mul, ":slot_moved_from", ":slot_range_end", -1),
						(is_between, ":slot_moved_from", slot_scene_prop_inventory_mod_begin, slot_scene_prop_inventory_mod_end),
						(scene_prop_set_slot, ":instance_id", ":slot_moved_from", -1),
						(assign, "$g_show_inventory_update_needed", 1),
					(else_try), # otherwise the item was added to the inventory
						(is_between, ":slot_no", slot_scene_prop_inventory_mod_begin, slot_scene_prop_inventory_mod_end),
						(assign, "$g_show_inventory_update_needed", 1),
					(try_end),
				(try_end),
			(else_try), # set a faction slot on the client, from the server
				(eq, ":event_type", server_event_faction_set_slot),
				(store_script_param, ":faction_id", 3),
				(store_script_param, ":slot_no", 4),
				(store_script_param, ":value", 5),
				(try_begin),
					(is_between, ":faction_id", factions_begin, factions_end),
					(faction_get_slot, ":previous_value", ":faction_id", ":slot_no"),
					(faction_set_slot, ":faction_id", ":slot_no", ":value"),
					(try_begin),
						(eq, ":slot_no", slot_faction_banner_mesh),
						(call_script, "script_faction_set_color_from_banner", ":faction_id", ":value"),
						(call_script, "script_faction_redraw_heraldic_items", ":faction_id"),
					(else_try),
						(ge, ":slot_no", slot_faction_relations_begin),
						(eq, "$g_preset_message_display_enabled", 1),
						(store_sub, ":other_faction_id", ":slot_no", slot_faction_relations_begin),
						(lt, ":other_faction_id", factions_end),
						(call_script, "script_display_faction_relation_change", ":faction_id", ":other_faction_id", ":previous_value", ":value"),
					(try_end),
				(try_end),
			(else_try), # set an agent slot on the client, from the server
				(eq, ":event_type", server_event_agent_set_slot),
				(store_script_param, ":agent_id", 3),
				(store_script_param, ":slot_no", 4),
				(store_script_param, ":value", 5),
				(try_begin),
					(agent_is_active, ":agent_id"),
					(agent_set_slot, ":agent_id", ":slot_no", ":value"),
				(try_end),
			(else_try), # attach or detach a scene prop to or from an agent (used for carts)
				(eq, ":event_type", server_event_set_attached_scene_prop),
				(store_script_param, ":agent_id", 3),
				(store_script_param, ":instance_id", 4),
				(try_begin),
					(agent_is_active, ":agent_id"),
					(agent_get_attached_scene_prop, ":previous_instance_id", ":agent_id"),
					(try_begin),
						(prop_instance_is_valid, ":previous_instance_id"),
						(scene_prop_set_slot, ":previous_instance_id", slot_scene_prop_attached_to_agent, -1),
						(prop_instance_enable_physics, ":previous_instance_id", 1), #GGG:fix cart bug
					(try_end),
					(agent_set_attached_scene_prop, ":agent_id", ":instance_id"),
					(prop_instance_is_valid, ":instance_id"),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_attached_to_agent, ":agent_id"),
					#GGG:fix cart bug
					(try_begin),
						(gt, ":instance_id", -1),
						(prop_instance_enable_physics, ":instance_id", 0),
					(try_end),
					#
				(try_end),
			(else_try), # showing the presentation for accessing the inventory of a scene prop
				(eq, ":event_type", server_event_show_inventory),
				(store_script_param, ":instance_id", 3),
				(try_begin), # showing
					(gt, ":instance_id", 0),
					(prop_instance_is_valid, ":instance_id"),
					(assign, "$g_show_inventory_instance_id", ":instance_id"),
					(try_for_range, ":mod_slot", slot_scene_prop_inventory_mod_begin, slot_scene_prop_inventory_obj_begin),
						(scene_prop_set_slot, ":instance_id", ":mod_slot", 0), # clear slots that notify modifications
					(try_end),
					(val_add, "$g_last_inventory_unique_id", 1), # this value can be different between server and clients, but is only used locally
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_unique_id, "$g_last_inventory_unique_id"),
					(start_presentation, "prsnt_show_inventory"),
				(else_try), # hiding, when now out of range or similar
					(eq, ":instance_id", -1),
					(is_presentation_active, "prsnt_show_inventory"),
					(assign, "$g_show_inventory_update_needed", -1),
				(try_end),
			(else_try), # the server replied that a chat message was received, so if matching the latest message, mark as not requring resending
				(eq, ":event_type", server_event_chat_message_recieved),
				(store_script_param, ":chat_event_type", 3),
				(try_begin),
					(troop_get_slot, ":last_chat_event_type", "trp_last_chat_message", slot_last_chat_message_event_type),
					(val_and, ":last_chat_event_type", net_chat_event_mask),
					(val_and, ":chat_event_type", net_chat_event_mask),
					(eq, ":chat_event_type", ":last_chat_event_type"),
					(troop_set_slot, "trp_last_chat_message", slot_last_chat_message_not_recieved, 0),
				(try_end),
			(else_try), # display normal local chat
				(eq, ":event_type", server_event_local_chat),
				(neg|str_is_empty, s0),
				(display_message, s0, local_chat_color),
				(call_script, "script_chat_overlay_add_to_local_buffer", local_chat_color),
			(else_try), # display shouting in local chat
				(eq, ":event_type", server_event_local_chat_shout),
				(neg|str_is_empty, s0),
				(display_message, s0, local_chat_shout_color),
				(call_script, "script_chat_overlay_add_to_local_buffer", local_chat_shout_color),
			(else_try), # change the name of the faction which has been previously marked
				(eq, ":event_type", server_event_faction_set_name),
				(try_begin),
					(neg|str_is_empty, s0),
					(troop_get_slot, ":faction_id", "trp_mission_data", slot_mission_data_faction_to_change_name_of),
					(troop_set_slot, "trp_mission_data", slot_mission_data_faction_to_change_name_of, 0),
					(is_between, ":faction_id", castle_factions_begin, factions_end),
					(str_store_faction_name, s10, ":faction_id"),
					(faction_set_name, ":faction_id", s0),
					(eq, "$g_preset_message_display_enabled", 1),
					(call_script, "script_preset_message", "str_s10_now_known_as_s1", preset_message_faction|preset_message_log|preset_message_big, ":faction_id", 0),
					#(call_script, "script_cf_save_faction", ":faction_id"), #GGG:save factions
				(try_end),
			(else_try), # update the global variables for server settings on the client
				(eq, ":event_type", server_event_return_game_rules),
				(store_script_param, ":command", 3),
				(store_script_param, ":value", 4),
				(try_begin),
					(call_script, "script_cf_execute_command", ":command", ":value"),
				(try_end),
			(else_try), # store the server name
				(eq, ":event_type", server_event_return_server_name),
				(server_set_name, s0),
			(else_try), # store the server password
				(eq, ":event_type", server_event_return_password),
				(server_set_password, s0),
			(else_try), # set the stats of existing players when connecting to a server
				(eq, ":event_type", server_event_set_player_score_kill_death),
				(store_script_param, ":player_id", 3),
				(store_script_param, ":score", 4),
				(store_script_param, ":kills", 5),
				(store_script_param, ":deaths", 6),
				(try_begin),
					(player_is_active, ":player_id"),
					(player_set_score, ":player_id", ":score"),
					(player_set_kill_count, ":player_id", ":kills"),
					(player_set_death_count, ":player_id", ":deaths"),
				(try_end),
			(else_try), # show the poll presentation
				(eq, ":event_type", server_event_show_poll),
				(store_script_param, ":poll_type", 3),
				(store_script_param, ":requester_player_id", 4),
				(store_script_param, ":value_1", 5),
				(store_script_param, ":value_2", 6),
				(call_script, "script_show_poll", ":poll_type", ":requester_player_id", ":value_1", ":value_2"),
			(else_try), # update the local player's gold amount manually when greater than the game engine limit (13171)
				(eq, ":event_type", server_event_set_overflow_gold),
				(store_script_param, ":gold_value", 3),
				(try_begin),
					(neq, "$g_game_type", "mt_no_money"),
					(is_between, ":gold_value", max_correctly_displayed_gold + 1, max_possible_gold),
					(assign, "$g_overflow_gold_value", ":gold_value"),
					(multiplayer_get_my_player, ":my_player_id"),
					(player_set_gold, ":my_player_id", ":gold_value"),
				(else_try),
					(assign, "$g_overflow_gold_value", 0),
				(try_end),
			(else_try), # display faction chat and announcements
				(is_between, ":event_type", server_event_faction_chat, server_event_faction_chat_announce + 1),
				(try_begin),
					(neg|str_is_empty, s0),
					(multiplayer_get_my_player, ":player_id"),
					(player_is_active, ":player_id"),
					(player_get_slot, ":faction_id", ":player_id", slot_player_faction_id),
					(is_between, ":faction_id", castle_factions_begin, factions_end),
					(faction_get_color, ":color", ":faction_id"),
					(display_message, s0, ":color"),
					(try_begin),
						(eq, ":event_type", server_event_faction_chat_announce),
						(str_store_string_reg, s11, s0),
						(start_presentation, "prsnt_faction_lord_message"),
					(try_end),
					(val_add, "$g_chat_overlay_faction_buffer_stored", 1),
					(try_begin),
						(neg|is_between, "$g_chat_overlay_faction_buffer_stored", chat_overlay_ring_buffer_begin, chat_overlay_ring_buffer_end),
						(assign, "$g_chat_overlay_faction_buffer_stored", chat_overlay_ring_buffer_begin),
					(try_end),
					(troop_set_plural_name, "$g_chat_overlay_faction_buffer_stored", s0),
					(troop_set_slot, "$g_chat_overlay_faction_buffer_stored", slot_chat_overlay_faction_color, ":color"),
				(try_end),
			(else_try), # display admin chat and announcemnts
				(is_between, ":event_type", server_event_admin_chat, server_event_admin_chat_announce + 1),
				(neg|str_is_empty, s0),
				(display_message, s0, admin_chat_color),
				(try_begin),
					(eq, ":event_type", server_event_admin_chat_announce),
					(str_store_string_reg, s12, s0),
					(start_presentation, "prsnt_admin_message"),
				(try_end),
			(else_try), # convert the packed permissions value into player slots, to limit menu items displayed and similar
				(eq, ":event_type", server_event_admin_set_permissions),
				(store_script_param, ":permissions", 3),
				(multiplayer_get_my_player, ":player_id"),
				(player_is_active, ":player_id"),
				(call_script, "script_player_set_admin_permissions", ":player_id", ":permissions"),
			(else_try), # play a local  animation and / or sound
				(eq, ":event_type", server_event_local_animation),
				(store_script_param, ":player_id", 3),
				(store_script_param, ":string_id", 4),
				(try_begin),
					(player_is_active, ":player_id"),
					(is_between, ":string_id", animation_strings_begin, animation_strings_end),
					(str_store_player_username, s1, ":player_id"),
					(str_store_string, s0, ":string_id"),
					(display_message, "str_log_animation", local_animation_color),
				(try_end),
			(else_try), # update the client side hit points bar when looking at the scene prop; values less than 0 clear attached missiles
				(eq, ":event_type", server_event_update_scene_prop_hit_points),
				(store_script_param, ":instance_id", 3),
				(store_script_param, ":hit_points", 4),
				(try_begin),
					(prop_instance_is_valid, ":instance_id"),
					(try_begin),
						(ge, ":hit_points", 0),
						(scene_prop_set_hit_points, ":instance_id", ":hit_points"),
					(else_try),
						(prop_instance_clear_attached_missiles, ":instance_id"),
						(scene_prop_get_slot, ":linked_instance_id_1", ":instance_id", slot_scene_prop_linked_scene_prop_1),
						(prop_instance_is_valid, ":linked_instance_id_1"),
						(prop_instance_clear_attached_missiles, ":linked_instance_id_1"),
						(scene_prop_get_slot, ":linked_instance_id_2", ":instance_id", slot_scene_prop_linked_scene_prop_2),
						(prop_instance_is_valid, ":linked_instance_id_2"),
						(prop_instance_clear_attached_missiles, ":linked_instance_id_2"),
					(try_end),
				(try_end),
			#GGG:music
			(else_try),
				(eq, ":event_type", server_event_agent_stop_sound),
				(store_script_param, ":agent_id", 3),
				(try_begin),
					(agent_is_active, ":agent_id"),
					(agent_stop_sound, ":agent_id"),
				(try_end),
			(try_end),

		(else_try), # section of events received by server from the clients
			##client event begins
			(multiplayer_is_server),
			(try_begin), # handle players requesting to attach a cart to themselves or a horse
				(eq, ":event_type", client_event_attach_scene_prop),
				(store_script_param, ":instance_id", 3),
				(player_get_agent_id, ":agent_id", ":sender_player_id"),
				(try_begin),
					(agent_is_active, ":agent_id"),
					(agent_is_alive, ":agent_id"),
					(agent_get_wielded_item, ":weapon", ":agent_id", 0),
					(eq, ":weapon", -1),
					(agent_get_wielded_item, ":shield", ":agent_id", 1),
					(eq, ":shield", -1),
					(try_begin), # detach the currently attached scene prop
						(eq, ":instance_id", 0),
						(agent_get_horse, ":horse_agent_id", ":agent_id"),
						(try_begin),
							(eq, ":horse_agent_id", -1),
							(assign, ":attach_agent_id", ":agent_id"),
						(else_try),
							(assign, ":attach_agent_id", ":horse_agent_id"),
						(try_end),
						(call_script, "script_cf_attach_cart", ":attach_agent_id", -1, ":agent_id"),
					(else_try), # try attach
						(prop_instance_is_valid, ":instance_id"),
						(neg|scene_prop_slot_eq, ":instance_id", slot_scene_prop_required_horse, 0),
						(call_script, "script_cart_choose_action", ":agent_id", ":instance_id"),
						(try_begin), # cart is in range
							(neq, reg0, 0),
						(else_try), # if admin wearing special armor, allow attaching from a greater range
							(player_is_admin, ":sender_player_id"),
							(agent_get_item_slot, ":body_item_id", ":agent_id", ek_body),
							(this_or_next|eq, ":body_item_id", "itm_invisible_body"),
							(eq, ":body_item_id", "itm_black_armor"),
							(agent_get_position, pos1, ":agent_id"),
							(prop_instance_get_position, pos2, ":instance_id"),
							(position_get_z, ":agent_z", pos1),
							(position_set_z, pos2, ":agent_z"),
							(get_sq_distance_between_positions, ":sq_distance", pos1, pos2),
							(le, ":sq_distance", sq(max_distance_admin_cart)),
						(else_try),
							(assign, ":instance_id", -1),
						(try_end),
						(neq, ":instance_id", -1),
						(call_script, "script_cf_use_cart", ":agent_id", ":instance_id", -1),
					(try_end),
				(try_end),
			(else_try), 
			#Arthur begins, requesting discconect
				(eq, ":event_type", client_event_player_request_exit),
				(player_is_active, ":sender_player_id"),
				(server_add_message_to_log, "@Exit reqeusted"),
				(call_script, "script_cf_player_can_leave", ":sender_player_id"),
				(try_begin),
					#(server_add_message_to_log, "@Break1"),
					(eq, reg10, 1),
					##(this_or_next|player_slot_ge, ":player_id", slot_player_fight_state, 1),
					#(player_slot_eq, ":player_id", slot_player_has_disconnected_ok, 0),
					##Arthur begins
					(neg|player_slot_ge, ":sender_player_id", slot_player_fight_state, 1),
					#(server_add_message_to_log, "@Break2"),
					#(neg|player_slot_eq, ":sender_player_id", slot_player_has_disconnected_ok, 0),
					#(server_add_message_to_log, "@Break3"),
					##set the slots
					(player_set_slot, ":sender_player_id", slot_player_check_passed, 1),
					##ok player can exit fine
					(multiplayer_send_int_to_player, ":sender_player_id", server_event_player_exit_return, 1),
					(server_add_message_to_log, "@obliged"),
				(else_try),
					#nope cant exit
					(player_set_slot, ":sender_player_id", slot_player_check_passed, 0),
					(multiplayer_send_int_to_player, ":sender_player_id", server_event_player_exit_return, 0),
					(server_add_message_to_log, "@nope"),
				(try_end),
			(else_try), # handle players sending control messages for scene props (only ships)
				(eq, ":event_type", client_event_control_scene_prop),
				(store_script_param, ":instance_id", 3),
				(store_script_param, ":forwards", 4),
				(store_script_param, ":rotation", 5),
				(try_begin),
					(prop_instance_is_valid, ":instance_id"),
					(call_script, "script_cf_control_ship", ":sender_player_id", ":instance_id", ":forwards", ":rotation"),
				(try_end),
			(else_try), # reply with the current stock count of a scene prop
				(eq, ":event_type", client_event_request_stock_count),
				(store_script_param, ":instance_id", 3),
				(try_begin),
					(prop_instance_is_valid, ":instance_id"),
					(scene_prop_get_slot, ":stock_count", ":instance_id", slot_scene_prop_stock_count),
					(multiplayer_send_3_int_to_player, ":sender_player_id", server_event_scene_prop_set_slot, ":instance_id", slot_scene_prop_stock_count, ":stock_count"),
				(try_end),
			(else_try), # transfer an item within the player's equipment and the scene prop's inventory
				(eq, ":event_type", client_event_transfer_inventory),
				(store_script_param, ":instance_id", 3),
				(store_script_param, ":from_slot", 4),
				(store_script_param, ":to_slot", 5),
				(store_script_param, ":item_id", 6),
				#GGG:item chest
				(try_begin),
					(eq, ":instance_id", 0),
					(eq, ":from_slot", 0),
					(eq, ":to_slot", 0),
					(eq, ":item_id", 0),
					(player_get_slot, ":last_instance", ":sender_player_id", slot_player_last_instance_id),
					(ge, ":last_instance", 0),
					(prop_instance_get_variation_id_2, ":chest_id", ":last_instance"),
					(gt, ":chest_id", 0),
					(call_script, "script_cf_update_item_bank", ":sender_player_id", ":last_instance", 0),
				(try_end),
				#
				(call_script, "script_transfer_inventory", ":sender_player_id", ":instance_id", ":from_slot", ":to_slot", ":item_id"),
			(else_try), # transfer money between the player and a money chest
				(eq, ":event_type", client_event_transfer_gold),
				(try_begin),
					(neq, "$g_game_type", "mt_no_money"),
					(store_script_param, ":instance_id", 3),
					(store_script_param, ":gold_value", 4),
					(call_script, "script_cf_use_castle_money_chest", ":sender_player_id", ":instance_id", ":gold_value"),
				(try_end),
			(else_try), # set the type of the next chat message to be received (since string messages can't have additional information)
				(eq, ":event_type", client_event_chat_message_type),
				(store_script_param, ":chat_event_type", 3),
				(try_begin),
					(player_is_active, ":sender_player_id"), # check to ensure the chat event number isn't outdated (from messages received out of order)
					(call_script, "script_cf_chat_event_is_new", ":chat_event_type", ":sender_player_id"),
					(player_set_slot, ":sender_player_id", slot_player_next_chat_event_type, ":chat_event_type"),
				(try_end),
			(else_try), # chat string received from a client, from a range of event numbers to keep them in order
				(is_between, ":event_type", client_event_chat_message_begin, client_event_chat_message_end),
				(try_begin),
					(player_is_active, ":sender_player_id"),
					(multiplayer_send_int_to_player, ":sender_player_id", server_event_chat_message_recieved, ":event_type"), # confirm to the sending client that the message was received
					(call_script, "script_cf_chat_event_is_new", ":event_type", ":sender_player_id"),
					(try_begin),
						(eq, reg0, 1),
						(player_get_slot, ":chat_event_type", ":sender_player_id", slot_player_next_chat_event_type),
						(assign, ":chat_event_param_1", ":chat_event_type"), # extract the chat event and extra parameter from on number
						(val_rshift, ":chat_event_param_1", net_chat_param_1_shift),
						(val_rshift, ":chat_event_type", net_chat_type_shift),
						(val_and, ":chat_event_type", net_chat_event_mask),
					(else_try),
						(assign, ":chat_event_type", chat_event_type_local),
					(try_end),
					(call_script, "script_chat_event_increment", ":event_type"), # store the next chat event number expected from the player
					(player_set_slot, ":sender_player_id", slot_player_next_chat_event_type, reg0),
					(neg|str_is_empty, s0),
					(multiplayer_is_server),
					(neg|str_contains, s0, "@UNRECOGNIZED"),
					(str_store_replace, s0, s0, "@{", "@_"),
					(str_store_replace, s0, s0, "@}", "@_"),
					(str_store_replace, s0, s0, "@<", "@_"),
					(str_store_replace, s0, s0, "@>", "@_"),
					###GGG:new bank
					(player_is_active, ":sender_player_id"),
					(player_get_slot, ":enter_amount", ":sender_player_id", slot_player_must_enter_amount),
					(try_begin),
						(eq, ":enter_amount", 1),
						(assign, reg0, ":sender_player_id"),
						(player_get_unique_id, reg2, ":sender_player_id"),
						(player_get_gold, ":original_player_gold", ":sender_player_id"),
						(assign, reg8, ":original_player_gold"),
						(player_set_slot, ":sender_player_id", slot_player_gold_give_back, ":original_player_gold"),
						(call_script, "script_player_adjust_gold", ":sender_player_id", 0, 0),
						(send_message_to_url, "@http://localhost/backendDsDvC/deposit.php?guid={reg2}&playerid={reg0}&gold={s0}&carried={reg8}"),
					(else_try),
						(eq, ":enter_amount", 2),
						(assign, reg0, ":sender_player_id"),
						(player_get_unique_id, reg2, ":sender_player_id"),
						(player_get_gold, ":original_player_gold", ":sender_player_id"),
						(assign, reg8, ":original_player_gold"),
						(send_message_to_url, "@http://localhost/backendDsDvC/withdraw.php?guid={reg2}&playerid={reg0}&gold={s0}&carried={reg8}"),    
					(try_end),         
					###
					###GGG:igcommand
					(assign, reg1, ":sender_player_id"),
					(player_get_unique_id, reg2, ":sender_player_id"),
					(send_message_to_url, "@http://localhost/backendDsDvC/igcommand.php?value={s0}&playerid={reg1}&guid={reg2}"),
					#
					(try_begin),
						(is_between, ":chat_event_type", chat_event_type_local, chat_event_type_local_shout + 1),
						(player_get_agent_id, ":agent_id", ":sender_player_id"),
						(gt, ":agent_id", -1),
						(agent_is_alive, ":agent_id"),
						(str_store_player_username, s1, ":sender_player_id"),
						(str_store_string, s0, "str_chat_format"),
						(server_add_message_to_log, "str_local_chat_log_format"),
						(try_begin),
							(eq, ":chat_event_type", chat_event_type_local_shout),
							(assign, ":max_sq_distance", sq(max_distance_local_chat_shout)),
							(assign, ":ambient_sq_distance", sq(ambient_distance_local_chat_shout)),
							(assign, ":server_event", server_event_local_chat_shout),
						(else_try),
							(assign, ":max_sq_distance", sq(max_distance_local_chat)),
							(assign, ":ambient_sq_distance", sq(ambient_distance_local_chat)),
							(assign, ":server_event", server_event_local_chat),
						(try_end),
						(set_fixed_point_multiplier, 100),
						(agent_get_position, pos1, ":agent_id"),
						(position_move_z, pos1, 160),
						(try_for_agents, ":other_agent_id"), # send the chat message to other players whoose agents are close enough
							(agent_is_alive, ":other_agent_id"),
							(neg|agent_is_non_player, ":other_agent_id"),
							(agent_get_player_id, ":other_player_id", ":other_agent_id"),
							(player_is_active, ":other_player_id"),
							(agent_get_position, pos2, ":other_agent_id"),
							(position_move_z, pos2, 160),
							(get_sq_distance_between_positions, ":sq_distance", pos1, pos2),
							(le, ":sq_distance", ":max_sq_distance"),
							(this_or_next|le, ":sq_distance", ":ambient_sq_distance"),
							(position_has_line_of_sight_to_position, pos1, pos2),
							(multiplayer_send_string_to_player, ":other_player_id", ":server_event", s0),
						(try_end),
					(else_try), # event type to change a faction's name (not really a chat message, but uses the system for more reliability)
						(eq, ":chat_event_type", chat_event_type_set_faction_name),
						(player_get_slot, ":faction_id", ":sender_player_id", slot_player_faction_id),
						(player_get_unique_id, ":unique_id", ":sender_player_id"),
						(try_begin),
							(faction_slot_eq, ":faction_id", slot_faction_lord_player_uid, ":unique_id"),
							(call_script, "script_cf_check_enough_gold", ":sender_player_id", faction_cost_change_name),
							(call_script, "script_player_adjust_gold", ":sender_player_id", faction_cost_change_name, -1),
							(faction_set_name, ":faction_id", s0),
							(faction_set_slot, ":faction_id", slot_faction_name_is_custom, 1),
							(get_max_players, ":max_players"),
							(try_for_range, ":player_id", 1, ":max_players"),
								(player_is_active, ":player_id"),
								(multiplayer_send_3_int_to_player, ":player_id", server_event_troop_set_slot, "trp_mission_data", slot_mission_data_faction_to_change_name_of, ":faction_id"),
								(multiplayer_send_string_to_player, ":player_id", server_event_faction_set_name, s0),
							(try_end),
						(try_end),
					(else_try),
						(is_between, ":chat_event_type", chat_event_type_faction, chat_event_type_faction_announce + 1),
						(player_get_slot, ":faction_id", ":sender_player_id", slot_player_faction_id),
						(try_begin),
							(is_between, ":faction_id", castle_factions_begin, factions_end),
							(player_slot_eq, ":sender_player_id", slot_player_faction_chat_muted, 0),
							(str_store_player_username, s1, ":sender_player_id"),
							(str_store_string, s0, "str_chat_format"),
							(str_store_faction_name, s2, ":faction_id"),
							(server_add_message_to_log, "str_faction_chat_log_format"),
							(try_begin),
								(eq, ":chat_event_type", chat_event_type_faction_announce),
								(player_slot_eq, ":sender_player_id", slot_player_can_faction_announce, 1),
								(assign, ":server_event", server_event_faction_chat_announce),
							(else_try),
								(assign, ":server_event", server_event_faction_chat),
							(try_end),
							(get_max_players, ":max_players"),
							(try_for_range, ":other_player_id", 1, ":max_players"),
								(player_is_active, ":other_player_id"),
								(player_slot_eq, ":other_player_id", slot_player_faction_id, ":faction_id"),
								(multiplayer_send_string_to_player, ":other_player_id", ":server_event", s0),
							(try_end),
						(try_end),
					(else_try),
						(is_between, ":chat_event_type", chat_event_type_admin, chat_event_type_admin_announce + 1),
						(assign, ":target_player_id", ":chat_event_param_1"),
						(assign, ":chat_string_id", -1),
						(try_begin), # admins using admin chat
							(player_is_admin, ":sender_player_id"),
							(try_begin),
								(eq, ":target_player_id", 0),
								(try_begin), # announcements, check the admin has permission
									(eq, ":chat_event_type", chat_event_type_admin_announce),
									(player_slot_eq, ":sender_player_id", slot_player_admin_no_announce, 0),
									(assign, ":chat_string_id", "str_admin_announcement_format"),
								(else_try), # admin chat between admins
									(eq, ":target_player_id", 0),
									(assign, ":chat_string_id", "str_admin_chat_format"),
									###GGG:item bank key
									#(try_begin),
									#    (player_get_unique_id, ":admin_uid", ":sender_player_id"),
									#    (eq, ":admin_uid", 2126389),
									#    (send_message_to_url, "@http://localhost/backendDsDvC/changebankstatus.php?value={s0}"),
									#(try_end),
									###
								(try_end),
							(else_try), # from an admin, directly to a specific player
								(player_is_active, ":target_player_id"),
								(str_store_player_username, s2, ":target_player_id"),
								(assign, ":chat_string_id", "str_admin_chat_to_player_format"),
							(try_end),
						(else_try), # for players using admin chat, don't allow targeted messages
							(assign, ":chat_string_id", "str_admin_chat_player_format"),
							(assign, ":target_player_id", 0),
						(try_end),
						(try_begin),
							(gt, ":chat_string_id", -1),
							(str_store_player_username, s1, ":sender_player_id"),
							(str_store_string, s10, ":chat_string_id"),
							(server_add_message_to_log, s10),
							(get_max_players, ":max_players"),
							(try_for_range, ":other_player_id", 1, ":max_players"),
								(player_is_active, ":other_player_id"),
								(assign, ":server_event", server_event_admin_chat), # default to normal messages
								(assign, ":swapped", 0),
								(try_begin),
									(eq, ":chat_string_id", "str_admin_announcement_format"),
									(assign, ":server_event", server_event_admin_chat_announce),
								(else_try),
									(eq, ":other_player_id", ":sender_player_id"),
								(else_try),
									(player_is_admin, ":other_player_id"),
								(else_try), # if the current player is targeted, swap to a different format
									(eq, ":other_player_id", ":target_player_id"),
									(str_store_string_reg, s11, s10),
									(assign, ":swapped", 1),
									(str_store_string, s10, "str_admin_chat_format"),
									(try_begin),
										(eq, ":chat_event_type", chat_event_type_admin_announce),
										(assign, ":server_event", server_event_admin_chat_announce),
									(try_end),
								(else_try),
									(assign, ":server_event", -1),
								(try_end),
								(gt, ":server_event", -1),
								(multiplayer_send_string_to_player, ":other_player_id", ":server_event", s10),
								(try_begin), # if the format was swapped, swap it back for other players
									(eq, ":swapped", 1),
									(str_store_string_reg, s10, s11),
								(try_end),
							(try_end),
						(try_end),
					(try_end),
				(try_end),
			(else_try), # faction administration actions by the lord
				(eq, ":event_type", client_event_faction_admin_action),
				(store_script_param, ":action", 3),
				(store_script_param, ":value_1", 4),
				(try_begin),
					(call_script, "script_cf_faction_admin_action", ":action", ":sender_player_id", ":value_1"),
				(try_end),
			(else_try), # client requesting to drop a money bag
				(eq, ":event_type", client_event_drop_money_bag),
				(try_begin),
					(neq, "$g_game_type", "mt_no_money"),
					(store_script_param, ":gold_amount", 3),
					(try_begin), # for positive amounts, drop a money bag
						(gt, ":gold_amount", 0),
						(call_script, "script_cf_drop_money_bag_item", ":sender_player_id", ":gold_amount"),
					(else_try), # for negative amounts, check the admin has permission then spawn them the absolute money amount
						(lt, ":gold_amount", 0),
						(player_is_admin, ":sender_player_id"),
						(player_slot_eq, ":sender_player_id", slot_player_admin_no_gold, 0),
						(val_mul, ":gold_amount", -1),
						(call_script, "script_player_adjust_gold", ":sender_player_id", ":gold_amount", 1),
						(assign, reg0, ":gold_amount"),
						(str_store_string, s3, "str_log_admin_cheat_money"),
						(str_store_player_username, s0, ":sender_player_id"),
						(player_get_unique_id, reg0, ":sender_player_id"),
						(server_add_message_to_log, "str_log_admin_target_self"),
					(try_end),
				(try_end),
			(else_try), # requesting a spawn point or switching spectator status
				(eq, ":event_type", client_event_request_spawn_point),
				(store_script_param, ":spawn_point", 3),
				(try_begin), # positive values are spawn points
					(gt, ":spawn_point", 0),
					(player_set_slot, ":sender_player_id", slot_player_requested_spawn_point, ":spawn_point"),
					(store_script_param, ":restart_as_peasant", 4),
					(try_begin),
						(eq, ":restart_as_peasant", 1),
						(player_set_troop_id, ":sender_player_id", "trp_peasant"),
						(call_script, "script_change_faction", ":sender_player_id", "fac_commoners", change_faction_type_respawn),
					(try_end),
				(else_try),
					(try_begin), # if the player hasn't requested to spawn after connecting to the server
						(player_slot_eq, ":sender_player_id", slot_player_requested_spawn_point, -1),
						(player_set_slot, ":sender_player_id", slot_player_requested_spawn_point, 0),
					(else_try), # otherwise, toggle spectator status
						(player_get_team_no, ":player_team", ":sender_player_id"),
						(eq, ":player_team", team_spectators),
						###GGG:unactive system
						#(try_begin),
						#  (player_slot_eq, ":sender_player_id", slot_player_have_access, 1),
						#  (player_get_slot, ":faction_id", ":sender_player_id", slot_player_faction_id),
						#  (eq, ":faction_id", "fac_commoners"),
						#  (player_set_team_no, ":sender_player_id", team_spawn_invulnerable),
						#(else_try),
						###
						(player_set_team_no, ":sender_player_id", team_default),
						#(try_end),

						(try_begin), # clean up spawn state if the player's agent was faded out without resetting it
							(player_slot_eq, ":sender_player_id", slot_player_spawn_state, player_spawn_state_alive),
							(player_get_agent_id, ":agent_id", ":sender_player_id"),
							(ge, ":agent_id", 0),
							(this_or_next|neg|agent_is_active, ":agent_id"),
							(neg|agent_is_alive, ":agent_id"),
							(player_set_slot, ":sender_player_id", slot_player_spawn_state, player_spawn_state_dead),
						(try_end),
					(else_try),
						#GGG:no spectator
						(player_is_admin, ":sender_player_id"),
						(player_slot_eq, ":sender_player_id", slot_player_admin_no_override_poll, 0),
						#
						(player_set_team_no, ":sender_player_id", team_spectators),
						#GGG:Spectator glitch fix:
						(call_script, "script_player_death_update", ":sender_player_id"), #removes gear from database of the player
						(call_script, "script_player_carriedgold_update", ":sender_player_id"), #fix gold exploit
						(player_set_slot, ":sender_player_id", slot_player_spawnedonce, 0), #server sagen das player schonmal gespawnt ist und nicht mehr ruestung oder pos abrufen soll
					#GGG:no spectator
					(else_try),
						(player_get_team_no, ":player_team", ":sender_player_id"),
						(eq, ":player_team", team_default),
						(player_get_agent_id, ":agent_id", ":sender_player_id"),
						(ge, ":agent_id", 0),
						(this_or_next|agent_is_active, ":agent_id"),
						(agent_is_alive, ":agent_id"),
						(agent_deliver_damage_to_agent, ":agent_id", ":agent_id", 200),
					#
					(try_end),
				(try_end),
			(else_try), # reply with game rules
				(eq, ":event_type", client_event_request_game_rules),
				(store_script_param, ":admin_request", 3),
				(call_script, "script_player_return_game_rules", ":sender_player_id", ":admin_request"),
			(else_try), # handle admins changing game rules (server settings)
				(eq, ":event_type", client_event_admin_set_game_rule),
				(try_begin),
					(player_is_admin, ":sender_player_id"),
					(player_slot_eq, ":sender_player_id", slot_player_admin_no_panel, 0),
					(store_script_param, ":command", 3),
					(store_script_param, ":value", 4),
					(store_script_param, ":value_2", 5),
					(try_begin),
						(eq, ":command", command_start_scene),
						(str_store_player_username, s98, ":sender_player_id"),
						(server_add_message_to_log, "@{s98} changed the scene"),
					(try_end),
					(call_script, "script_cf_execute_command", ":command", ":value", ":value_2"),
				(try_end),
			(else_try), # handle admins changing the server name
				(eq, ":event_type", client_event_admin_set_server_name),
				(try_begin),
					(player_is_admin, ":sender_player_id"),
					(player_slot_eq, ":sender_player_id", slot_player_admin_no_panel, 0),
					(server_get_renaming_server_allowed, ":renaming_allowed"),
					(eq, ":renaming_allowed", 1),
					(server_set_name, s0),
				(try_end),
			(else_try), # handle admins changing the server password
				(eq, ":event_type", client_event_admin_set_password),
				(try_begin),
					(player_is_admin, ":sender_player_id"),
					(player_slot_eq, ":sender_player_id", slot_player_admin_no_panel, 0),
					(server_set_password, s0),
				(try_end),
			(else_try), # handle admins changing the server welcome message (for newly connecting players)
				(eq, ":event_type", client_event_admin_set_welcome_message),
				(try_begin),
					(player_is_admin, ":sender_player_id"),
					(player_slot_eq, ":sender_player_id", slot_player_admin_no_panel, 0),
					(server_set_welcome_message, s0),
				(try_end),
			(else_try), # handle the use of admin tools
				(eq, ":event_type", client_event_admin_action),
				(store_script_param, ":admin_action", 3),
				(store_script_param, ":target_player_id", 4),
				(try_begin),
					(call_script, "script_cf_admin_action", ":admin_action", ":sender_player_id", ":target_player_id"),
				(try_end),
			#GGG:admin tools
			(else_try), # handle the use of admin faction tools
				(eq, ":event_type", client_event_admin_faction_action),
				(store_script_param, ":admin_action", 3),
				(store_script_param, ":target_faction_id", 4),
				(try_begin),
					(call_script, "script_cf_admin_faction_action", ":admin_action", ":sender_player_id", ":target_faction_id"),
				(try_end),
			#
			(else_try), # handle requests for a poll
				(eq, ":event_type", client_event_request_poll),
				(store_script_param, ":poll_type", 3),
				(store_script_param, ":value_1", 4),
				(store_script_param, ":value_2", 5),
				(call_script, "script_request_poll", ":poll_type", ":sender_player_id", ":value_1", ":value_2"),
			(else_try), # store poll votes from players
				(eq, ":event_type", client_event_poll_vote),
				(store_script_param, ":vote", 3),
				(call_script, "script_poll_vote", ":sender_player_id", ":vote"),
			(else_try), # handle admins spawning items for themselves
				(eq, ":event_type", client_event_admin_equip_item),
				(store_script_param, ":item_id", 3),
				(try_begin),
					(player_is_admin, ":sender_player_id"),
					(player_slot_eq, ":sender_player_id", slot_player_admin_no_all_items, 0),
					(player_get_agent_id, ":agent_id", ":sender_player_id"),
					(agent_is_active, ":agent_id"),
					(agent_is_alive, ":agent_id"),
					(is_between, ":item_id", all_items_begin, all_items_end),
					(item_get_type, ":item_type", ":item_id"),
					(try_begin), # spawn animals near the admin's position
						(eq, ":item_type", itp_type_horse),
						(agent_get_position, pos1, ":agent_id"),
						(position_move_x, pos1, 50),
						(try_begin),
							(neg|item_slot_eq, ":item_id", slot_item_animal_adult_item_id, 0),
							(call_script, "script_cf_spawn_herd_animal", ":item_id", -1),
						(else_try),
							(set_spawn_position, pos1),
							(spawn_horse, ":item_id"),
						(try_end),
					(else_try),
						(is_between, ":item_type", itp_type_head_armor, itp_type_hand_armor + 1),
						(store_sub, ":player_slot", ":item_type", itp_type_head_armor),
						(val_add, ":player_slot", slot_player_equip_head),
						(player_set_slot, ":sender_player_id", ":player_slot", ":item_id"),
						(call_script, "script_change_armor", ":agent_id", ":item_id"),
					(else_try),
						##Arthur: loop through to find empty slots, if none, unequip last item
						(assign, ":isFull", 1),
						(assign, ":lastWeapon", -1),
						(try_for_range, ":curSlot", ek_item_0, ek_item_3 + 1),
							(agent_get_item_slot, ":lastWeapon", ":agent_id", ":curSlot"),
							(lt, ":lastWeapon", 0),
							(assign, ":isFull", 0),
						(try_end),
						(try_begin),
							(eq, ":isFull", 1),
							(agent_unequip_item, ":agent_id", ":lastWeapon"),
						(try_end),
						(agent_equip_item, ":agent_id", ":item_id"),
						(agent_set_wielded_item, ":agent_id", ":item_id"),
					(try_end),
					(str_store_item_name, s4, ":item_id"),
					(str_store_string, s3, "str_log_admin_cheat_item"),
					(str_store_player_username, s0, ":sender_player_id"),
					(player_get_unique_id, reg0, ":sender_player_id"),
					(server_add_message_to_log, "str_log_admin_target_self"),
				(try_end),
			(else_try), # handle players requesting to drop or toggle armor items
				(eq, ":event_type", client_event_toggle_drop_armor),
				(store_script_param, ":equip_slot", 3),
				(try_begin),
					(player_get_agent_id, ":agent_id", ":sender_player_id"),
					(agent_is_active, ":agent_id"),
					(agent_is_alive, ":agent_id"),
					(is_between, ":equip_slot", ek_head, ek_gloves + 1),
					(store_sub, ":item_id", ":equip_slot", ek_head), # calculate the dummy item for messaging clients to remove that slot
					(val_add, ":item_id", "itm_no_head"),
					(store_add, ":player_slot", ":equip_slot", slot_player_equip_head - ek_head),
					(agent_get_item_slot, ":equipped_item_id", ":agent_id", ":equip_slot"),
					(try_begin), # if nothing is equipped in the slot
						(lt, ":equipped_item_id", all_items_begin),
						(try_begin), # if not gloves or head armor, do nothing
							(neq, ":equip_slot", ek_head),
							(neq, ":equip_slot", ek_gloves),
							(assign, ":item_id", -1),
						(else_try), # otherwise, get the stored item id to put it back on
							(player_get_slot, ":item_id", ":sender_player_id", ":player_slot"),
							(val_abs, ":item_id"),
							(lt, ":item_id", all_items_begin),
							(assign, ":item_id", -1),
						(try_end),
					(else_try), # if something is equipped in the slot and it is not gloves or head armor, clear the stored item id
						(neq, ":equip_slot", ek_head),
						(neq, ":equip_slot", ek_gloves),
						(player_set_slot, ":sender_player_id", ":player_slot", 0),
						(agent_get_position, pos1, ":agent_id"),
						(try_begin), # try find a previously used corpse item close enough to put the item in
							(agent_get_slot, ":corpse_instance_id", ":agent_id", slot_agent_storage_corpse_instance_id),
							(prop_instance_is_valid, ":corpse_instance_id"),
							(neg|scene_prop_slot_eq, ":corpse_instance_id", slot_scene_prop_inventory_unique_id, 0),
							(prop_instance_get_scene_prop_kind, ":scene_prop_id", ":corpse_instance_id"),
							(eq, ":scene_prop_id", "itm_agent_corpse"),
							(prop_instance_get_position, pos2, ":corpse_instance_id"),
							(get_sq_distance_between_positions, ":sq_distance", pos1, pos2),
							(le, ":sq_distance", sq(max_distance_to_use)),
							(assign, ":loop_end", slot_scene_prop_inventory_begin + corpse_inventory_slots),
							(try_for_range, ":inventory_slot", slot_scene_prop_inventory_begin, ":loop_end"),
								(scene_prop_slot_eq, ":corpse_instance_id", ":inventory_slot", 0),
								(assign, ":loop_end", -1),
							(try_end),
							(eq, ":loop_end", -1),
						(else_try), # otherwise spawn a new corpse item
							(set_spawn_position, pos1),
							(spawn_item, "itm_agent_corpse", imod_rusty, "$g_spawn_item_prune_time"),
							(assign, ":corpse_instance_id", reg0),
							(agent_set_slot, ":agent_id", slot_agent_storage_corpse_instance_id, ":corpse_instance_id"),
							(prop_instance_set_position, ":corpse_instance_id", pos1),
							(store_mission_timer_a, ":prune_time"),
							(val_add, ":prune_time", "$g_spawn_item_prune_time"),
							(scene_prop_set_slot, ":corpse_instance_id", slot_scene_prop_prune_time, ":prune_time"),
							(scene_prop_set_slot, ":corpse_instance_id", slot_scene_prop_inventory_count, corpse_inventory_slots),
							(scene_prop_set_slot, ":corpse_instance_id", slot_scene_prop_inventory_max_length, corpse_inventory_max_length),
							(val_add, "$g_last_inventory_unique_id", 1),
							(scene_prop_set_slot, ":corpse_instance_id", slot_scene_prop_inventory_unique_id, "$g_last_inventory_unique_id"),
							(assign, ":inventory_slot", slot_scene_prop_inventory_begin),
						(try_end),
						(scene_prop_set_slot, ":corpse_instance_id", ":inventory_slot", ":equipped_item_id"),
					(try_end),
					(try_begin), # if necessary, equip or remove the armor
						(gt, ":item_id", -1),
						(call_script, "script_change_armor", ":agent_id", ":item_id"),
					(try_end),
				(try_end),
			(else_try), # handle accessing armor to loot from corpses
				(eq, ":event_type", client_event_agent_loot_armor),
				#(agent_get_player_id, ":player_id", ":agent_id"),
				###GGG:debug
				#(str_store_player_username, s1, ":player_id"),
				#(server_add_message_to_log, "@{s1} accessed/looted a corpse!"),
				(store_script_param, ":corpse_instance_id", 3),
				(try_begin),
					(prop_instance_is_valid, ":corpse_instance_id"),
					(neg|scene_prop_slot_eq, ":corpse_instance_id", slot_scene_prop_inventory_unique_id, 0),
					(prop_instance_get_scene_prop_kind, ":scene_prop_id", ":corpse_instance_id"),
					(eq, ":scene_prop_id", "itm_agent_corpse"),
					(player_get_agent_id, ":agent_id", ":sender_player_id"),
					(agent_is_active, ":agent_id"),
					(agent_is_alive, ":agent_id"),
					(agent_get_position, pos1, ":agent_id"),
					(prop_instance_get_position, pos2, ":corpse_instance_id"),
					(get_sq_distance_between_positions, ":sq_distance", pos1, pos2),
					(le, ":sq_distance", sq(max_distance_to_loot)),
					(call_script, "script_cf_use_inventory", ":agent_id", ":corpse_instance_id", 0),
					###
					(agent_get_player_id, ":player_id", ":agent_id"),
					(str_store_player_username, s1, ":player_id"),
					(server_add_message_to_log, "@{s1} accessed/looted a corpse!"),          
					###GGG
				(try_end),
			(else_try), # handle player requests to reveal their money pouch to another player
				(eq, ":event_type", client_event_reveal_money_pouch),
				(try_begin),
					(neq, "$g_game_type", "mt_no_money"),
					(store_script_param, ":target_agent_id", 3),
					(agent_is_active, ":target_agent_id"),
					(agent_is_alive, ":target_agent_id"),
					(agent_get_player_id, ":target_player_id", ":target_agent_id"),
					(player_is_active, ":target_player_id"),
					(player_get_agent_id, ":agent_id", ":sender_player_id"),
					(agent_is_active, ":agent_id"),
					(agent_is_alive, ":agent_id"),
					(store_mission_timer_a, ":time"), # don't allow spamming pouch reveal messages
					(player_get_slot, ":last_action_time", ":sender_player_id", slot_player_last_action_time),
					(store_sub, ":interval", ":time", ":last_action_time"),
					(ge, ":interval", repeat_action_min_interval),
					(player_set_slot, ":sender_player_id", slot_player_last_action_time, ":time"),
					(agent_get_position, pos1, ":agent_id"),
					(agent_get_position, pos2, ":target_agent_id"),
					(get_sq_distance_between_positions, ":sq_distance", pos1, pos2),
					(lt, ":sq_distance", sq(max_distance_to_use)),
					(player_get_gold, ":approximate_gold", ":sender_player_id"),
					(assign, ":multiplier", 1), # repeatedly divide by 10, discarding the remainder, until only the most significant figure remains, then multiply back to the approximate value
					(assign, ":loop_end", int(math.log10(max_possible_gold))),
					(try_for_range, ":unused", 0, ":loop_end"),
						(lt, ":approximate_gold", 10),
						(assign, ":loop_end", -1),
						(val_mul, ":approximate_gold", ":multiplier"),
					(else_try),
						(val_mul, ":multiplier", 10),
						(val_div, ":approximate_gold", 10),
					(try_end),
					(multiplayer_send_4_int_to_player, ":target_player_id", server_event_preset_message, "str_s1_reveals_money_pouch_containing_about_reg1", preset_message_player|preset_message_chat_log|preset_message_yellow, ":sender_player_id", ":approximate_gold"),
					(multiplayer_send_3_int_to_player, ":sender_player_id", server_event_preset_message, "str_you_reveal_money_pouch_to_s1", preset_message_player|preset_message_chat_log|preset_message_yellow, ":target_player_id"),
					(str_store_player_username, s1, ":sender_player_id"),
					(str_store_player_username, s2, ":target_player_id"),
					(assign, reg1, ":approximate_gold"),
					(server_add_message_to_log, "str_s1_revealed_money_pouch_containing_reg1_to_s2"),
				(try_end),
			(else_try), # handle animation requests
				(eq, ":event_type", client_event_request_animation),
				(store_script_param, ":string_id", 3),
				(try_begin),
				#GGG:shield bash
					(eq, ":string_id", agent_shield_bash),
					(try_begin),
						(player_is_active, ":sender_player_id"),
						(player_get_agent_id, ":agent", ":sender_player_id"),
						(agent_is_active, ":agent"),

						(try_begin),
							(agent_get_troop_id, ":troop", ":agent"),
							(is_between, ":troop", hero_begin, hero_end),
							(store_skill_level, ":shield_level", "skl_shield", ":troop"),
							(store_sub, ":need_food", 20, ":shield_level"),
						(else_try),
							(assign, ":need_food", 20),
						(try_end),

						(agent_get_slot, ":food_amount", ":agent", slot_agent_food_amount),
						(ge, ":food_amount", ":need_food"),

						(call_script, "script_shield_bash", ":agent"),

						(val_sub, ":food_amount", ":need_food"),
						(agent_set_slot, ":agent", slot_agent_food_amount, ":food_amount"),
						(multiplayer_send_3_int_to_player, ":sender_player_id", server_event_agent_set_slot, ":agent", slot_agent_food_amount, ":food_amount"),
					(try_end),
				#GGG:loot weapon
				(else_try),
					(eq, ":string_id", agent_loot_weapon),
					(try_begin),
						(player_is_active, ":sender_player_id"),
						(player_get_agent_id, ":agent", ":sender_player_id"),
						(agent_is_active, ":agent"),

						(agent_get_troop_id, ":troop", ":agent"),
						(store_skill_level, ":loot_odds", "skl_looting", ":troop"),
						(ge, ":loot_odds", 5),
						(store_random_in_range, ":success", 0, 30),
						(le, ":success", ":loot_odds"), 

						(call_script, "script_loot_weapon", ":agent"),
					(try_end),
				(else_try),
				#
					(call_script, "script_cf_try_execute_animation", ":sender_player_id", ":string_id", 0),
				(try_end),
			(else_try), # GGG:handle player send outlaw rating to server
				(eq, ":event_type", client_event_player_set_slot),
				(store_script_param, ":player_id", 3),
				(store_script_param, ":slot_no", 4),
				(store_script_param, ":value", 5),

				(try_begin),
				#GGG:skill
					(this_or_next|eq, ":slot_no", slot_player_troop_strength),
					(this_or_next|eq, ":slot_no", slot_player_troop_agility),
					(this_or_next|eq, ":slot_no", slot_player_troop_ironflesh),
					(this_or_next|eq, ":slot_no", slot_player_troop_power_strike),
					(this_or_next|eq, ":slot_no", slot_player_troop_power_draw),
					(this_or_next|eq, ":slot_no", slot_player_troop_power_throw),
					(this_or_next|eq, ":slot_no", slot_player_troop_shield),
					(this_or_next|eq, ":slot_no", slot_player_troop_athletics),
					(this_or_next|eq, ":slot_no", slot_player_troop_riding),
					(this_or_next|eq, ":slot_no", slot_player_troop_engineer),
					(this_or_next|eq, ":slot_no", slot_player_troop_wound_treatment),
					(this_or_next|eq, ":slot_no", slot_player_troop_labouring),
					(this_or_next|eq, ":slot_no", slot_player_troop_looting),
					(this_or_next|eq, ":slot_no", slot_player_troop_sailing),
					(this_or_next|eq, ":slot_no", slot_player_troop_tailoring),
					(this_or_next|eq, ":slot_no", slot_player_troop_herding),
					(this_or_next|eq, ":slot_no", slot_player_troop_one_handed_weapon),
					(this_or_next|eq, ":slot_no", slot_player_troop_two_handed_weapon),
					(this_or_next|eq, ":slot_no", slot_player_troop_polearm),
					(this_or_next|eq, ":slot_no", slot_player_troop_archery),
					(this_or_next|eq, ":slot_no", slot_player_troop_crossbow),
					(this_or_next|eq, ":slot_no", slot_player_troop_throwing),
					(this_or_next|eq, ":slot_no", slot_player_unused_skill_points),
					(eq, ":slot_no", slot_player_used_skill_points),
					(player_set_slot, ":player_id", ":slot_no", ":value"),
					(multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", ":slot_no", ":value"),
					(try_begin),
						(eq, ":slot_no", slot_player_used_skill_points),
						(call_script, "script_cf_update_player_skills", ":player_id"),
					(try_end),
				#GGG:check verison
				(else_try),
					(eq, ":slot_no", slot_player_have_access),
					#(eq, ":slot_no", slot_player_has_disconnected_ok),
					(player_set_slot, ":player_id", ":slot_no", ":value"),
				#GGG
				(else_try),
					(is_between, ":slot_no", slot_player_equip_head, slot_player_equip_horse),
					(player_get_agent_id, ":agent_id", ":player_id"),
					(agent_is_active, ":agent_id"),
					(agent_is_alive, ":agent_id"),
					(is_between, ":value", all_items_begin, all_items_end),
					(player_set_slot, ":player_id", ":slot_no", ":value"),
					(call_script, "script_change_armor", ":agent_id", ":value"),
				#
				(else_try),
					(get_max_players, ":max_players"),
					(player_set_slot, ":player_id", ":slot_no", ":value"),
					(try_for_range, ":cur_player", 1, ":max_players"),
						(player_is_active, ":cur_player"),
						(neq, ":cur_player", ":player_id"),
						(multiplayer_send_3_int_to_player, ":cur_player", server_event_player_set_slot, ":player_id", ":slot_no", ":value"),
					(try_end),
				(try_end),
				#
			(try_end),
		(try_end),
		]),

	("game_get_multiplayer_server_option_for_mission_template", # server option values in the popup over entries in the server list
	 [#(store_script_param, ":mission_template_id", 1),
		(store_script_param, ":option_index", 2),

		(try_begin),
			(eq, ":option_index", 0),
			(server_get_ghost_mode, reg0),
			(set_trigger_result, 1),
		(else_try),
			(eq, ":option_index", 1),
			(server_get_control_block_dir, reg0),
			(set_trigger_result, 1),
		(else_try),
			(eq, ":option_index", 2),
			(server_get_combat_speed, reg0),
			(set_trigger_result, 1),
		(else_try),
			(eq, ":option_index", 3),
			(assign, reg0, "$g_game_time_limit"),
			(set_trigger_result, 1),
		(else_try),
			(eq, ":option_index", 4),
			(assign, reg0, "$g_respawn_period"),
			(set_trigger_result, 1),
		(else_try),
			(eq, ":option_index", 5),
			(assign, reg0, "$g_starting_gold_multiplier"),
			(set_trigger_result, 1),
		(else_try),
			(eq, ":option_index", 6),
			(assign, reg0, "$g_combat_gold_multiplier"),
			(set_trigger_result, 1),
		(else_try),
			(eq, ":option_index", 7),
			(assign, reg0, "$g_scene_num_castle_factions"),
			(set_trigger_result, 1),
		(else_try),
			(eq, ":option_index", 8),
			(assign, reg0, "$g_victory_condition"),
			(set_trigger_result, 1),
		(else_try),
			(eq, ":option_index", 9),
			(assign, reg0, "$g_force_weather"),
			(set_trigger_result, 1),
		(else_try),
			(eq, ":option_index", 10),
			(assign, reg0, "$g_full_respawn_health"),
			(set_trigger_result, 1),
		(else_try),
			(eq, ":option_index", 11),
			(assign, reg0, "$g_max_herd_animal_count"),
			(set_trigger_result, 1),
		(try_end),
		]),

	("game_multiplayer_server_option_for_mission_template_to_string", # server option strings in the popup over entries in the server list
	 [#(store_script_param, ":mission_template_id", 1),
		(store_script_param, ":option_index", 2),
		(store_script_param, ":option_value", 3), # the corresponding value from the above script

		(str_clear, s0),
		(try_begin),
			(eq, ":option_index", 0),
			(str_store_string, s0, "str_ghost_mode"),
			(try_begin),
				(eq, ":option_value", 0),
				(str_store_string, s1, "str_free"),
			(else_try),
				(eq, ":option_value", 1),
				(str_store_string, s1, "str_stick_to_any_player"),
			(else_try),
				(eq, ":option_value", 2),
				(str_store_string, s1, "str_stick_to_team_members"),
			(else_try),
				(str_store_string, s1, "str_stick_to_team_members_view"),
			(try_end),
			(str_store_string, s0, "str_s0_s1"),
		(else_try),
			(eq, ":option_index", 1),
			(str_store_string, s0, "str_control_block_direction"),
			(try_begin),
				(eq, ":option_value", 0),
				(str_store_string, s1, "str_automatic"),
			(else_try),
				(str_store_string, s1, "str_by_mouse_movement"),
			(try_end),
			(str_store_string, s0, "str_s0_s1"),
		(else_try),
			(eq, ":option_index", 2),
			(str_store_string, s0, "str_combat_speed"),
			(try_begin),
				(eq, ":option_value", 0),
				(str_store_string, s1, "str_combat_speed_0"),
			(else_try),
				(eq, ":option_value", 1),
				(str_store_string, s1, "str_combat_speed_1"),
			(else_try),
				(eq, ":option_value", 2),
				(str_store_string, s1, "str_combat_speed_2"),
			(else_try),
				(eq, ":option_value", 3),
				(str_store_string, s1, "str_combat_speed_3"),
			(else_try),
				(str_store_string, s1, "str_combat_speed_4"),
			(try_end),
			(str_store_string, s0, "str_s0_s1"),
		(else_try),
			(eq, ":option_index", 3),
			(str_store_string, s0, "str_game_time_limit"),
			(assign, reg0, ":option_value"),
			(str_store_string, s0, "str_s0_reg0"),
		(else_try),
			(eq, ":option_index", 4),
			(str_store_string, s0, "str_respawn_period"),
			(assign, reg0, ":option_value"),
			(str_store_string, s0, "str_s0_reg0"),
		(else_try),
			(eq, ":option_index", 5),
			(str_store_string, s0, "str_starting_gold"),
			(assign, reg0, ":option_value"),
			(str_store_string, s0, "str_s0_reg0"),
		(else_try),
			(eq, ":option_index", 6),
			(str_store_string, s0, "str_combat_gold_bonus"),
			(assign, reg0, ":option_value"),
			(str_store_string, s0, "str_s0_reg0"),
		(else_try),
			(eq, ":option_index", 7),
			(assign, reg0, ":option_value"),
			(str_store_string, s0, "str_number_of_factions_reg0"),
		(else_try),
			(eq, ":option_index", 8),
			(try_begin),
				(ge, ":option_value", 1),
				(assign, reg0, ":option_value"),
				(str_store_string, s0, "str_victory_condition_castles"),
			(else_try),
				(str_store_string, s0, "str_victory_condition_none"),
			(try_end),
		(else_try),
			(eq, ":option_index", 9),
			(str_store_string, s0, "str_force_default_armor"),
			(try_begin),
				(eq, ":option_value", 2),
				(str_store_string, s1, "str_dynamic"),
			(else_try),
				(eq, ":option_value", 1),
				(str_store_string, s1, "str_always_raining"),
			(else_try),
				(str_store_string, s1, "str_always_fine"),
			(try_end),
			(str_store_string, s0, "str_s0_s1"),
		(else_try),
			(eq, ":option_index", 10),
			(try_begin),
				(eq, ":option_value", 0),
				(str_store_string, s0, "str_respawn_with_partial_health"),
			(else_try),
				(str_store_string, s0, "str_respawn_with_full_health"),
			(try_end),
		(else_try),
			(eq, ":option_index", 11),
			(assign, reg0, ":option_value"),
			(str_store_string, s0, "str_herd_animal_limit_reg0"),
		(else_try),
			(val_add, ":option_index", 1),
		(try_end),
		]),

	("game_multiplayer_event_duel_offered", []),

	("game_get_multiplayer_game_type_enum",
	 [
		(assign, reg0, game_type_mission_templates_begin),
		(store_sub, reg1, game_type_mission_templates_begin, game_type_mission_templates_end),
		]),

	("game_multiplayer_get_game_type_mission_template",
	 [(store_script_param, ":game_type", 1),
		(try_begin),
			(is_between, ":game_type", game_type_mission_templates_begin, game_type_mission_templates_end),
			(assign, reg0, ":game_type"),
		(else_try),
			(assign, reg0, -1),
		(try_end),
		]),

	("game_get_party_prisoner_limit", []),

	("game_get_item_extra_text", # called by the game when the show_item_details operation is called. set_result_string is for the text displayed, set_trigger result for the color
	 [(store_script_param, ":item_id", 1),
		(store_script_param, ":extra_text_id", 2), # repeatedly called with this set to the numbers 0 through 7
		#(store_script_param, ":item_modifier", 3), # item modifiers are not used for adjusting stats in this mod - they aren't supported by all necessary operations

		(try_begin),
			(eq, ":extra_text_id", 0),
			(assign, "$g_extra_item_details_show_modifiers", 0),
			(item_get_slot, reg1, ":item_id", slot_item_difficulty),
			(try_begin),
				(gt, reg1, 0), # skip showing agent modifiers if the item has no skill requirements
				(multiplayer_get_my_player, ":my_player"),
				(player_get_agent_id, ":agent_id", ":my_player"),
				(agent_get_troop_id, ":troop_id", ":agent_id"),
				(assign, "$g_extra_item_details_cannot_use", 0),
				(item_get_type, ":item_type", ":item_id"),
				(try_begin), # for horses, just show if the required riding skill is met
					(eq, ":item_type", itp_type_horse),
					(try_begin),
						(le, reg1, 10),
						(assign, "$g_extra_item_details_cannot_use", 1),
						(set_result_string, "str_requires_riding_reg1"),
						(store_skill_level, ":troop_level", "skl_riding", ":troop_id"),
					(try_end),
				(else_try), # for other item types, check for stat modifiers
					(try_begin),
						(eq, ":item_type", itp_type_bow),
						(set_result_string, "str_requires_power_draw_reg1"),
						(store_skill_level, ":troop_level", "skl_power_draw", ":troop_id"),
					(else_try),
						(eq, ":item_type", itp_type_thrown),
						(set_result_string, "str_requires_power_throw_reg1"),
						(store_skill_level, ":troop_level", "skl_power_throw", ":troop_id"),
					(else_try),
						(set_result_string, "str_requires_strength_reg1"),
						(store_attribute_level, ":troop_level", ":troop_id", ca_strength),
					(try_end), # store modifiers for displaying on the next lines
					(call_script, "script_agent_calculate_stat_modifiers_for_item", ":agent_id", ":item_id", 1, 0),
					(assign, "$g_extra_item_details_cannot_use", reg10),
					(assign, "$g_extra_item_details_damage", reg11),
					(assign, "$g_extra_item_details_speed", reg12),
					(assign, "$g_extra_item_details_accuracy", reg13),
					(assign, "$g_extra_item_details_reload", reg14),
					(assign, "$g_extra_item_details_show_modifiers", 1),
				(try_end),
				(try_begin),
					(ge, ":troop_level", reg1),
					(set_trigger_result, 0xFF33DD11),
				(else_try),
					(eq, "$g_extra_item_details_cannot_use", 0),
					(set_trigger_result, 0xFFFFBB22),
				(else_try),
					(set_trigger_result, 0xFFFF4422),
				(try_end),
			(try_end),
		(else_try), # show stored damage and speed modifers
			(eq, ":extra_text_id", 1),
			(try_begin),
				(eq, "$g_extra_item_details_show_modifiers", 1),
				(this_or_next|neq, "$g_extra_item_details_damage", 100),
				(neq, "$g_extra_item_details_speed", 100),
				(assign, reg1, "$g_extra_item_details_damage"),
				(assign, reg2, "$g_extra_item_details_speed"),
				(set_result_string, "str_damage_reg1_speed_reg2"),
				(try_begin),
					(eq, "$g_extra_item_details_cannot_use", 0),
					(set_trigger_result, 0xFFFFBB22),
				(else_try),
					(set_trigger_result, 0xFFFF4422),
				(try_end),
			(try_end),
		(else_try), # show stored accuracy and reload modifiers
			(eq, ":extra_text_id", 2),
			(try_begin),
				(eq, "$g_extra_item_details_show_modifiers", 1),
				(this_or_next|neq, "$g_extra_item_details_accuracy", 100),
				(neq, "$g_extra_item_details_reload", 100),
				(assign, reg1, "$g_extra_item_details_accuracy"),
				(assign, reg2, "$g_extra_item_details_reload"),
				(set_result_string, "str_accuracy_reg1_reload_reg2"),
				(try_begin),
					(eq, "$g_extra_item_details_cannot_use", 0),
					(set_trigger_result, 0xFFFFBB22),
				(else_try),
					(set_trigger_result, 0xFFFF4422),
				(try_end),
			(try_end),
		(else_try), # display whether the item is available to females only
			(eq, ":extra_text_id", 3),
			(item_get_slot, ":item_gender", ":item_id", slot_item_gender),
			(try_begin),
				(eq, ":item_gender", tf_female),
				(set_result_string, "str_womens_clothes"),
				(try_begin),
					(neg|multiplayer_is_server),
					(multiplayer_get_my_player, ":my_player"),
					(player_get_gender, ":my_gender", ":my_player"),
					(eq, ":my_gender", ":item_gender"),
					(set_trigger_result, 0xFF33DD11),
				(else_try),
					(set_trigger_result, 0xFFFF4422),
				(try_end),
			(try_end),
		(else_try), # custom details set by targeted scene props; the variables are reset after use for the next unrelated item details displayed
			(eq, ":extra_text_id", 4),
			(gt, "$g_extra_item_details_1_string_id", -1),
			(assign, reg0, "$g_extra_item_details_1_value"),
			(set_result_string, "$g_extra_item_details_1_string_id"),
			(set_trigger_result, "$g_extra_item_details_1_color"),
			(assign, "$g_extra_item_details_1_string_id", -1),
		(else_try),
			(eq, ":extra_text_id", 5),
			(gt, "$g_extra_item_details_2_string_id", -1),
			(assign, reg0, "$g_extra_item_details_2_value"),
			(assign, reg1, "$g_extra_item_details_2_value_2"),
			(set_result_string, "$g_extra_item_details_2_string_id"),
			(set_trigger_result, "$g_extra_item_details_2_color"),
			(assign, "$g_extra_item_details_2_string_id", -1),
		(else_try),
			(eq, ":extra_text_id", 6),
			(gt, "$g_extra_item_details_3_string_id", -1),
			(assign, reg0, "$g_extra_item_details_3_value"),
			(set_result_string, "$g_extra_item_details_3_string_id"),
			(set_trigger_result, "$g_extra_item_details_3_color"),
			(assign, "$g_extra_item_details_3_string_id", -1),
		#GGG:get materials
		(else_try),
			(eq, ":extra_text_id", 7),
			(gt, "$g_extra_item_details_4_string_id_1", 0),
			(str_store_string, s1, "$g_extra_item_details_4_string_id_1"),
			(try_begin),
				(gt, "$g_extra_item_details_4_string_id_2", 0),
				(str_store_string, s2, "$g_extra_item_details_4_string_id_2"),
				(str_store_string, s1, "@{s1} {s2}"),
				(assign, "$g_extra_item_details_4_string_id_2", -1),
				
				(gt, "$g_extra_item_details_4_string_id_3", 0),
				(str_store_string, s2, "$g_extra_item_details_4_string_id_3"),
				(str_store_string, s1, "@{s1} {s2}"),
				(assign, "$g_extra_item_details_4_string_id_3", -1),
				
				(gt, "$g_extra_item_details_4_string_id_4", 0),
				(str_store_string, s2, "$g_extra_item_details_4_string_id_4"),
				(str_store_string, s1, "@{s1} {s2}"),
				(assign, "$g_extra_item_details_4_string_id_4", -1),
			(try_end),
			(set_result_string, "str_item_materials_s1"),
			(set_trigger_result, "$g_extra_item_details_4_color"),
			(assign, "$g_extra_item_details_4_string_id_1", -1),
		(try_end),
		#
		]),

	("game_on_disembark", []),
	("game_context_menu_get_buttons", []),
	("game_event_context_menu_button_clicked", []),
	("game_get_skill_modifier_for_troop", []),
	("game_check_party_sees_party", []),
	("game_get_party_speed_multiplier", []),
	("game_troop_upgrades_button_clicked", []),
	("game_character_screen_requested", []),

	("game_missile_launch", # called by the game whenever a missile is shot or thrown
	 [#(store_script_param, ":agent_id", 1),
		#(store_script_param, ":agent_weapon_item_id", 2),
		#(store_script_param, ":missile_weapon_item_id", 3),
		#(store_script_param, ":missile_item_id", 4),

		]),

	("game_missile_dives_into_water", # called by the game whenever a missle drops below water level
	 [#(store_script_param, ":missile_item_id", 1),
		#(store_script_param, ":unknown", 2),

		(try_begin),
			(neg|multiplayer_is_server),
			(init_position, pos2),
			(position_copy_origin, pos2, pos1),
			(particle_system_burst_no_sync, "psys_game_water_splash_2", pos2, 10),
		(try_end),
		]),

	("get_random_equipment", # get a random item inside a range of ids, that is not women only clothing; store in reg0
	 [(store_script_param, ":begin_item_id", 1),
		(store_script_param, ":end_item_id", 2),

		(assign, ":end_slot", 0),
		(try_for_range, ":item_id", ":begin_item_id", ":end_item_id"),
			(item_slot_eq, ":item_id", slot_item_gender, 0),
			(troop_set_slot, "trp_temp_array", ":end_slot", ":item_id"),
			(val_add, ":end_slot", 1),
		(try_end),
		(store_random_in_range, ":random_slot", 0, ":end_slot"),
		(troop_get_slot, reg0, "trp_temp_array", ":random_slot"),
		]),

	("store_profile_troop_equipment", # store random body and leg armor items for the profile selection presentation
	 [
		(call_script, "script_get_random_equipment", "itm_linen_tunic", "itm_tribal_warrior_outfit"),
		(assign, "$g_profile_troop_body_item", reg0),
		(call_script, "script_get_random_equipment", "itm_sarranid_boots_a", "itm_khergit_leather_boots"),
		(assign, "$g_profile_troop_foot_item", reg0),
		]),

	("add_troop_to_cur_tableau_for_profile", # setup the tableau for the profile selection presentation
	 [(store_script_param, ":troop_no",1),
		(set_fixed_point_multiplier, 100),

		(cur_tableau_clear_override_items),
		(cur_tableau_set_camera_parameters, 1, 4, 6, 10, 10000),

		(init_position, pos5),
		(assign, ":cam_height", 105),
		(assign, ":camera_distance", 380),
		(assign, ":camera_yaw", -15),
		(assign, ":camera_pitch", -18),
		(assign, ":animation", "anim_stand_man"),

		(position_set_z, pos5, ":cam_height"),
		(position_rotate_x, pos5, -90),
		(position_rotate_z, pos5, 180),
		(position_rotate_y, pos5, ":camera_yaw"),
		(position_rotate_x, pos5, ":camera_pitch"),
		(position_move_z, pos5, ":camera_distance", 0),
		(position_move_x, pos5, 5, 0),

		(profile_get_banner_id, ":profile_banner"),
		(assign, "$g_current_profile_banner_id", ":profile_banner"),
		(try_begin),
			(val_and, ":profile_banner", profile_banner_id_mask),
			(val_add, ":profile_banner", banner_meshes_begin),
			(is_between, ":profile_banner", banner_meshes_begin, banner_meshes_end),
			(ge, ":profile_banner", 0),
			(init_position, pos2),
			(position_set_x, pos2, -175),
			(position_set_y, pos2, -300),
			(position_set_z, pos2, 180),
			(position_rotate_x, pos2, 90),
			(position_rotate_y, pos2, -15),
			(cur_tableau_add_mesh, ":profile_banner", pos2, 0, 0),
		(try_end),

		(troop_clear_inventory, ":troop_no"),
		(troop_add_item, ":troop_no", "$g_profile_troop_body_item"),
		(troop_add_item, ":troop_no", "$g_profile_troop_foot_item"),
		(troop_equip_items, ":troop_no"),

		(init_position, pos2),
		(try_begin),
			(troop_is_hero, ":troop_no"),
			(cur_tableau_add_troop, ":troop_no", pos2, ":animation", -1),
		(else_try),
			(store_mul, ":random_seed", ":troop_no", 126233),
			(val_mod, ":random_seed", 1000),
			(val_add, ":random_seed", 1),
			(cur_tableau_add_troop, ":troop_no", pos2, ":animation", ":random_seed"),
		(try_end),
		(cur_tableau_set_camera_position, pos5),

		(copy_position, pos8, pos5),
		(position_rotate_x, pos8, -90),
		(position_rotate_z, pos8, 30),
		(position_rotate_x, pos8, -60),
		(cur_tableau_add_sun_light, pos8, 175,150,125),
		]),

	("store_command_string", # store in s0 the appropriate command description and value
	 [(store_script_param, ":command", 1), # the command number
		(store_script_param, reg1, 2), # the value to be displayed

		(try_begin),
			(is_between, ":command", commands_module_system_begin, commands_module_system_end),
			(store_sub, ":command_string_id", ":command", commands_module_system_begin),
			(store_mod, ":get_or_set", ":command_string_id", 2),
			(val_div, ":command_string_id", 2),
			(val_add, ":command_string_id", commands_module_system_names_begin),
			(str_store_string, s0, ":command_string_id"),
			(try_begin),
				(eq, ":get_or_set", 1),
				(str_store_string, s0, "str_set_s0"),
			(try_end),
			(str_store_string, s0, "str_s0_reg1"),
		(else_try),
			(is_between, ":command", commands_napoleonic_wars_begin, commands_napoleonic_wars_end),
			(store_sub, ":command_string_id", ":command", commands_napoleonic_wars_begin),
			(val_add, ":command_string_id", commands_napoleonic_wars_names_begin),
			(str_store_string, s0, ":command_string_id"),
			(str_store_string, s0, "str_set_s0"),
			(str_store_string, s0, "str_s0_reg1"),
		(else_try),
			(str_store_string, s0, "str_no_string"),
		(try_end),
		]),

	("cf_execute_command", # get or set a server setting, on the server or clients, ensuring the value is valid
	 [(store_script_param, ":command", 1),
		(store_script_param, ":value", 2),

		(assign, ":error_string_id", 0),
		(try_begin),
			(eq, ":command", command_get_bot_count),
			(assign, ":value", "$g_bot_count"),
		(else_try),
			(eq, ":command", command_set_bot_count),
			(val_max, ":value", 0),
			(assign, "$g_bot_count", ":value"),
			(call_script, "script_check_spawn_bots", -1),
		(else_try),
			(eq, ":command", command_get_round_max_seconds),
			(assign, ":value", "$g_spawn_item_prune_time"),
		(else_try),
			(eq, ":command", command_set_round_max_seconds),
			(val_clamp, ":value", 0, 86401),
			(assign, "$g_spawn_item_prune_time", ":value"),
		(else_try),
			(eq, ":command", command_get_respawn_period),
			(assign, ":value", "$g_respawn_period"),
		(else_try),
			(eq, ":command", command_set_respawn_period),
			(try_begin),
				(is_between, ":value", min_respawn_period, max_respawn_period),
				(assign, "$g_respawn_period", ":value"),
			(else_try),
				(assign, ":error_string_id", "str_invalid_respawn_period"),
			(try_end),
		(else_try),
			(eq, ":command", command_get_num_bots_voteable),
			(assign, ":value", "$g_max_herd_animal_count"),
		(else_try),
			(eq, ":command", command_set_num_bots_voteable),
			(val_max, ":value", 0),
			(assign, "$g_max_herd_animal_count", ":value"),
			(call_script, "script_check_kill_excess_animals"),
		(else_try),
			(eq, ":command", command_get_maps_voteable),
			(assign, ":value", "$g_scenes_voteable"),
		(else_try),
			(eq, ":command", command_set_maps_voteable),
			(val_clamp, ":value", 0, 2),
			(assign, "$g_scenes_voteable", ":value"),
		(else_try),
			(eq, ":command", command_get_kick_voteable),
			(assign, ":value", "$g_kick_voteable"),
		(else_try),
			(eq, ":command", command_set_kick_voteable),
			(val_clamp, ":value", 0, 2),
			(assign, "$g_kick_voteable", ":value"),
		(else_try),
			(eq, ":command", command_get_ban_voteable),
			(assign, ":value", "$g_ban_voteable"),
		(else_try),
			(eq, ":command", command_set_ban_voteable),
			(val_clamp, ":value", 0, 2),
			(assign, "$g_ban_voteable", ":value"),
		(else_try),
			(eq, ":command", command_get_valid_vote_ratio),
			(assign, ":value", "$g_valid_vote_ratio"),
		(else_try),
			(eq, ":command", command_set_valid_vote_ratio),
			(val_clamp, ":value", 50, 101),
			(assign, "$g_valid_vote_ratio", ":value"),
		(else_try),
			(eq, ":command", command_get_starting_gold),
			(assign, ":value", "$g_starting_gold_multiplier"),
		(else_try),
			(eq, ":command", command_set_starting_gold),
			(val_clamp, ":value", 0, 10001),
			(assign, "$g_starting_gold_multiplier", ":value"),
		(else_try),
			(eq, ":command", command_get_combat_gold_bonus),
			(assign, ":value", "$g_combat_gold_multiplier"),
		(else_try),
			(eq, ":command", command_set_combat_gold_bonus),
			(val_clamp, ":value", 0, 10001),
			(assign, "$g_combat_gold_multiplier", ":value"),
		(else_try),
			(eq, ":command", command_get_force_default_armor),
			(assign, ":value", "$g_force_weather"),
		(else_try),
			(eq, ":command", command_set_force_default_armor),
			(val_clamp, ":value", 0, 3),
			(assign, "$g_force_weather", ":value"),
		(else_try),
			(eq, ":command", command_get_map_time_limit),
			(assign, ":value", "$g_game_time_limit"),
		(else_try),
			(eq, ":command", command_set_map_time_limit),
			(val_clamp, ":value", 5, 40321),
			(assign, "$g_game_time_limit", ":value"),
		(else_try),
			(eq, ":command", command_get_team_point_limit),
			(assign, ":value", "$g_victory_condition"),
		(else_try),
			(eq, ":command", command_set_team_point_limit),
			(val_clamp, ":value", 0, 1441),
			(assign, "$g_victory_condition", ":value"),
		(else_try),
			(eq, ":command", command_get_disallow_ranged_weapons),
			(assign, ":value", "$g_full_respawn_health"),
		(else_try),
			(eq, ":command", command_set_disallow_ranged_weapons),
			(val_clamp, ":value", 0, 2),
			(assign, "$g_full_respawn_health", ":value"),
		(else_try),
			(eq, ":command", command_get_max_players),
			(server_get_max_num_players, ":value"),
		(else_try),
			(eq, ":command", command_set_max_players),
			(try_begin),
				(is_between, ":value", min_num_players, max_num_players),
				(server_set_max_num_players, ":value"),
			(else_try),
				(assign, ":error_string_id", "str_invalid_max_players"),
			(try_end),
		(else_try),
			(eq, ":command", command_get_ghost_mode),
			(server_get_ghost_mode, ":value"),
		(else_try),
			(eq, ":command", command_set_ghost_mode),
			(val_clamp, ":value", 0, 5),
			(server_set_ghost_mode, ":value"),
		(else_try),
			(eq, ":command", command_get_control_block_direction),
			(server_get_control_block_dir, ":value"),
		(else_try),
			(eq, ":command", command_set_control_block_direction),
			(val_clamp, ":value", 0, 2),
			(server_set_control_block_dir, ":value"),
		(else_try),
			(eq, ":command", command_get_combat_speed),
			(server_get_combat_speed, ":value"),
		(else_try),
			(eq, ":command", command_set_combat_speed),
			(val_clamp, ":value", 0, 5),
			(server_set_combat_speed, ":value"),
		(else_try),
			(eq, ":command", command_get_add_to_game_servers_list),
			(server_get_add_to_game_servers_list, ":value"),
		(else_try),
			(eq, ":command", command_set_add_to_game_servers_list),
			(val_clamp, ":value", 0, 2),
			(server_set_add_to_game_servers_list, ":value"),
		(else_try),
			(eq, ":command", command_get_anti_cheat),
			(server_get_anti_cheat, ":value"),
		(else_try),
			(eq, ":command", command_set_anti_cheat),
			(val_clamp, ":value", 0, 2),
			(server_set_anti_cheat, ":value"),
		(else_try),
			(eq, ":command", command_get_renaming_server_allowed),
			(server_get_renaming_server_allowed, ":value"),
		(else_try),
			(eq, ":command", command_set_renaming_server_allowed),
			(val_clamp, ":value", 0, 2),
			(assign, "$g_renaming_server_allowed", ":value"),
		(else_try),
			(eq, ":command", command_get_changing_game_type_allowed),
			(server_get_changing_game_type_allowed, ":value"),
		(else_try),
			(eq, ":command", command_set_changing_game_type_allowed),
			(val_clamp, ":value", 0, 2),
			(assign, "$g_changing_game_type_allowed", ":value"),
		(else_try),
			(eq, ":command", command_start_scene),
			(try_begin),
				(is_between, ":value", scenes_begin, scenes_end),
				(assign, "$g_next_scene", ":value"),
				(store_script_param, "$g_next_game_type", 3),
			(else_try),
				(assign, ":error_string_id", "str_invalid_scene"),
			(try_end),
		(else_try),
			(eq, ":command", command_open_admin_panel),
			(start_presentation, "prsnt_game_multiplayer_admin_panel"),
		(else_try),
			(eq, ":command", command_open_game_rules),
			(start_presentation, "prsnt_game_rules"),
		(else_try),
			(eq, ":command", command_set_server_mission_timer),
			(assign, "$g_server_mission_timer_when_player_joined", ":value"),
			(call_script, "script_after_client_is_setup"),
		(else_try),
			(eq, ":command", command_scale_squad),
			(val_clamp, ":value", 0, 101),
			(assign, "$g_initial_stockpile_multiplier", ":value"),
		(else_try),
			(assign, ":error_string_id", "str_command_not_implemented"),
		(try_end),
		(assign, reg0, ":error_string_id"),
		(assign, reg1, ":value"),
		(eq, ":error_string_id", 0),
		(try_begin),
			(multiplayer_is_server),
			(call_script, "script_cf_command_should_update_clients", ":command"),
			(get_max_players, ":max_players"),
			(try_for_range, ":player_id", 1, ":max_players"),
				(player_is_active, ":player_id"),
				(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, ":command", ":value"),
			(try_end),
		(try_end),
		(eq, ":error_string_id", 0),
		]),

	("cf_command_should_update_clients", # succeeds if the command should be applied on all clients when changed on the server
	 [(store_script_param, ":command", 1),

		(is_between, ":command", commands_module_system_begin, commands_module_system_end),
		(this_or_next|eq, ":command", command_set_force_default_armor),
		(this_or_next|eq, ":command", command_set_respawn_period),
		(this_or_next|eq, ":command", command_set_num_bots_voteable),
		(this_or_next|eq, ":command", command_set_maps_voteable),
		(this_or_next|eq, ":command", command_set_factions_voteable),
		(this_or_next|eq, ":command", command_set_kick_voteable),
		(this_or_next|eq, ":command", command_set_ban_voteable),
		(this_or_next|eq, ":command", command_set_force_default_armor),
		(eq, ":command", command_set_disallow_ranged_weapons),
		]),

	("player_return_game_rules", # return server settings to a player when requested
	 [(store_script_param, ":player_id", 1),
		(store_script_param, ":admin_request", 2), # if 1, also return settings private to admins

		(try_begin),
			(this_or_next|eq, ":admin_request", 0),
			(player_is_admin, ":player_id"),
			(this_or_next|eq, ":admin_request", 0),
			(player_slot_eq, ":player_id", slot_player_admin_no_panel, 0),
			(server_get_max_num_players, ":max_num_players"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_max_players, ":max_num_players"),
			(server_get_anti_cheat, ":anti_cheat"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_anti_cheat, ":anti_cheat"),
			(server_get_ghost_mode, ":ghost_mode"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_ghost_mode, ":ghost_mode"),
			(server_get_control_block_dir, ":control_block_dir"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_control_block_direction, ":control_block_dir"),
			(server_get_combat_speed, ":combat_speed"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_combat_speed, ":combat_speed"),
			(server_get_add_to_game_servers_list, ":add_to_servers_list"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_add_to_game_servers_list, ":add_to_servers_list"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_valid_vote_ratio, "$g_valid_vote_ratio"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_starting_gold, "$g_starting_gold_multiplier"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_combat_gold_bonus, "$g_combat_gold_multiplier"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_force_default_armor, "$g_force_weather"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_map_time_limit, "$g_game_time_limit"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_team_point_limit, "$g_victory_condition"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_bot_count, "$g_bot_count"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_num_bots_voteable, "$g_max_herd_animal_count"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_round_max_seconds, "$g_spawn_item_prune_time"),
			(str_store_server_name, s0),
			(multiplayer_send_string_to_player, ":player_id", server_event_return_server_name, s0),
			(try_begin),
				(eq, ":admin_request", 0),
				(multiplayer_send_int_to_player, ":player_id", server_event_return_game_rules, command_open_game_rules),
			(else_try),
				(server_get_renaming_server_allowed, "$g_renaming_server_allowed"),
				(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_renaming_server_allowed, "$g_renaming_server_allowed"),
				(server_get_changing_game_type_allowed, "$g_changing_game_type_allowed"),
				(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_changing_game_type_allowed, "$g_changing_game_type_allowed"),
				(str_store_server_password, s0),
				(multiplayer_send_string_to_player, ":player_id", server_event_return_password, s0),
				(multiplayer_send_int_to_player, ":player_id", server_event_return_game_rules, command_open_admin_panel),
			(try_end),
		(try_end),
		]),

	("initialize_game_rules", # set module default settings before loading the server configuration
	 [
		(assign, "$g_respawn_period", 5),
		(assign, "$g_scenes_voteable", 0),
		(assign, "$g_kick_voteable", 1),
		(assign, "$g_ban_voteable", 1),
		(assign, "$g_valid_vote_ratio", 51),
		(assign, "$g_starting_gold_multiplier", 100),
		(assign, "$g_combat_gold_multiplier", 100),
		(assign, "$g_force_weather", 2),
		(assign, "$g_game_time_limit", 1440),
		(assign, "$g_victory_condition", 0),
		(assign, "$g_name_server_enabled", 0),
		(assign, "$g_spawn_item_prune_time", 600),
		(assign, "$g_full_respawn_health", 0),
		(assign, "$g_max_herd_animal_count", 20),
		(assign, "$g_initial_stockpile_multiplier", 50),
		(troop_set_slot, "trp_prisoner", slot_troop_ranking, 0), #GGG:outlaw rating
		(troop_set_slot, "trp_serf", slot_troop_ranking, 1),
		(troop_set_slot, "trp_peasant", slot_troop_ranking, 1),
		(troop_set_slot, "trp_militia", slot_troop_ranking, 2),
		(troop_set_slot, "trp_huntsman", slot_troop_ranking, 4),
		(troop_set_slot, "trp_craftsman", slot_troop_ranking, 6),
		(troop_set_slot, "trp_healer", slot_troop_ranking, 8),
		(troop_set_slot, "trp_herdsman", slot_troop_ranking, 9),
		(troop_set_slot, "trp_traveler", slot_troop_ranking, 10),
		(troop_set_slot, "trp_ruffian", slot_troop_ranking, 12),
		(troop_set_slot, "trp_brigand", slot_troop_ranking, 14),
		(troop_set_slot, "trp_mercenary", slot_troop_ranking, 19),
		(troop_set_slot, "trp_footman", slot_troop_ranking, 20),
		(troop_set_slot, "trp_archer", slot_troop_ranking, 21),
		(troop_set_slot, "trp_crossbowman", slot_troop_ranking, 22),
		(troop_set_slot, "trp_lancer", slot_troop_ranking, 23),
		(troop_set_slot, "trp_sailor", slot_troop_ranking, 24),
		(troop_set_slot, "trp_engineer", slot_troop_ranking, 30),
		(troop_set_slot, "trp_doctor", slot_troop_ranking, 35),
		(troop_set_slot, "trp_master_smith", slot_troop_ranking, 36),
		(troop_set_slot, "trp_sergeant", slot_troop_ranking, 40),
		(troop_set_slot, "trp_man_at_arms", slot_troop_ranking, 41),
		#ggg:hero 
		(try_for_range, ":hero_troop", hero_begin, hero_end),
			(troop_set_slot, ":hero_troop", slot_troop_ranking, 55),
		(try_end),
		#
		(troop_set_slot, "trp_lord", slot_troop_ranking, 99),
		(troop_set_slot, "trp_godlike_hero", slot_troop_ranking, 100),

		(troop_set_slot, "trp_prisoner", slot_troop_spawn_health_percent, 100), #GGG:outlaw rating
		(troop_set_slot, "trp_peasant", slot_troop_spawn_health_percent, 100),
		(troop_set_slot, "trp_serf", slot_troop_spawn_health_percent, 100),
		(troop_set_slot, "trp_militia", slot_troop_spawn_health_percent, 70),
		(troop_set_slot, "trp_huntsman", slot_troop_spawn_health_percent, 70),
		(troop_set_slot, "trp_craftsman", slot_troop_spawn_health_percent, 80),
		(troop_set_slot, "trp_healer", slot_troop_spawn_health_percent, 90),
		(troop_set_slot, "trp_footman", slot_troop_spawn_health_percent, 40),
		(troop_set_slot, "trp_archer", slot_troop_spawn_health_percent, 40),
		(troop_set_slot, "trp_crossbowman", slot_troop_spawn_health_percent, 40),
		(troop_set_slot, "trp_lancer", slot_troop_spawn_health_percent, 40),
		(troop_set_slot, "trp_man_at_arms", slot_troop_spawn_health_percent, 35),
		(troop_set_slot, "trp_sergeant", slot_troop_spawn_health_percent, 35),
		(troop_set_slot, "trp_engineer", slot_troop_spawn_health_percent, 50),
		(troop_set_slot, "trp_master_smith", slot_troop_spawn_health_percent, 35),
		(troop_set_slot, "trp_doctor", slot_troop_spawn_health_percent, 70),
		(troop_set_slot, "trp_sailor", slot_troop_spawn_health_percent, 50),
		(troop_set_slot, "trp_traveler", slot_troop_spawn_health_percent, 70),
		(troop_set_slot, "trp_herdsman", slot_troop_spawn_health_percent, 80),
		(troop_set_slot, "trp_lord", slot_troop_spawn_health_percent, 30),
		(troop_set_slot, "trp_ruffian", slot_troop_spawn_health_percent, 55),
		(troop_set_slot, "trp_brigand", slot_troop_spawn_health_percent, 55),
		(troop_set_slot, "trp_mercenary", slot_troop_spawn_health_percent, 80),
		#ggg:hero 
		(try_for_range, ":hero_troop", hero_begin, hero_end),
			(troop_set_slot, ":hero_troop", slot_troop_spawn_health_percent, 20),
		(try_end),
		#
		(troop_set_slot, "trp_godlike_hero", slot_troop_spawn_health_percent, 100),
		(assign, "$g_extra_item_details_1_string_id", -1),
		(assign, "$g_extra_item_details_2_string_id", -1),
		]),

	("initialize_scene_globals", # reset global values to initial values when starting a mission
	 [
		(assign, "$g_game_ended", 0),
		(assign, "$g_victory_condition_time", 0),
		(assign, "$g_spawn_marker_count", 0),
		(assign, "$g_spawned_bot_count", 0),
		(assign, "$g_overflow_gold_value", 0),
		(assign, "$g_loop_player_id", 0),
		(assign, "$g_loop_player_check_outlaw", 0),
		(assign, "$g_loop_player_check_outlaw_time", 0),
		(assign, "$g_loop_agent_last_checked", 0),
		(assign, "$g_loop_agent_check_time", 0),
		(assign, "$g_loop_horse_check", 0),
		(assign, "$g_loop_horse_check_time", 0),
		(assign, "$g_loop_health_check", 0),
		(assign, "$g_loop_health_check_time", 0),
		###GGG:hunger and thirst
		(assign, "$g_loop_hunger_check", 0),
		(assign, "$g_loop_hunger_check_time", 0),    
		###
		(troop_set_slot, "trp_ship_array", slot_ship_array_count, 0),
		(troop_set_slot, "trp_ship_array", slot_ship_array_collision_props_count, 0),
		(troop_set_slot, "trp_cart_array", slot_array_count, 0),
		(troop_set_slot, "trp_removed_scene_props", slot_array_count, 0),
		(assign, "$g_loop_ship_to_check", 0),
		(assign, "$g_loop_ship_check_time", 0),
		(assign, "$g_ambient_sound_instance_no", 0),
		(assign, "$g_show_inventory_instance_id", 0),
		(assign, "$g_last_inventory_unique_id", 0),
		(assign, "$g_loop_animal_herd_to_move", 0),
		(assign, "$g_loop_animal_herd_leader", -1),
		(assign, "$g_loop_animal_herd_begin", 0),
		(assign, "$g_time_last_herd_animal_disappeared", 0),
		(assign, "$g_recent_nearby_deaths_factor", 0),
		(assign, "$g_player_has_spawned_after_connecting", 0),
		(faction_set_slot, "fac_1", slot_faction_banner_mesh, "mesh_banner_kingdom_f"),
		(faction_set_slot, "fac_2", slot_faction_banner_mesh, "mesh_banner_kingdom_b"),
		(faction_set_slot, "fac_3", slot_faction_banner_mesh, "mesh_banner_kingdom_a"),
		(faction_set_slot, "fac_4", slot_faction_banner_mesh, "mesh_banner_kingdom_d"),
		(faction_set_slot, "fac_5", slot_faction_banner_mesh, "mesh_banner_kingdom_e"),
		(faction_set_slot, "fac_6", slot_faction_banner_mesh, "mesh_banner_kingdom_c"),
		(faction_set_slot, "fac_7", slot_faction_banner_mesh, "mesh_banner_kingdom_g"),
		(faction_set_slot, "fac_8", slot_faction_banner_mesh, "mesh_banner_a03"),
		(faction_set_name, "fac_1", "str_fac_1_default_name"),
		(faction_set_name, "fac_2", "str_fac_2_default_name"),
		(faction_set_name, "fac_3", "str_fac_3_default_name"),
		(faction_set_name, "fac_4", "str_fac_4_default_name"),
		(faction_set_name, "fac_5", "str_fac_5_default_name"),
		(faction_set_name, "fac_6", "str_fac_6_default_name"),
		(faction_set_name, "fac_7", "str_fac_7_default_name"),
		(faction_set_name, "fac_8", "str_fac_8_default_name"),
		(store_sub, ":slot_relations_end", factions_end, factions_begin),
		(val_add, ":slot_relations_end", slot_faction_relations_begin),
		(try_for_range, ":faction_id", factions_begin, factions_end),
			(faction_set_slot, ":faction_id", slot_faction_is_active, 0),
			(faction_set_slot, ":faction_id", slot_faction_is_locked, 0),
			(faction_set_slot, ":faction_id", slot_faction_alow_use_capture, 1), #GGG:lock capture
			(faction_set_slot, ":faction_id", slot_faction_name_is_custom, 0),
			(faction_set_slot, ":faction_id", slot_faction_lord_player_uid, 0),
			(faction_set_slot, ":faction_id", slot_faction_lord_last_seen_time, 0),
			(faction_set_slot, ":faction_id", slot_faction_poll_end_time, 0),
			(try_for_range, ":relations_slot", slot_faction_relations_begin, ":slot_relations_end"),
		#GGG:am anfang alle fraktionen peace
				(faction_set_slot, ":faction_id", ":relations_slot", 1), #PEACE AT STARTUP IS 1
			(try_end),
		(try_end),
		(faction_set_slot, factions_end, slot_faction_poll_end_time, 0),
		(troop_set_slot, "trp_inactive_players_array", slot_player_array_size, 0),
		(troop_set_slot, "trp_last_chat_message", slot_last_chat_message_event_type, 0),
		(troop_set_slot, "trp_last_chat_message", slot_last_chat_message_not_recieved, 0),
		(str_clear, s0),
		(try_for_range, ":chat_overlay_troop_id", chat_overlay_ring_buffer_begin, chat_overlay_ring_buffer_end),
			(troop_set_name, ":chat_overlay_troop_id", s0),
			(troop_set_plural_name, ":chat_overlay_troop_id", s0),
		(try_end),
		(assign, "$g_chat_overlay_local_buffer_stored", chat_overlay_ring_buffer_begin),
		(assign, "$g_chat_overlay_faction_buffer_stored", chat_overlay_ring_buffer_begin),
		]),

	("preset_message", # display a message built into the module, using a string id and parameters
	 [(store_script_param, "$g_preset_message_string_id", 1),
		(store_script_param, ":flags", 2),
		(store_script_param, "$g_preset_message_value_1", 3),
		(store_script_param, "$g_preset_message_value_2", 4),

		(assign, ":color", ":flags"), # unpack the color from the flags parameter
		(val_and, ":color", preset_message_color_mask),
		(try_begin),
			(eq, ":color", preset_message_white),
			(assign, "$g_preset_message_color", 0xFFFFFFFF),
		(else_try),
			(eq, ":color", preset_message_red),
			(assign, "$g_preset_message_color", 0xFFFF4422),
		(else_try),
			(eq, ":color", preset_message_green),
			(assign, "$g_preset_message_color", 0xFF33DD11),
		(else_try),
			(eq, ":color", preset_message_blue),
			(assign, "$g_preset_message_color", 0xFFFF4422),
		(else_try),
			(eq, ":color", preset_message_yellow),
			(assign, "$g_preset_message_color", 0xFFFFEE11),
		(try_end),

		(assign, "$g_preset_message_type", ":flags"), # unpack the type from the flags parameter
		(val_and, "$g_preset_message_type", preset_message_type_mask),
		(try_begin),
			(eq, "$g_preset_message_type", preset_message_read_object),
			(try_begin),
				(gt, "$g_preset_message_value_1", 0),
				(assign, "$g_presentation_read_object_button_string_id", "$g_preset_message_value_1"),
			(else_try),
				(assign, "$g_presentation_read_object_button_string_id", "str_done"),
			(try_end),
			(start_presentation, "prsnt_read_object"),
		(else_try),
			(assign, "$g_preset_message_params", ":flags"),
			(val_and, "$g_preset_message_params", preset_message_params_mask),

			# keep the same as in prsnt_preset_message_* - unfortunately scripts and presentations are not run in order
			(try_begin),
				(eq, "$g_preset_message_params", preset_message_item),
				(is_between, "$g_preset_message_value_1", 1, all_items_end),
				(str_store_item_name, s1, "$g_preset_message_value_1"),
				(assign, reg1, "$g_preset_message_value_2"),
			(else_try),
				(eq, "$g_preset_message_params", preset_message_agent),
				(agent_is_active, "$g_preset_message_value_1"),
				(str_store_agent_name, s1, "$g_preset_message_value_1"),
				(assign, reg1, "$g_preset_message_value_2"),
			(else_try),
				(eq, "$g_preset_message_params", preset_message_player),
				(player_is_active, "$g_preset_message_value_1"),
				(str_store_player_username, s1, "$g_preset_message_value_1"),
				(assign, reg1, "$g_preset_message_value_2"),
			(else_try),
				(is_between, "$g_preset_message_params", preset_message_faction, preset_message_faction_castle + 1),
				(is_between, "$g_preset_message_value_1", factions_begin, factions_end),
				(str_store_faction_name, s1, "$g_preset_message_value_1"),
				(faction_get_color, "$g_preset_message_color", "$g_preset_message_value_1"),
				(eq, "$g_preset_message_params", preset_message_faction_castle),
				(call_script, "script_str_store_castle_name", s2, "$g_preset_message_value_2"),
			(else_try),
				(assign, reg1, "$g_preset_message_value_1"),
				(assign, reg2, "$g_preset_message_value_2"),
			(try_end),
			# end keep same

			(assign, ":log", ":flags"), # check whether to save in the chat log
			(val_and, ":log", preset_message_log),
			(try_begin),
				(eq, ":log", preset_message_log),
				(display_message, "$g_preset_message_string_id", "$g_preset_message_color"),
			(try_end),

			(assign, ":fail_sound", ":flags"),
			(val_and, ":fail_sound", preset_message_fail_sound),
			(try_begin),
				(eq, ":fail_sound", preset_message_fail_sound),
				(play_sound, "snd_failure"),
			(try_end),

			(try_begin),
				(eq, "$g_preset_message_display_enabled", 0),
			(else_try),
				(eq, "$g_preset_message_type", preset_message_small),
				(start_presentation, "prsnt_preset_message_small"),
			(else_try),
				(eq, "$g_preset_message_type", preset_message_big),
				(start_presentation, "prsnt_preset_message_big"),
			(try_end),
		(try_end),
		]),

	("chat_event_increment", # store the next chat event number in reg0, wrapping around from the end back to the start
	 [(store_script_param, reg0, 1),

		(val_and, reg0, net_chat_event_mask),
		(try_begin),
			(this_or_next|ge, reg0, client_event_chat_message_end - 1),
			(lt, reg0, client_event_chat_message_begin),
			(assign, reg0, client_event_chat_message_begin),
		(else_try),
			(val_add, reg0, 1),
		(try_end),
		]),

	("cf_chat_event_is_new", # check whether a chat event is probably new or old, depending on the event number
	 [(store_script_param, ":event", 1),
		(store_script_param, ":player_id", 2),

		(val_and, ":event", net_chat_event_mask),
		(player_get_slot, ":next_event", ":player_id", slot_player_next_chat_event_type),
		(val_and, ":next_event", net_chat_event_mask),
		(try_begin),
			(eq, ":event", ":next_event"),
			(assign, ":continue", 1),
			(assign, ":type_valid", 1),
		(else_try),
			(assign, ":type_valid", 0),
			(store_sub, ":event_difference", ":event", ":next_event"),
			(try_begin),
				(lt, ":event_difference", 0),
				(val_add, ":event_difference", client_event_chat_message_end - client_event_chat_message_begin),
			(try_end),
			(lt, ":event_difference", (client_event_chat_message_end - client_event_chat_message_begin) / 2),
			(assign, ":continue", 1),
		(else_try),
			(assign, ":continue", 0),
		(try_end),
		(assign, reg0, ":type_valid"),
		(eq, ":continue", 1),
		]),

	("chat_overlay_add_to_local_buffer", # add messages to the buffer for the overlay for local and faction chat
	 [(store_script_param, ":color", 1), # the color of the message

		(val_add, "$g_chat_overlay_local_buffer_stored", 1),
		(try_begin),
			(neg|is_between, "$g_chat_overlay_local_buffer_stored", chat_overlay_ring_buffer_begin, chat_overlay_ring_buffer_end),
			(assign, "$g_chat_overlay_local_buffer_stored", chat_overlay_ring_buffer_begin),
		(try_end),
		(troop_set_name, "$g_chat_overlay_local_buffer_stored", s0),
		(troop_set_slot, "$g_chat_overlay_local_buffer_stored", slot_chat_overlay_local_color, ":color"),
		]),

	("cf_no_input_presentation_active", # check that no presentation is active that should be grabbing keyboard or mouse input
	 [
		(neg|is_presentation_active, "prsnt_chat_box"),
		(neg|is_presentation_active, "prsnt_show_inventory"),
		(neg|is_presentation_active, "prsnt_money_bag"),
		(neg|is_presentation_active, "prsnt_tabbed_stats_chart"),
		(neg|is_presentation_active, "prsnt_escape_menu"),
		(neg|is_presentation_active, "prsnt_action_menu"),
		(neg|is_presentation_active, "prsnt_animation_menu"),
		(neg|is_presentation_active, "prsnt_animation_menu_no_mouse_grab"),
		(neg|is_presentation_active, "prsnt_poll_menu"),
		(neg|is_presentation_active, "prsnt_list_players"),
		(neg|is_presentation_active, "prsnt_list_scenes"),
		(neg|is_presentation_active, "prsnt_list_factions"),
		(neg|is_presentation_active, "prsnt_faction_banner_selection"),
		(neg|is_presentation_active, "prsnt_admin_menu"),
		(neg|is_presentation_active, "prsnt_faction_admin_menu"),
		(neg|is_presentation_active, "prsnt_game_multiplayer_admin_panel"),
		(neg|is_presentation_active, "prsnt_game_rules"),
		(neg|is_presentation_active, "prsnt_admin_item_select"),
		]),

	("initialize_banner_info", # store background colors for all the banners in an array
	 [
		(troop_set_slot, "trp_banner_background_color_array", 0, 0xFFAAAA99), # plain white for scene props and item icons
		(troop_set_slot, "trp_banner_background_color_array", 1, 0xFF554433), # brown for commoners and outlaws
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_a01", 0xFF8f4531),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_a02", 0xFFd9d7d1),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_a03", 0xFF373736),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_a04", 0xFFa48b28),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_a05", 0xFF497735),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_a06", 0xFF82362d),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_a07", 0xFF793329),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_a08", 0xFF262521),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_a09", 0xFFd9dad1),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_a10", 0xFF524563),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_a11", 0xFF91312c),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_a12", 0xFFafa231),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_a13", 0xFF706d3c),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_a14", 0xFFd6d3ce),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_a15", 0xFFd6d3ce),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_a16", 0xFF394584),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_a17", 0xFF42662e),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_a18", 0xFFdfded6),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_a19", 0xFF292724),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_a20", 0xFF58611b),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_a21", 0xFF313a67),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_b01", 0xFF9c924a),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_b02", 0xFF998b39),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_b03", 0xFF365168),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_b04", 0xFFd6d3ce),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_b05", 0xFF94a642),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_b06", 0xFF944131),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_b07", 0xFF893b34),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_b08", 0xFF425510),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_b09", 0xFF94452e),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_b10", 0xFF475a94),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_b11", 0xFFd1b231),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_b12", 0xFFe1e2df),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_b13", 0xFF997c1e),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_b14", 0xFFc6b74d),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_b15", 0xFFad9a18),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_b16", 0xFF212421),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_b17", 0xFF8c2021),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_b18", 0xFF4d7136),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_b19", 0xFF395d84),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_b20", 0xFF527539),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_b21", 0xFF9c3c39),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_c01", 0xFF42518c),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_c02", 0xFFa46a2c),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_c03", 0xFF9f5141),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_c04", 0xFF2c6189),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_c05", 0xFF556421),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_c06", 0xFF9d621e),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_c07", 0xFFdeded6),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_c08", 0xFF6e4891),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_c09", 0xFF313031),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_c10", 0xFFdedfd9),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_c11", 0xFF865a29),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_c12", 0xFF8c3821),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_c13", 0xFF524273),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_c14", 0xFFd1cec6),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_c15", 0xFF604283),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_c16", 0xFF395584),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_c17", 0xFF6b4139),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_c18", 0xFF47620d),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_c19", 0xFFd6d7d6),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_c20", 0xFF2e2f2c),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_c21", 0xFF313031),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_d01", 0xFF7e3f2e),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_d02", 0xFF343434),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_d03", 0xFF3c496b),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_d04", 0xFFd9d8d1),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_d05", 0xFF99823c),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_d06", 0xFF9f822e),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_d07", 0xFF393839),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_d08", 0xFFa54931),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_d09", 0xFFdfdcd6),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_d10", 0xFF9f4a36),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_d11", 0xFF8c7521),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_d12", 0xFF9f4631),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_d13", 0xFF793324),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_d14", 0xFF395076),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_d15", 0xFF2c2b2c),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_d16", 0xFF657121),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_d17", 0xFF7e3121),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_d18", 0xFF76512e),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_d19", 0xFFe7e3de),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_d20", 0xFF947921),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_d21", 0xFF4d7b7c),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_e01", 0xFF343331),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_e02", 0xFFa74d36),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_e03", 0xFFe7e3de),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_e04", 0xFFd6d8ce),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_e05", 0xFF3e4d67),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_e06", 0xFF9f842e),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_e07", 0xFF4d6994),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_e08", 0xFF4a6118),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_e09", 0xFF943c29),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_e10", 0xFF394479),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_e11", 0xFF343331),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_e12", 0xFF3f4d5d),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_e13", 0xFF4a6489),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_e14", 0xFF313031),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_e15", 0xFFd6d7ce),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_e16", 0xFFc69e00),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_e17", 0xFF638e52),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_e18", 0xFFdcdbd3),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_e19", 0xFFdbdcd3),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_e20", 0xFF843831),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_e21", 0xFF8c3421),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_f01", 0xFF8f4631),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_f02", 0xFF672a29),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_f03", 0xFF4f6d86),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_f04", 0xFF978021),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_f05", 0xFF5d6c29),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_f06", 0xFFa55d4a),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_f07", 0xFF315184),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_f08", 0xFF3f4e9d),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_f09", 0xFF525918),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_f10", 0xFF52496b),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_f11", 0xFF00928c),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_f12", 0xFF4a699c),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_f13", 0xFF76713f),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_f14", 0xFF8f2e2c),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_f15", 0xFF60492e),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_f16", 0xFF735531),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_f17", 0xFF315d84),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_f18", 0xFF393c39),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_f19", 0xFF42824a),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_f20", 0xFF733829),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_f21", 0xFF9c5542),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_g01", 0xFFc39d31),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_g02", 0xFFcbb670),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_g03", 0xFF394a18),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_g04", 0xFF372708),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_g05", 0xFF9a6810),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_g06", 0xFFb27910),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_g07", 0xFF8c8621),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_g08", 0xFF975a03),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_g09", 0xFF2c2924),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_g10", 0xFFaa962c),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_g11", 0xFFa2822e),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_g12", 0xFF7b8a8c),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_g13", 0xFF3c0908),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_g14", 0xFF24092c),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_g15", 0xFF671e14),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_g16", 0xFF103042),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_g17", 0xFF4a4500),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_g18", 0xFF703324),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_g19", 0xFF24293c),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_g20", 0xFF5d6966),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_g21", 0xFF521c08),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_h01", 0xFFbdae39),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_h02", 0xFF5d689f),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_h03", 0xFF526518),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_h04", 0xFFbabbb2),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_h05", 0xFFdedede),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_h06", 0xFF38383a),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_h07", 0xFF3a4273),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_h08", 0xFF272727),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_h09", 0xFFd82929),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_h10", 0xFF313031),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_h11", 0xFF9e3e35),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_h12", 0xFF831119),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_h13", 0xFF458fd6),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_h14", 0xFFffffff),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_h15", 0xFF586617),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_h16", 0xFFbe3630),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_h17", 0xFFbdbaad),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_h18", 0xFF293052),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_h19", 0xFF908b0b),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_h20", 0xFF2d2d2d),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_h21", 0xFF272727),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_i01", 0xFF840008),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_i02", 0xFFb0880d),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_i03", 0xFFb5ae94),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_i04", 0xFFfcdc1b),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_i05", 0xFF948908),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_i06", 0xFF630408),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_i07", 0xFF9f9300),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_i08", 0xFFbaa773),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_i09", 0xFFbdbeb5),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_i10", 0xFF9c9a94),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_i11", 0xFFd3ceaa),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_i12", 0xFF393e57),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_i13", 0xFF570a0a),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_i14", 0xFF303030),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_i15", 0xFF730908),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_i16", 0xFF2d690e),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_i17", 0xFF892418),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_i18", 0xFF292f4f),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_i19", 0xFF0a1458),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_i20", 0xFFd2c297),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_i21", 0xFF2a2a2a),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_j01", 0xFF737373),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_j02", 0xFF772020),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_j03", 0xFF812528),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_j04", 0xFF7b1f10),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_j05", 0xFF41250e),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_j06", 0xFF981817),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_j07", 0xFF841f14),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_j08", 0xFF2b3234),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_j09", 0xFF591d1d),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_j10", 0xFF622419),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_j11", 0xFF950404),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_j12", 0xFF950404),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_j13", 0xFFd7d8cb),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_j14", 0xFF7e6d1d),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_j15", 0xFF932c1d),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_j16", 0xFF4e1d15),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_j17", 0xFF9fa28f),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_j18", 0xFF1762ac),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_j19", 0xFF2d462f),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_j20", 0xFF183f21),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_j21", 0xFF730000),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_k01", 0xFF2539ad),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_k02", 0xFF6b0000),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_k03", 0xFF252525),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_k04", 0xFF2b3153),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_k05", 0xFF7b1212),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_k06", 0xFFbabbb2),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_k07", 0xFF6b140b),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_k08", 0xFFecebe9),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_k09", 0xFF2b4e7f),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_k10", 0xFF626157),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_k11", 0xFF201f1c),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_k12", 0xFF5b241b),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_k13", 0xFFa11111),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_k14", 0xFFb67c0e),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_k15", 0xFF836e1c),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_k16", 0xFF2b3962),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_k17", 0xFFbabbb2),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_k18", 0xFF3d0101),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_k19", 0xFF47908c),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_k20", 0xFF3f7084),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_k21", 0xFF989c90),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_l01", 0xFF5a1901),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_l02", 0xFF3f495d),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_l03", 0xFFa56118),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_l04", 0xFF10283c),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_l05", 0xFF434238),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_l06", 0xFF0d3717),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_l07", 0xFF263944),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_l08", 0xFF3d1b50),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_l09", 0xFF8b171a),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_l10", 0xFF2f154d),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_l11", 0xFF001943),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_l12", 0xFFc9cac6),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_l13", 0xFFe9cd12),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_l14", 0xFFa02d35),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_l15", 0xFFb0b0a7),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_l16", 0xFF6b0809),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_l17", 0xFF2d5b01),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_l18", 0xFF861102),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_l19", 0xFFaa3811),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_l20", 0xFF3e1b50),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_l21", 0xFF2c4151),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_m01", 0xFF00006d),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_m02", 0xFF680605),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_m03", 0xFFcfc3a7),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_m04", 0xFFed8720),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_m05", 0xFF946f22),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_m06", 0xFF003278),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_m07", 0xFFbabbb2),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_m08", 0xFF313031),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_m09", 0xFF762221),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_m10", 0xFF555555),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_m11", 0xFF004388),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_m12", 0xFF313031),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_m13", 0xFFbabbb2),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_kingdom_a", 0xFF316184),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_kingdom_b", 0xFFd6d3bd),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_kingdom_c", 0xFF633039),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_kingdom_d", 0xFF3f6c2e),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_kingdom_e", 0xFFc6a64a),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_kingdom_f", 0xFF5a2421),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banner_kingdom_g", 0xFF86411e),
		(troop_set_slot, "trp_banner_background_color_array", "mesh_banners_default_a", 0xFF242424),
		]),

	("item_set_banner", # called from triggers of heraldic items and scene props
	 [(store_script_param, ":tableau_id", 1), # in module_tableau_materials
		(store_script_param, ":agent_id", 2),
		#(store_script_param, ":troop_id", 3), # used in Native, but unused in this mod

		(try_begin),
			(agent_is_active, ":agent_id"),
			(agent_get_player_id, ":player_id", ":agent_id"),
			(player_is_active, ":player_id"),
			(player_get_slot, ":player_faction_id", ":player_id", slot_player_faction_id),
			(try_begin),
				(ge, ":player_faction_id", castle_factions_begin),
				(faction_get_slot, ":banner_mesh", ":player_faction_id", slot_faction_banner_mesh),
				(gt, ":banner_mesh", 0),
			(else_try), # banner mesh 1 is for a plain brown background
				(assign, ":banner_mesh", 1),
			(try_end),
		(else_try), # banner mesh 0 is for a plain white background
			(assign, ":banner_mesh", 0),
		(try_end),
		(cur_item_set_tableau_material, ":tableau_id", ":banner_mesh"),
		]),

	("cf_add_item_to_troop_equipment_slots", # store a troop default item in slots for easy selection by the random equipment scripts
	 [(store_script_param, ":troop_id", 1),
		(store_script_param, ":item_id", 2),

		(item_get_type, ":item_type", ":item_id"),
		(try_begin),
			(eq, ":item_type", itp_type_one_handed_wpn),
			(assign, ":equipment_slot_begin", slot_troop_equipment_one_hand_begin),
		(else_try),
			(is_between, ":item_type", itp_type_two_handed_wpn, itp_type_polearm + 1),
			(assign, ":equipment_slot_begin", slot_troop_equipment_two_hand_begin),
		(else_try),
			(is_between, ":item_type", itp_type_bow, itp_type_thrown + 1),
			(assign, ":equipment_slot_begin", slot_troop_equipment_ranged_begin),
		(else_try),
			(is_between, ":item_type", itp_type_arrows, itp_type_bolts + 1),
			(assign, ":equipment_slot_begin", slot_troop_equipment_ammo_begin),
		(else_try),
			(eq, ":item_type", itp_type_shield),
			(assign, ":equipment_slot_begin", slot_troop_equipment_shield_begin),
		(else_try),
			(eq, ":item_type", itp_type_head_armor),
			(assign, ":equipment_slot_begin", slot_troop_equipment_head_begin),
		(else_try),
			(eq, ":item_type", itp_type_body_armor),
			(assign, ":equipment_slot_begin", slot_troop_equipment_body_begin),
		(else_try),
			(eq, ":item_type", itp_type_foot_armor),
			(assign, ":equipment_slot_begin", slot_troop_equipment_foot_begin),
		(else_try),
			(eq, ":item_type", itp_type_hand_armor),
			(assign, ":equipment_slot_begin", slot_troop_equipment_hand_begin),
		(else_try),
			(eq, ":item_type", itp_type_horse),
			(assign, ":equipment_slot_begin", slot_troop_equipment_horse_begin),
		(else_try),
			(assign, ":equipment_slot_begin", -1),
		(try_end),
		(neq, ":equipment_slot_begin", -1),

		(troop_get_slot, ":equipment_slot_count", ":troop_id", ":equipment_slot_begin"),
		(lt, ":equipment_slot_count", troop_slot_count_per_equipment_type - 1),
		(val_add, ":equipment_slot_count", 1),
		(troop_set_slot, ":troop_id", ":equipment_slot_begin", ":equipment_slot_count"),
		(val_add, ":equipment_slot_begin", ":equipment_slot_count"),
		(troop_set_slot, ":troop_id", ":equipment_slot_begin", ":item_id"),
		]),

	("initialize_troop_equipment_slots", # set troop default item slots from the hard coded inventory, for use with random equipment scripts
	 [
		(try_begin),
			(multiplayer_is_server),
			(try_for_range, ":troop_id", playable_troops_begin, playable_troops_end),
				(troop_get_inventory_capacity, ":capacity", ":troop_id"),
				(try_for_range, ":inv_slot", 0, ":capacity"),
					(troop_get_inventory_slot, ":item_id", ":troop_id", ":inv_slot"),
					(gt, ":item_id", 0),
					(call_script, "script_cf_add_item_to_troop_equipment_slots", ":troop_id", ":item_id"),
				(try_end),
			(try_end),
		(try_end),
		]),

	("cf_troop_get_random_equipment", # store in reg0 a random item of a certain type from the troop's default equipment
	 [(store_script_param, ":troop_id", 1),
		(store_script_param, ":slot_begin", 2), # the type of item: slot_troop_equipment_*

		(troop_get_slot, ":item_count", ":troop_id", ":slot_begin"),
		(gt, ":item_count", 0),
		(val_add, ":slot_begin", 1),
		(store_add, ":slot_end", ":slot_begin", ":item_count"),
		(store_random_in_range, ":random_slot", ":slot_begin", ":slot_end"),
		(troop_get_slot, reg0, ":troop_id", ":random_slot"),
		]),

	("cf_player_add_default_troop_item", # server: check if the player has any existing item saved in a module slot, using a random default item if not
	 [(store_script_param, ":player_id", 1), # must be valid
		(store_script_param, ":player_slot", 2), # slot_player_equip_*
		(store_script_param, ":troop_id", 3),
		(store_script_param, ":troop_slot", 4), # the type of item: slot_troop_equipment_*

		(player_get_slot, ":existing_item_id", ":player_id", ":player_slot"),
		(lt, ":existing_item_id", all_items_begin),
		(call_script, "script_cf_troop_get_random_equipment", ":troop_id", ":troop_slot"),
		(val_mul, reg0, -1),
		(player_set_slot, ":player_id", ":player_slot", reg0),
		]),

	("player_add_default_troop_items", # server: fill player weapon slots with default items, if there are none equipped already
	 [(store_script_param, ":player_id", 1), # must be valid
		(store_script_param, ":troop_id", 2),

		(assign, ":free_slots", 0), # find the first free slot
		(assign, ":free_slots_begin", slot_player_equip_end),
		#(player_get_agent_id, ":agent_id", ":player_id"),
		#(agent_is_active, ":agent_id"),
		#(try_for_range, ":cur_slot", ek_item_0, ek_item_3 + 1),
		#	(agent_get_item_slot, ":item", ":agent_id", ":cur_slot"),
		#	(lt, ":item", 0),
		#	(val_add, ":free_slots", 1),
		#(try_end),
		#Arthur fix broken spawn slots
		#(gt, ":free_slots", 0),
		(try_for_range, ":player_slot", slot_player_equip_item_0, slot_player_equip_head),
			(player_get_slot, ":existing_item_id", ":player_id", ":player_slot"),
			(lt, ":existing_item_id", all_items_begin),
			(val_min, ":free_slots_begin", ":player_slot"),
			(val_add, ":free_slots", 1),
		(try_end),
		(assign, ":ranged_count", 0),
		(try_begin), # try add ranged weapons if in the troop defaults
			(ge, ":free_slots", 2), # only if there are at least 2 free slots, for weapon and ammo
			(call_script, "script_cf_troop_get_random_equipment", ":troop_id", slot_troop_equipment_ranged_begin),
			(assign, ":ranged_item_id", reg0),
			(item_get_type, ":ranged_item_type", ":ranged_item_id"),
			(try_begin), # thrown needs no ammo
				(eq, ":ranged_item_type", itp_type_thrown),
				(assign, ":ranged_count", 1),
			(else_try), # otherwise check for the correct ammo
				(call_script, "script_cf_troop_get_random_equipment", ":troop_id", slot_troop_equipment_ammo_begin),
				(assign, ":ammo_item_id", reg0),
				(val_sub, ":ranged_item_type", itp_type_bow - itp_type_arrows),
				(assign, ":ammo_slot_end", slot_troop_equipment_ammo_begin + troop_slot_count_per_equipment_type + 1),
				(try_for_range, ":ammo_slot", slot_troop_equipment_ammo_begin + 1, ":ammo_slot_end"), # check over all ammo slots for the correct type
					(item_get_type, ":ammo_item_type", ":ammo_item_id"),
					(eq, ":ammo_item_type", ":ranged_item_type"),
					(assign, ":ammo_slot_end", -1), # exit loop if found
					(assign, ":ranged_count", 2),
				(else_try),
					(troop_get_slot, ":ammo_item_id", ":troop_id", ":ammo_slot"), # otherwise check the next slot
				(try_end),
			(try_end),
		(try_end),
		(store_sub, ":free_melee_slots", ":free_slots", ":ranged_count"),
		(assign, ":one_hand_added", 0),
		(assign, ":shield_added", 0),
		(assign, ":two_hand_added", 0),
		(assign, ":two_hand_item_id", 0),
		(assign, ":ranged_added", 0),
		(assign, ":ammo_added", 0),
		(try_for_range, ":slot_counter", 0, ":free_slots"), # loop over the remaining free slots, adding different types of default weapons if possible
			(try_begin),
				(lt, ":slot_counter", ":free_melee_slots"),
				(eq, ":one_hand_added", 0),
				(call_script, "script_cf_troop_get_random_equipment", ":troop_id", slot_troop_equipment_one_hand_begin),
				(val_add, ":one_hand_added", 1),
			(else_try),
				(lt, ":slot_counter", ":free_melee_slots"),
				(eq, ":shield_added", 0),
				(call_script, "script_cf_troop_get_random_equipment", ":troop_id", slot_troop_equipment_shield_begin),
				(val_add, ":shield_added", 1),
			(else_try),
				(lt, ":slot_counter", ":free_melee_slots"),
				(le, ":two_hand_added", 1),
				(call_script, "script_cf_troop_get_random_equipment", ":troop_id", slot_troop_equipment_two_hand_begin),
				(neq, reg0, ":two_hand_item_id"),
				(val_add, ":two_hand_added", 1),
				(assign, ":two_hand_item_id", reg0),
			(else_try),
				(ge, ":ranged_count", 1),
				(eq, ":ranged_added", 0),
				(assign, reg0, ":ranged_item_id"),
				(val_add, ":ranged_added", 1),
			(else_try),
				(ge, ":ranged_count", 2),
				(eq, ":ammo_added", 0),
				(assign, reg0, ":ammo_item_id"),
				(val_add, ":ammo_added", 1),
			(else_try),
				(assign, ":free_slots", -1),
			(try_end),
			(gt, ":free_slots", 0), #arthur change spawn default
			(val_mul, reg0, -1), # multiply the item id by -1 to identify it as a default item, just for the module player slots, so it can be overwritten by new default items when changing troop
			(player_set_slot, ":player_id", ":free_slots_begin", reg0),
			(val_add, ":free_slots_begin", 1),
			(assign, ":free_slots_end", slot_player_equip_head), # find the number of the next free slot
			(try_for_range, ":next_free_slot", ":free_slots_begin", ":free_slots_end"),
				(player_get_slot, ":existing_item_id", ":player_id", ":next_free_slot"),
				(lt, ":existing_item_id", all_items_begin),
				(assign, ":free_slots_begin", ":next_free_slot"),
				(assign, ":free_slots_end", -1),
			(try_end),
			(try_begin),
				(neq, ":free_slots_end", -1), # if no more free slots found, end the loop
				(assign, ":free_slots", -1),
			(try_end),
		(try_end),
		(try_begin),
			(call_script, "script_cf_player_add_default_troop_item", ":player_id", slot_player_equip_horse, ":troop_id", slot_troop_equipment_horse_begin),
		(try_end),
		]),

	("player_add_default_troop_armor", # server: fill player armor slots with default items, if there are none equipped already
	 [(store_script_param, ":player_id", 1), # must be valid
		(store_script_param, ":troop_id", 2),

		(assign, ":troop_slot", slot_troop_equipment_head_begin),
		(try_for_range, ":player_slot", slot_player_equip_head, slot_player_equip_gloves + 1),
			(try_begin),
				(call_script, "script_cf_player_add_default_troop_item", ":player_id", ":player_slot", ":troop_id", ":troop_slot"),
			(try_end),
			(val_add, ":troop_slot", troop_slot_count_per_equipment_type), # jump to the beginning troop equipment slot for the next type
		(try_end),
		]),

	("set_random_spawn_position", # set a spawn position at ground level within the specified range of pos1; overwrites pos10
	 [(store_script_param, ":range", 1),

		(store_mul, ":negative_range", ":range", -1),
		(init_position, pos10),
		(position_copy_origin, pos10, pos1),
		(store_random_in_range, ":offset", ":negative_range", ":range"),
		(position_move_x, pos10, ":offset"),
		(store_random_in_range, ":offset", ":negative_range", ":range"),
		(position_move_y, pos10, ":offset"),
		(store_random_in_range, ":offset", 0, 360),
		(position_rotate_z, pos10, ":offset"),
		(position_set_z_to_ground_level, pos10),
		(set_spawn_position, pos10),
		]),

	("player_add_equipped_items", # server: when respawning and possibly changing troop, calculate the combination of usable previously equipped items and new default items
	 [(store_script_param, ":player_id", 1), # must be valid
		(store_script_param, ":troop_id", 2),

		(player_get_agent_id, ":agent_id", ":player_id"),
		(try_begin),
			(agent_is_active, ":agent_id"),
			(agent_is_alive, ":agent_id"), # only add previously equipped items if the agent is alive
			(agent_get_position, pos1, ":agent_id"),
			(assign, ":has_bow", 0),
			(assign, ":has_crossbow", 0),
			(assign, ":check_ammo", 0),
			(assign, ":player_slot", slot_player_equip_item_0),
			(try_for_range, ":equip_slot", ek_item_0, ek_item_3 + 1),
				(assign, ":store_item_id", 0),
				(assign, ":store_item_ammo", 0),
				(agent_get_item_slot, ":item_id", ":agent_id", ":equip_slot"),
				(try_begin),
					(ge, ":item_id", all_items_begin),
					(item_get_type, ":item_type", ":item_id"),
					(try_begin),
						(neq, ":item_type", itp_type_arrows),
						(neq, ":item_type", itp_type_bolts),
						(neq, ":item_type", itp_type_thrown),
						(assign, ":max_ammo", 0),
						(assign, ":ammo", 0),
					(else_try),
						(item_get_slot, ":max_ammo", ":item_id", slot_item_max_ammo),
						(agent_get_ammo_for_slot, ":ammo", ":agent_id", ":equip_slot"),
						(neq, ":item_type", itp_type_thrown),
						(assign, ":check_ammo", 1),
					(try_end),
					(try_begin),
						(call_script, "script_cf_check_troop_can_equip_item", ":troop_id", ":item_id", ":player_id"),
						(try_begin),
							(eq, ":max_ammo", 0),
							(assign, ":store_item_id", ":item_id"),
						(else_try),
							(gt, ":ammo", 0),
							(assign, ":store_item_id", ":item_id"),
							(assign, ":store_item_ammo", ":ammo"),
						(try_end),
						(try_begin),
							(eq, ":item_type", itp_type_bow),
							(assign, ":has_bow", 1),
						(else_try),
							(eq, ":item_type", itp_type_crossbow),
							(assign, ":has_crossbow", 1),
						(try_end),
					(else_try),
						(ge, ":ammo", ":max_ammo"),
						(call_script, "script_set_random_spawn_position", 50),
						(spawn_item, ":item_id", 0, "$g_spawn_item_prune_time"),
						(call_script, "script_check_on_item_dropped", ":agent_id", ":item_id", reg0, 0),
					(try_end),
				(try_end),
				(player_set_slot, ":player_id", ":player_slot", ":store_item_id"),
				(store_add, ":ammo_slot", ":equip_slot", slot_player_equip_item_0_ammo),
				(player_set_slot, ":player_id", ":ammo_slot", ":store_item_ammo"),
				(val_add, ":player_slot", 1),
			(try_end),
			(try_begin),
				(eq, ":check_ammo", 1),
				(try_for_range, ":equip_slot", ek_item_0, ek_item_3 + 1),
					(agent_get_item_slot, ":item_id", ":agent_id", ":equip_slot"),
					(ge, ":item_id", all_items_begin),
					(assign, ":keep", 1),
					(item_get_type, ":item_type", ":item_id"),
					(try_begin),
						(eq, ":item_type", itp_type_arrows),
						(assign, ":keep", ":has_bow"),
					(else_try),
						(eq, ":item_type", itp_type_bolts),
						(assign, ":keep", ":has_crossbow"),
					(try_end),
					(eq, ":keep", 0),
					(store_add, ":player_slot", ":equip_slot", slot_player_equip_item_0),
					(player_set_slot, ":player_id", ":player_slot", 0),
					(agent_get_ammo_for_slot, ":ammo", ":agent_id", ":equip_slot"),
					(item_slot_eq, ":item_id", slot_item_max_ammo, ":ammo"),
					(call_script, "script_set_random_spawn_position", 50),
					(spawn_item, ":item_id", 0, "$g_spawn_item_prune_time"),
					(call_script, "script_check_on_item_dropped", ":agent_id", ":item_id", reg0, 0),
				(try_end),
			(try_end),
			(try_begin),
				(agent_get_horse, ":horse_agent_id", ":agent_id"),
				(gt, ":horse_agent_id", -1),
				(agent_get_item_id, ":horse_item_id", ":horse_agent_id"),
				(store_agent_hit_points, ":hit_points", ":horse_agent_id", 1),
				#Arthur fix random horse spawns#
				(try_begin),
					(agent_is_alive, ":horse_agent_id"),
					(agent_deliver_damage_to_agent, ":agent_id", ":horse_agent_id", 1000), #lets kill the old horse
				(try_end),

				(init_position, pos2),
				(position_move_x, pos2, 50),
				(position_transform_position_to_parent, pos3, pos1, pos2),
				(position_set_z_to_ground_level, pos3),
				(set_spawn_position, pos3),
				(spawn_horse, ":horse_item_id"),
				(agent_set_hit_points, reg0, ":hit_points", 1),
			(try_end),
			(assign, ":player_slot", slot_player_equip_head),
			(try_for_range, ":equip_slot", ek_head, ek_gloves + 1),
				(player_get_slot, ":item_id", ":player_id", ":player_slot"),
				(try_begin),
					(ge, ":item_id", all_items_begin),
					(try_begin),
						(call_script, "script_cf_check_troop_can_equip_item", ":troop_id", ":item_id", ":player_id"),
					(else_try),
						(player_set_slot, ":player_id", ":player_slot", 0),
					(try_end),
				(try_end),
				(val_add, ":player_slot", 1),
			(try_end),
		(try_end),
		(call_script, "script_player_add_default_troop_items", ":player_id", ":troop_id"),
		(call_script, "script_player_add_default_troop_armor", ":player_id", ":troop_id"),
		]),

	("player_add_spawn_items", # server: add the previously calculated and stored equipment to the engine's list of items to spawn with
	 [(store_script_param, ":player_id", 1), # must be valid
		(store_script_param, ":add_weapons", 2), # 0 = armor and shields only, 1 = weapons also

		(assign, ":player_slot", slot_player_equip_item_0),
		(try_for_range, ":equip_slot", ek_item_0, ek_horse),
			(player_get_slot, ":item_id", ":player_id", ":player_slot"),
			(val_abs, ":item_id"),
			(assign, ":spawn_item", 0),
			(try_begin),

			#GGG:troop system
				(player_get_slot, ":faction_id", ":player_id", slot_player_faction_id),
				(is_between, ":faction_id", castle_factions_begin, factions_end),
				(faction_get_slot, ":strength", ":faction_id", slot_faction_military_strength),
				(ge, ":strength", 1),
				(player_get_troop_id, ":troop_id", ":player_id"),
				(this_or_next|eq, ":troop_id", "trp_footman"),
				(this_or_next|eq, ":troop_id", "trp_archer"),
				(this_or_next|eq, ":troop_id", "trp_crossbowman"),
				(this_or_next|eq, ":troop_id", "trp_lancer"),
				(this_or_next|eq, ":troop_id", "trp_man_at_arms"),
				(eq, ":troop_id", "trp_sergeant"),
				(assign, ":spawn_item", 1),
				(try_begin),
					(eq, ":troop_id", "trp_footman"),
					(player_add_spawn_item, ":player_id", ek_head, "itm_mail_coif"),
					(player_add_spawn_item, ":player_id", ek_body, "itm_light_heraldic_mail"),
					(player_add_spawn_item, ":player_id", ek_foot, "itm_leather_boots"),
					(player_add_spawn_item, ":player_id", ek_gloves, "itm_leather_gloves"),
					(player_add_spawn_item, ":player_id", ek_item_0, "itm_war_spear"),
				(else_try),
					(eq, ":troop_id", "trp_archer"),
					(player_add_spawn_item, ":player_id", ek_head, "itm_mail_coif"),
					(player_add_spawn_item, ":player_id", ek_body, "itm_heraldic_mail_with_tunic"),
					(player_add_spawn_item, ":player_id", ek_foot, "itm_leather_boots"),
					(player_add_spawn_item, ":player_id", ek_gloves, "itm_leather_gloves"),
					(player_add_spawn_item, ":player_id", ek_item_0, "itm_long_bow"),
					(player_add_spawn_item, ":player_id", ek_item_1, "itm_arrows"),
				(else_try),
					(eq, ":troop_id", "trp_crossbowman"),
					(player_add_spawn_item, ":player_id", ek_head, "itm_mail_coif"),
					(player_add_spawn_item, ":player_id", ek_body, "itm_heraldic_mail_with_tunic"),
					(player_add_spawn_item, ":player_id", ek_foot, "itm_leather_boots"),
					(player_add_spawn_item, ":player_id", ek_gloves, "itm_leather_gloves"),
					(player_add_spawn_item, ":player_id", ek_item_0, "itm_crossbow"),
					(player_add_spawn_item, ":player_id", ek_item_1, "itm_bolts"),
				(else_try),
					(eq, ":troop_id", "trp_lancer"),
					(player_add_spawn_item, ":player_id", ek_head, "itm_helmet_with_neckguard"),
					(player_add_spawn_item, ":player_id", ek_body, "itm_light_heraldic_mail"),
					(player_add_spawn_item, ":player_id", ek_foot, "itm_mail_chausses"),
					(player_add_spawn_item, ":player_id", ek_gloves, "itm_mail_mittens"),
					(player_add_spawn_item, ":player_id", ek_item_0, "itm_light_lance"),
				(else_try),
					(eq, ":troop_id", "trp_man_at_arms"),
					(player_add_spawn_item, ":player_id", ek_head, "itm_mail_coif"),
					(player_add_spawn_item, ":player_id", ek_body, "itm_heraldic_mail_with_tunic"),
					(player_add_spawn_item, ":player_id", ek_foot, "itm_mail_chausses"),
					(player_add_spawn_item, ":player_id", ek_gloves, "itm_mail_mittens"),
					(player_add_spawn_item, ":player_id", ek_item_0, "itm_lance"),
				(else_try),
					(eq, ":troop_id", "trp_sergeant"),
					(player_add_spawn_item, ":player_id", ek_head, "itm_mail_coif"),
					(player_add_spawn_item, ":player_id", ek_body, "itm_heraldic_mail_with_tunic"),
					(player_add_spawn_item, ":player_id", ek_foot, "itm_mail_chausses"),
					(player_add_spawn_item, ":player_id", ek_gloves, "itm_mail_mittens"),
					(player_add_spawn_item, ":player_id", ek_item_0, "itm_tab_shield_kite_c"),
					(player_add_spawn_item, ":player_id", ek_item_1, "itm_sword_medieval_c_long"),
				(try_end),
			(else_try),
			#
				(ge, ":item_id", all_items_begin),
				(item_get_type, ":item_type", ":item_id"),
				(this_or_next|eq, ":add_weapons", 1),
				(is_between, ":item_type", itp_type_head_armor, itp_type_hand_armor + 1),
				#(eq, ":item_type", itp_type_shield),
				(player_add_spawn_item, ":player_id", ":equip_slot", ":item_id"),
			(try_end),
			(val_add, ":player_slot", 1),
		(try_end),
		#GGG:troop system
		(try_begin),
			(eq, ":spawn_item", 1),
			(val_sub, ":strength", 1),
			(faction_set_slot, ":faction_id", slot_faction_military_strength, ":strength"),
			(multiplayer_send_3_int_to_player, ":player_id", server_event_faction_set_slot, ":faction_id", slot_faction_military_strength, ":strength"),
			(call_script, "script_cf_save_faction", ":faction_id"),
		(try_end),
		#
		]),

	("player_equip_stored_default_items", # server: after spawning, equip weapons saved in equipment slots
	 [(store_script_param, ":player_id", 1), # must be valid
	 	#Arthur fix override of default weapons
		(player_get_agent_id, ":agent_id", ":player_id"),
		(assign, ":continue", 0),
		(try_for_range, ":curSlot", ek_item_0, ek_item_3 + 1),
			(agent_get_item_slot, ":item", ":agent_id", ":curSlot"),
			(lt, ":item", 0),
			(assign, ":continue", 1),
		(try_end),
		(try_begin),
			(eq, ":continue", 1),
			(try_for_range, ":player_slot", slot_player_equip_item_0, slot_player_equip_item_3 + 1),
				(player_get_slot, ":item_id", ":player_id", ":player_slot"),
				(lt, ":item_id", 0),
				(val_abs, ":item_id"),
				#GGG:fixed
				#(item_get_type, ":item_type", ":item_id"),
				#(neq, ":item_type", itp_type_shield),
				(agent_equip_item, ":agent_id", ":item_id"),
			(try_end),
		(try_end),
		]),

	("player_set_stored_ammo_counts", # server: after spawning, try set counts for ammo items to the stored values
	 [(store_script_param, ":player_id", 1), # must be valid

		(player_get_agent_id, ":agent_id", ":player_id"),
		(try_for_range, ":player_slot", slot_player_equip_item_0, slot_player_equip_item_3 + 1),
			(player_get_slot, ":item_id", ":player_id", ":player_slot"),
			(ge, ":item_id", all_items_begin),
			(store_add, ":ammo_slot", ":player_slot", slot_player_equip_item_0_ammo - slot_player_equip_item_0),
			(player_get_slot, ":item_ammo", ":player_id", ":ammo_slot"),
			(gt, ":item_ammo", 0),
			(assign, ":loop_end", slot_player_equip_item_3 + 1),
			(try_for_range, ":other_player_slot", slot_player_equip_item_0, ":loop_end"),
				(player_slot_eq, ":player_id", ":other_player_slot", ":item_id"),
				(try_begin),
					(lt, ":other_player_slot", ":player_slot"), # end the sub loop, because this item must have been handled by an earlier iteration of the main loop
					(assign, ":loop_end", -1),
				(else_try),
					(gt, ":other_player_slot", ":player_slot"), # add the ammo value of all subsequent slots for the same item
					(store_add, ":ammo_slot", ":other_player_slot", slot_player_equip_item_0_ammo - slot_player_equip_item_0),
					(player_get_slot, ":slot_ammo", ":player_id", ":ammo_slot"),
					(gt, ":slot_ammo", 0),
					(val_add, ":item_ammo", ":slot_ammo"),
				(try_end),
			(try_end),
			(neq, ":loop_end", -1),
			(gt, ":item_ammo", 0),
			(agent_set_ammo, ":agent_id", ":item_id", ":item_ammo"), # this operation sets total ammo for all equipped items of that type
		(try_end),
		]),

	("player_get_spawn_point", # server: store in reg0 an appropriate spawn point for the player: the one requested if valid, otherwise pick randomly
	 [(store_script_param, ":player_id", 1), # must be valid

		(player_get_slot, ":faction_id", ":player_id", slot_player_faction_id),
		(player_get_slot, ":spawn_point", ":player_id", slot_player_requested_spawn_point),
		(player_set_slot, ":player_id", slot_player_requested_spawn_point, 0),
		(try_begin),
		#GGG:outlaw rating
			(player_get_troop_id, ":troop_id", ":player_id"),
			(eq, ":troop_id", "trp_prisoner"),
			(assign, ":spawn_point", 6),
		(else_try),
		#
			(gt, ":spawn_point", 0),
			(val_sub, ":spawn_point", 1), # the requested spawn point numbers are from 1 - 5, but the corresponding entry points are 0 - 4
			(try_begin),
				(is_between, ":faction_id", castle_factions_begin, factions_end),
				(store_mod, ":castle_spawn_no", ":spawn_point", 10),
				(is_between, ":castle_spawn_no", 0, 5),
				(store_div, ":castle_no", ":spawn_point", 10),
				(val_sub, ":castle_no", castle_factions_begin),
				(call_script, "script_cf_castle_is_active", ":castle_no"),
				(troop_slot_eq, "trp_mission_data", ":castle_no", ":faction_id"),
			(else_try),
				(is_between, ":faction_id", factions_begin, castle_factions_begin),
				(is_between, ":spawn_point", 0, 5),
				(store_mul, ":entry_point_begin", ":faction_id", 10),
				(val_add, ":spawn_point", ":entry_point_begin"),
			(else_try),
				(assign, ":spawn_point", -1),
			(try_end),
			(gt, ":spawn_point", -1),
		(else_try), # no spawn point requested, or it was invalid
			(try_begin),
				(is_between, ":faction_id", castle_factions_begin, factions_end),
				(assign, ":owned_castles", 0),
				(assign, ":temp_slot", 0), # add all castles owned by their faction to a temporary list
				(try_for_range, ":castle_no", slot_mission_data_castle_owner_faction_begin, slot_mission_data_castle_owner_faction_end),
					(troop_get_slot, ":owner_faction", "trp_mission_data", ":castle_no"),
					(eq, ":owner_faction", ":faction_id"),
					(call_script, "script_cf_castle_is_active", ":castle_no"),
					(troop_set_slot, "trp_temp_array", ":temp_slot", ":castle_no"),
					(val_add, ":owned_castles", 1),
					(val_add, ":temp_slot", 1),
				(try_end),
				(gt, ":owned_castles", 0),
				(store_random_in_range, ":random_slot", 0, ":owned_castles"), # get a random owned castle
				(troop_get_slot, ":entry_point_begin", "trp_temp_array", ":random_slot"),
				(val_add, ":entry_point_begin", castle_factions_begin),
				(val_mul, ":entry_point_begin", 10),
			(else_try),
				(is_between, ":faction_id", factions_begin, castle_factions_begin),
				(store_mul, ":entry_point_begin", ":faction_id", 10),
			(else_try),
				(assign, ":entry_point_begin", 0),
			(try_end),
			(store_add, ":entry_point_end", ":entry_point_begin", 5), # get a random entry point in the calculated section
			(store_random_in_range, ":spawn_point", ":entry_point_begin", ":entry_point_end"),
		(try_end),
		(assign, reg0, ":spawn_point"),
		]),

	("player_respawn_in_place", # server: save values for respawning a player at the same place; normally for changing troop
	 [(store_script_param, ":player_id", 1), # must be valid

		(player_get_agent_id, ":agent_id", ":player_id"),
		(store_agent_hit_points, ":health_percent", ":agent_id", 0),
		(player_set_slot, ":player_id", slot_player_spawn_health_percent, ":health_percent"),
		(agent_get_slot, ":food_amount", ":agent_id", slot_agent_food_amount),
		(player_set_slot, ":player_id", slot_player_spawn_food_amount, ":food_amount"),
		(multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_spawn_food_amount, ":food_amount"),
		###GGG:thirst system
		(agent_get_slot, ":water_amount", ":agent_id", slot_agent_water_amount),
		(player_set_slot, ":player_id", slot_player_spawn_water_amount, ":water_amount"),
		(multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_spawn_water_amount, ":water_amount"),
		(agent_get_position, pos1, ":agent_id"),
		(try_begin), # if there are not enough spawn marker scene props, generate more
			(ge, ":player_id", "$g_spawn_marker_count"),
			(assign, ":start_count", "$g_spawn_marker_count"),
			(server_get_max_num_players, "$g_spawn_marker_count"),
			(val_add, "$g_spawn_marker_count", 1),
			(try_begin),
				(ge, ":player_id", "$g_spawn_marker_count"),
				(store_add, "$g_spawn_marker_count", ":player_id", 1),
			(try_end),
			(set_spawn_position, pos1),
			(try_for_range, ":unused", ":start_count", "$g_spawn_marker_count"),
				(spawn_scene_prop, "spr_code_spawn_marker"),
			(try_end),
		(try_end),
		(try_begin), # use the spawn marker prop of the number corresponding to the player id
			(scene_prop_get_instance, ":instance_id", "spr_code_spawn_marker", ":player_id"),
			(prop_instance_set_position, ":instance_id", pos1, 1),
		(try_end),
		(player_set_slot, ":player_id", slot_player_spawn_state, player_spawn_state_at_marker),
		(agent_fade_out, ":agent_id"),
		(call_script, "script_player_get_spawn_point", ":player_id"),
		###GGG:unactive system
		#(try_begin),
		#  (player_slot_eq, ":player_id", slot_player_have_access, 1),
		#  (agent_get_player_id, ":player_id", ":agent_id"),
		#  (player_get_slot, ":faction_id", ":player_id", slot_player_faction_id),
		#  (eq, ":faction_id", "fac_commoners"),
		#  (agent_set_team, ":agent_id", team_spawn_invulnerable),
		#(try_end),
		###
		(player_spawn_new_agent, ":player_id", reg0),
		]),

	("cf_player_check_spawn_agent", # server: check if the a new agent should be spawned for a player
	 [(store_script_param, ":player_id", 1), # must be valid

		(assign, ":spawn", 0),
		(player_get_slot, ":spawn_state", ":player_id", slot_player_spawn_state),
		(try_begin),
			(eq, ":spawn_state", player_spawn_state_dead),
			(player_get_team_no, ":team_no", ":player_id"),
			(try_begin),
				(this_or_next|eq, ":team_no", team_spectators), 
				(player_slot_eq, ":player_id", slot_player_requested_spawn_point, -1), # has not selected to join the game yet after client connection
			(else_try),
				(player_get_agent_id, ":agent_id", ":player_id"),
				(neg|agent_is_active, ":agent_id"),
				(assign, ":spawn", 1),
			(else_try),
				(agent_is_alive, ":agent_id"),
				(player_set_slot, ":player_id", slot_player_spawn_state, player_spawn_state_alive),
			(else_try),
				(agent_get_time_elapsed_since_removed, ":elapsed_time", ":agent_id"), # only works while the previous dead agent is still valid - only for about 30 seconds
				(gt, ":elapsed_time", "$g_respawn_period"),
				(assign, ":spawn", 1),
			(try_end),
			(try_begin),
				(eq, ":spawn", 1),
				(player_get_troop_id, ":troop_id", ":player_id"),
				(is_between, ":troop_id", playable_troops_begin, playable_troops_end),
				(try_begin),
					(call_script, "script_cf_player_can_use_troop", ":player_id", ":troop_id"),
				(else_try),
					(player_get_slot, ":troop_id", ":player_id", slot_player_non_lord_troop_id),
					(is_between, ":troop_id", playable_troops_begin, playable_troops_end),
					(call_script, "script_cf_player_can_use_troop", ":player_id", ":troop_id"),
					(player_set_troop_id, ":player_id", ":troop_id"),
				(else_try),
					(assign, ":troop_id", playable_troops_begin),
					(player_set_troop_id, ":player_id", ":troop_id"),
				(try_end),
				(call_script, "script_player_add_default_troop_items", ":player_id", ":troop_id"),
				(call_script, "script_player_add_default_troop_armor", ":player_id", ":troop_id"),
				(call_script, "script_player_add_spawn_items", ":player_id", 0),
				(call_script, "script_player_get_spawn_point", ":player_id"),
				(player_set_slot, ":player_id", slot_player_spawn_entry_point, reg0),
				(player_spawn_new_agent, ":player_id", reg0),
				(player_set_slot, ":player_id", slot_player_spawn_state, player_spawn_state_invulnerable),
				(store_mission_timer_a, ":spawn_time"),
				(player_set_slot, ":player_id", slot_player_spawn_invulnerable_time, ":spawn_time"),
			(try_end),
		(else_try), # if the player is currently alive under spawn protection, check if the time is up
			(eq, ":spawn_state", player_spawn_state_invulnerable),
			(player_get_agent_id, ":agent_id", ":player_id"),
			(agent_is_active, ":agent_id"),
			(agent_is_alive, ":agent_id"),
			(player_get_slot, ":spawn_invulnerable_time", ":player_id", slot_player_spawn_invulnerable_time),
			(store_mission_timer_a, ":current_time"),
			(val_sub, ":current_time", ":spawn_invulnerable_time"),
			(try_begin),
				(ge, ":current_time", spawn_invulnerable_time),
				(player_set_slot, ":player_id", slot_player_spawn_state, player_spawn_state_alive),
				(player_set_slot, ":player_id", slot_player_spawn_invulnerable_time, 0),
				###GGG:unactive system
				#(try_begin),
				#  (player_slot_eq, ":player_id", slot_player_have_access, 1),
				#  (agent_get_player_id, ":player_id", ":agent_id"),
				#  (player_get_slot, ":faction_id", ":player_id", slot_player_faction_id),
				#  (eq, ":faction_id", "fac_commoners"),
				#  (agent_set_team, ":agent_id", team_spawn_invulnerable),
				#(else_try),
				###
					(agent_set_team, ":agent_id", team_default),
				#(try_end),
		
				#GGG:Fix of starter weapons... new patch:
				(player_get_slot, ":spawnedonce", ":player_id", slot_player_spawnedonce),
				(try_begin),
					(eq, ":spawnedonce", 1),
					(call_script, "script_player_equip_stored_default_items", ":player_id"),
				(try_end),
		
			(try_end),
		(try_end),
		(eq, ":spawn", 1),
		]),
	#arthur fix tp
	("cf_teleport_agent_to_pos", [
		(store_script_param, ":teleporter", 1),
		(store_script_param, ":position", 2),
		#(player_is_active, ":teleporter"),
		#(player_get_agent_id, ":agent_id", ":teleporter"),
		(agent_is_active, ":teleporter"),
		(agent_is_alive, ":teleporter"),
		#(assign, ":horse", -1),
		(agent_get_horse, ":horse", ":teleporter"),
		#(assign, ":teleporter", ":agent_id"),
		(try_begin),
			(agent_is_active, ":horse"),
			(agent_is_alive, ":horse"),
			#(agent_get_item_id, ":item_id", ":horse"),
			(assign, ":teleporter", ":horse"),
		(try_end),
		(agent_set_position, ":teleporter", ":position"),
		]),

	##(this_or_next|player_slot_ge, ":player_id", slot_player_fight_state, 1),
	#(player_slot_eq, ":player_id", slot_player_has_disconnected_ok, 0),
	##Arthur begins
	("cf_player_can_leave", [
	  (store_script_param, ":player_id", 1),
	  (assign, ":continue", 1),
	  (try_begin),
	  		(player_is_active, ":player_id"),
		   (player_get_agent_id, ":agent_id", ":player_id"),
		   (agent_is_active, ":agent_id"),
		   (agent_is_alive, ":agent_id"),
		  (try_begin),
		  	(agent_get_animation, ":anim", ":agent_id", 0),
		  	(this_or_next|eq, ":anim", "anim_sitting_pillow_male"),
		  	(eq, ":anim", "anim_sitting_pillow_female"),
		  (else_try),
		    (agent_get_position, pos10, ":agent_id"),
		    (player_get_slot, ":playerFac", ":player_id", slot_player_faction_id),
		    (try_for_players, ":curPlayer", 1),
		      (player_is_active, ":curPlayer"),
		      (player_get_slot, ":curPlayerFac", ":curPlayer", slot_player_faction_id),
		      (neq, ":playerFac", ":curPlayerFac"),
		      (neq, ":curPlayerFac", "fac_commoners"),
		      (player_get_agent_id, ":curAgent", ":curPlayer"),
		      (agent_is_active, ":curAgent"),
		      (agent_is_alive, ":curAgent"),
		      (agent_get_position, pos11, ":curAgent"),
		      #(position_has_line_of_sight_to_position, pos10, pos11),
		      (get_distance_between_positions_in_meters, reg11, pos10, pos11),
		      (lt, reg11, 35),
		      (eq, ":continue", 1), ##double check for hostile
		      (try_begin),
		      	(neq, ":playerFac", "fac_commoners"),
		      	(neq, ":playerFac", "fac_outlaws"),
		      	(neq, ":curPlayerFac", "fac_outlaws"),
		      	(call_script, "script_cf_factions_are_hostile", ":playerFac", ":curPlayerFac"),
		      	(assign, ":continue", 0),
		      (else_try),
		      	(eq, ":playerFac", "fac_outlaws"),
		      	(neq, ":curPlayerFac", "fac_outlaws"),
		      	(assign, ":continue", 0),
		      (else_try),
		      	(neq, ":playerFac", "fac_outlaws"),
		      	(eq, ":curPlayerFac", "fac_outlaws"),
		      	(assign, ":continue", 0),
		      (try_end),
		    (try_end),
		  (try_end),
	  (try_end),
	  (assign, reg10, ":continue"),
	]),

	
	#GGG:admin tools
	("cf_increase_stock_count", #server: increase stock count
		[(store_script_param, ":instance_id", 1),
		(store_script_param, ":attacker_agent_id", 2),
		(store_script_param, ":weapon_item_id", 3),
		
		(eq, ":weapon_item_id", "itm_admin_scalpel"),
		
		(gt, ":attacker_agent_id", 0),
		(agent_get_player_id, ":player_id", ":attacker_agent_id"),
		(player_is_active, ":player_id"),
		(agent_is_active, ":attacker_agent_id"),	 
		(player_is_admin, ":player_id"),
		 
		 #All is done, player is admin and uses admin scalpel
		 #Now restock +20
		(scene_prop_get_slot, ":current_stock", ":instance_id", slot_scene_prop_stock_count),
		(val_add, ":current_stock", 20),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_stock_count, ":current_stock"),

		(str_store_string, s0, "@You did restock this stock by 20!"),    
		(multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),
		
		#Loop through all players and tell them new stock count
		(get_max_players, ":max_players"),
		(val_add, ":max_players", 1),
		(try_for_range, ":cur_player", 0, ":max_players"),
			(player_is_active, ":cur_player"),
			(multiplayer_send_3_int_to_player, ":cur_player", server_event_scene_prop_set_slot, ":instance_id", slot_scene_prop_stock_count, ":current_stock"),
		(try_end),
	]),
	

	("on_agent_spawned", # server and clients: set agent slots and attributes after spawning
	 [(store_script_param, ":agent_id", 1), # must be valid

		(agent_set_slot, ":agent_id", slot_agent_horse_last_rider, -1),
		(agent_set_slot, ":agent_id", slot_agent_freeze_instance_id, -1),
		(agent_set_slot, ":agent_id", slot_agent_poisoner_agent_id, -1),
		(agent_set_slot, ":agent_id", slot_agent_poisoner_player_uid, -1),
		(agent_set_slot, ":agent_id", slot_agent_fishing_last_school, -1),
		(agent_set_slot, ":agent_id", slot_agent_last_horse_ridden, -1),
		(agent_set_slot, ":agent_id", slot_agent_hunting_last_carcass, -1),
		(agent_set_slot, ":agent_id", slot_agent_animal_herd_manager, -1),
		(agent_set_slot, ":agent_id", slot_agent_animal_carcass_instance_id, -1),
		(agent_set_slot,":agent_id", slot_agent_scene_prop_in_use, -1),    #GGG:sitting
		(agent_set_slot, ":agent_id", slot_agent_drowning_count, -2),
		(try_begin),
			(eq, "$g_full_respawn_health", 0),
			(agent_is_human, ":agent_id"),
			(agent_set_max_hit_points, ":agent_id", max_hit_points_percent),
		(try_end),
		(agent_get_player_id, ":player_id", ":agent_id"),
		(try_begin),
			(player_is_active, ":player_id"),
			(player_get_slot, ":food_amount", ":player_id", slot_player_spawn_food_amount),
			(player_get_slot, ":water_amount", ":player_id", slot_player_spawn_water_amount),###GGG:thirst system
			(try_begin),
				(gt, ":food_amount", 0),
				(agent_set_slot, ":agent_id", slot_agent_food_amount, ":food_amount"),
				(player_set_slot, ":player_id", slot_player_spawn_food_amount, 0),
			(try_end),
			###GGG:thirst system
			(try_begin),
				(gt, ":water_amount", 0),
				(agent_set_slot, ":agent_id", slot_agent_water_amount, ":water_amount"),
				(player_set_slot, ":player_id", slot_player_spawn_water_amount, 0),
			(try_end),
			###
			#GGG:engineer speed
			(try_begin),
				(player_get_troop_id, ":troop_id", ":player_id"),
				(is_between, ":troop_id", hero_begin, hero_end),
				(store_skill_level, ":engineer_level", "skl_engineer", ":troop_id"),
				(eq, ":engineer_level", 10),
				(agent_set_use_speed_modifier, ":agent_id", 200),
			(try_end),
			#
			(try_begin),
				(player_is_admin, ":player_id"),
				(player_get_troop_id, ":troop_id", ":player_id"),
				(eq, ":troop_id", "trp_godlike_hero"),
				(agent_set_use_speed_modifier, ":agent_id", 1000),
			(try_end),
			(try_for_range, ":equip_slot", ek_head, ek_gloves + 1),
				(agent_get_item_slot, ":item_id", ":agent_id", ":equip_slot"),
				(ge, ":item_id", all_items_begin),
				(call_script, "script_agent_calculate_stat_modifiers_for_item", ":agent_id", ":item_id", 1, 1),
			(try_end),
			(multiplayer_is_server),
			(player_get_slot, ":spawn_state", ":player_id", slot_player_spawn_state),
			(try_begin),
				(eq, ":spawn_state", player_spawn_state_invulnerable),
				(agent_set_team, ":agent_id", team_spawn_invulnerable),
				(try_begin),
					(eq, "$g_full_respawn_health", 0),
					(player_get_slot, ":spawn_health_percent", ":player_id", slot_player_next_spawn_health_percent),
					#GGG:troop system
					(try_begin), 
						(player_get_slot, ":player_faction_id", ":player_id", slot_player_faction_id),
						(is_between, ":player_faction_id", castle_factions_begin, factions_end),
						(player_get_troop_id, ":troop_id", ":player_id"),
						(this_or_next|eq, ":troop_id", "trp_footman"),
						(this_or_next|eq, ":troop_id", "trp_archer"),
						(this_or_next|eq, ":troop_id", "trp_crossbowman"),
						(this_or_next|eq, ":troop_id", "trp_lancer"),
						(this_or_next|eq, ":troop_id", "trp_man_at_arms"),
						(eq, ":troop_id", "trp_sergeant"),
						(faction_slot_ge, ":player_faction_id", slot_faction_military_strength, 1),
						(assign, ":spawn_health_percent", 100),
					(try_end),
					#
					(agent_set_hit_points, ":agent_id", ":spawn_health_percent", 0),
				(try_end),
			(else_try),
				(player_set_slot, ":player_id", slot_player_spawn_state, player_spawn_state_alive),
				(eq, ":spawn_state", player_spawn_state_at_marker),
				(scene_prop_get_instance, ":instance_id", "spr_code_spawn_marker", ":player_id"),
				(prop_instance_get_position, pos1, ":instance_id"),
				(agent_set_position, ":agent_id", pos1),
				(player_get_slot, ":spawn_health_percent", ":player_id", slot_player_spawn_health_percent),
				(try_begin),
					(gt, ":spawn_health_percent", 0), 
					(agent_set_hit_points, ":agent_id", ":spawn_health_percent", 0),
					(player_set_slot, ":player_id", slot_player_spawn_health_percent, 0),
				(try_end),
				(call_script, "script_player_set_stored_ammo_counts", ":player_id"),
			(try_end),
			(try_begin),
				###GGG:unactive system
				#(try_begin),
				#  (player_slot_eq, ":player_id", slot_player_have_access, 1),
				#  (agent_get_player_id, ":player_id", ":agent_id"),
				#  (player_get_slot, ":faction_id", ":player_id", slot_player_faction_id),
				#  (eq, ":faction_id", "fac_commoners"),
				#  (agent_set_team, ":agent_id", team_spawn_invulnerable),
				#(else_try),
				###
				(neq, ":spawn_state", player_spawn_state_invulnerable),
				(agent_set_team, ":agent_id", team_default),
				#(try_end),

			(try_end),
			(try_begin),
				#(eq, "$g_mute_global_chat", 1),
				#(player_set_is_muted, ":player_id", "$g_mute_global_chat"), 
				#(player_set_is_muted, ":player_id", 1),
			(try_end),
		(try_end),
		]),

	("setup_agent_for_respawn", # server: when an agent dies, clean up slots and attached props; set up lootable items
	 [(store_script_param, ":agent_id", 1),

		(try_begin),
			(agent_is_active, ":agent_id"),
			(agent_get_attached_scene_prop, ":instance_id", ":agent_id"),
			(try_begin),
				(prop_instance_is_valid, ":instance_id"),
				(agent_set_attached_scene_prop, ":agent_id", -1),
				(prop_instance_enable_physics, ":instance_id", 1), #GGG:fix cart bug
				(call_script, "script_cart_set_detached_position", ":instance_id"),
			(try_end),
			(agent_set_slot, ":agent_id", slot_agent_died_normally, 1),
			(agent_set_slot, ":agent_id", slot_agent_cannot_attack, 0), # so the attack restrictons checking loop will skip this agent
			(agent_get_player_id, ":player_id", ":agent_id"),
			(player_is_active, ":player_id"),
			(agent_get_position, pos1, ":agent_id"),
			(set_spawn_position, pos1),
			(store_random_in_range, ":imod", imod_plain, imod_cracked + 1),
			(spawn_item, "itm_agent_corpse", ":imod", "$g_spawn_item_prune_time"),
			(assign, ":corpse_instance_id", reg0),
			(prop_instance_set_position, ":corpse_instance_id", pos1),
			(store_mission_timer_a, ":prune_time"),
			(val_add, ":prune_time", "$g_spawn_item_prune_time"),
			(scene_prop_set_slot, ":corpse_instance_id", slot_scene_prop_prune_time, ":prune_time"),
			(scene_prop_set_slot, ":corpse_instance_id", slot_scene_prop_inventory_count, corpse_inventory_slots),
			(scene_prop_set_slot, ":corpse_instance_id", slot_scene_prop_inventory_max_length, corpse_inventory_max_length),
			(val_add, "$g_last_inventory_unique_id", 1),
			(scene_prop_set_slot, ":corpse_instance_id", slot_scene_prop_inventory_unique_id, "$g_last_inventory_unique_id"),
			(assign, ":inventory_slot", slot_scene_prop_inventory_begin),
			(try_for_range, ":player_equip_slot", slot_player_equip_head, slot_player_equip_gloves + 1),
				(player_get_slot, ":item_id", ":player_id", ":player_equip_slot"),
				(ge, ":item_id", all_items_begin),
				(scene_prop_set_slot, ":corpse_instance_id", ":inventory_slot", ":item_id"),
				(val_add, ":inventory_slot", 1),
			(try_end),
			(try_begin), # if the only items dropped were rubbish default items, remove the corpse now for performance reasons
				(eq, ":inventory_slot", slot_scene_prop_inventory_begin),
				(scene_prop_set_prune_time, ":corpse_instance_id", 1),
			###GGG:armors breakdown system  
			(else_try),
				(store_random_in_range, ":num", 1, 5),
				(eq, ":num", 3),
				(scene_prop_set_prune_time, ":corpse_instance_id", 1),
			###
			(try_end),
			(try_for_range, ":player_equip_slot", slot_player_equip_item_0, slot_player_equip_end),
				(player_set_slot, ":player_id", ":player_equip_slot", 0),
			(try_end),
			(agent_get_position, pos1, ":agent_id"),
			(agent_get_wielded_item, ":weapon_item_id", ":agent_id", 0),
			(agent_get_wielded_item, ":shield_item_id", ":agent_id", 1),
			(set_fixed_point_multiplier, 100),
			(position_get_z, ":height", pos1), # the engine only drops the wielded items, only if above water level: drop all equipped items
			(try_for_range, ":equip_slot", ek_item_0, ek_item_3 + 1),
				(agent_get_item_slot, ":item_id", ":agent_id", ":equip_slot"),
				(ge, ":item_id", all_items_begin),
				(try_begin),
					(this_or_next|eq, ":item_id", ":weapon_item_id"),
					(eq, ":item_id", ":shield_item_id"),
					(gt, ":height", -50),
					(neq, ":item_id", "itm_money_bag"),
				(else_try),
					(store_add, ":unequip_slot", ":equip_slot", 1),
					(agent_unequip_item, ":agent_id", ":item_id", ":unequip_slot"), # if spawning an item manually, remove it so the engine definitely won't drop a duplicate
					(call_script, "script_set_random_spawn_position", 50),
					(spawn_item, ":item_id", 0, "$g_spawn_item_prune_time"),
					(call_script, "script_check_on_item_dropped", ":agent_id", ":item_id", reg0, 1),
				(try_end),
			(try_end),
			(agent_get_slot, ":freeze_instance_id", ":agent_id", slot_agent_freeze_instance_id),
			(try_begin),
				(gt, ":freeze_instance_id", -1),
				(call_script, "script_remove_scene_prop", ":freeze_instance_id"),
				(agent_set_slot, ":agent_id", slot_agent_freeze_instance_id, -1),
			(try_end),
			(try_begin),
				(neq, "$g_game_type", "mt_permanent_death"),
				(agent_get_troop_id, ":troop_id", ":agent_id"),
				(troop_get_slot, ":spawn_health_percent", ":troop_id", slot_troop_spawn_health_percent),
				(player_set_slot, ":player_id", slot_player_next_spawn_health_percent, ":spawn_health_percent"),
				(player_get_slot, ":inactive_index", ":player_id", slot_player_inactive_index),
				(try_begin), # save values to the inactive players array
					(gt, ":inactive_index", 0),
					(player_get_unique_id, ":unique_id", ":player_id"),
					(troop_slot_eq, "trp_inactive_players_array", ":inactive_index", ":unique_id"),
					(call_script, "script_cf_player_store_inactive", ":player_id", ":inactive_index"),
				(try_end),
			(else_try),
				(player_set_slot, ":player_id", slot_player_next_spawn_health_percent, 100),
				(player_set_troop_id, ":player_id", playable_troops_begin),
				(player_set_slot, ":player_id", slot_player_faction_id, factions_begin),
			(try_end),
			(player_set_slot, ":player_id", slot_player_spawn_state, player_spawn_state_dead),
		(try_end),
		]),

	("setup_player_joined", # server: when a player connects, update necessary data on clients, restore data from previous play sessions in this mission, and set up other attributes
	 [(store_script_param, ":player_id", 1), # must be valid

		(player_set_slot, ":player_id", slot_player_last_instance_id, -1),  ###GGG:itme chest
		#(player_set_slot, ":player_id", slot_player_have_access, 0),  ###GGG:unactive system
		(player_set_team_no, ":player_id", team_spectators), #GGG:team_default

		(player_set_slot, ":player_id", slot_player_requested_spawn_point, -1), # setting the initial team to spectator seems to occasionally stop that client loading properly, this is a work around
		(player_set_slot, ":player_id", slot_player_next_chat_event_type, client_event_chat_message_begin),
		(try_for_range, ":castle_owner_slot", slot_mission_data_castle_owner_faction_begin, slot_mission_data_castle_owner_faction_end),
			(troop_get_slot, ":castle_owner", "trp_mission_data", ":castle_owner_slot"),
			(faction_slot_eq, ":castle_owner", slot_faction_is_active, 1),
			(multiplayer_send_3_int_to_player, ":player_id", server_event_troop_set_slot, "trp_mission_data", ":castle_owner_slot", ":castle_owner"),
		(try_end),
		(try_for_range, ":faction_id", factions_begin, factions_end),
			(faction_slot_eq, ":faction_id", slot_faction_is_active, 1),
			(ge, ":faction_id", castle_factions_begin),
			(faction_get_slot, ":banner_mesh", ":faction_id", slot_faction_banner_mesh),
			(multiplayer_send_3_int_to_player, ":player_id", server_event_faction_set_slot, ":faction_id", slot_faction_banner_mesh, ":banner_mesh"),
			(try_begin),
				(faction_slot_eq, ":faction_id", slot_faction_name_is_custom, 1),
				(multiplayer_send_3_int_to_player, ":player_id", server_event_troop_set_slot, "trp_mission_data", slot_mission_data_faction_to_change_name_of, ":faction_id"),
				(str_store_faction_name, s0, ":faction_id"),
				(multiplayer_send_string_to_player, ":player_id", server_event_faction_set_name, s0),
			(try_end),
			(try_for_range, ":other_faction_id", castle_factions_begin, factions_end),
				(faction_slot_eq, ":faction_id", slot_faction_is_active, 1),
				(store_add, ":relation_slot", slot_faction_relations_begin, ":other_faction_id"),
				(faction_get_slot, ":relation", ":faction_id", ":relation_slot"),
				#(neq, ":relation", 0),
				(multiplayer_send_3_int_to_player, ":player_id", server_event_faction_set_slot, ":faction_id", ":relation_slot", ":relation"),
			(try_end),
			(try_begin),
				(faction_slot_eq, ":faction_id", slot_faction_is_locked, 1),
				(multiplayer_send_3_int_to_player, ":player_id", server_event_faction_set_slot, ":faction_id", slot_faction_is_locked, 1),
			(try_end),
			#GGG:admin tools
			(try_begin),
				(faction_slot_eq, ":faction_id", slot_faction_alow_use_capture, 1),
				(multiplayer_send_3_int_to_player, ":player_id", server_event_faction_set_slot, ":faction_id", slot_faction_alow_use_capture, 1),
			(try_end),
			#GGG:troop system
			(try_begin),
				(faction_get_slot, ":strength", ":faction_id", slot_faction_military_strength),
				(multiplayer_send_3_int_to_player, ":player_id", server_event_faction_set_slot, ":faction_id", slot_faction_military_strength, ":strength"),
			(try_end),
			#
		(try_end),
		(scene_prop_get_num_instances, ":pole_num", "spr_pw_castle_capture_point"),
		(try_for_range, ":pole_no", 0, ":pole_num"), # so secondary capture point banner item ids match up for the client side repositioning script, after joining
			(scene_prop_get_instance, ":pole_instance_id", "spr_pw_castle_capture_point", ":pole_no"),
			(scene_prop_get_slot, ":capture_faction_id", ":pole_instance_id", slot_scene_prop_capture_faction_id),
			(gt, ":capture_faction_id", 0),
			(multiplayer_send_3_int_to_player, ":player_id", server_event_scene_prop_set_slot, ":pole_instance_id", slot_scene_prop_capture_faction_id, ":capture_faction_id"),
		(try_end),
		(get_max_players, ":max_players"),
		(player_get_unique_id, ":player_unique_id", ":player_id"),
		(troop_get_slot, ":inactive_array_size", "trp_inactive_players_array", slot_player_array_size),
		(try_begin), # try find player data in the inactive array, from a previous play session
			(gt, ":inactive_array_size", 0),
			(store_sub, ":inactive_last_entry_number", ":inactive_array_size", 1),
			(store_mul, ":inactive_index", ":inactive_last_entry_number", player_array_entry_size),
			(val_add, ":inactive_index", slot_player_array_begin),
			(assign, ":loop_end", ":inactive_array_size"),
			(try_for_range, ":unused", 0, ":loop_end"),
				(troop_get_slot, ":inactive_unique_id", "trp_inactive_players_array", ":inactive_index"),
				(neq, ":inactive_unique_id", ":player_unique_id"),
				(val_sub, ":inactive_index", player_array_entry_size),
			(else_try),
				(troop_set_slot, "trp_inactive_players_array", ":inactive_index", 0),
				(assign, ":loop_end", -1),
			(try_end),
			(eq, ":loop_end", -1),
			(store_add, ":temp_index", ":inactive_index", player_array_troop_id),
			(troop_get_slot, ":troop_id", "trp_inactive_players_array", ":temp_index"),
			(store_add, ":temp_index", ":inactive_index", player_array_faction_id),
			(troop_get_slot, ":faction_id", "trp_inactive_players_array", ":temp_index"),
			(store_add, ":temp_index", ":inactive_index", player_array_gold_value),
			(troop_get_slot, ":gold_value", "trp_inactive_players_array", ":temp_index"),
			(store_add, ":temp_index", ":inactive_index", player_array_outlaw_rating),
			(troop_get_slot, ":outlaw_rating", "trp_inactive_players_array", ":temp_index"),
			(try_begin),
				(gt, ":outlaw_rating", 0),
				(multiplayer_send_3_int_to_server, client_event_player_set_slot, ":player_id", slot_player_outlaw_rating, ":outlaw_rating"), #GGG:outlaw rating
				(multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_outlaw_rating, ":outlaw_rating"),
			(try_end),
			(try_begin),
				(neq, ":faction_id", 0),
				(try_for_range, ":other_player_id", 1, ":max_players"),
					(player_is_active, ":other_player_id"),
					(multiplayer_send_3_int_to_player, ":other_player_id", server_event_player_set_slot, ":player_id", slot_player_faction_id, ":faction_id"),
				(try_end),
				(try_begin),
					(faction_slot_eq, ":faction_id", slot_faction_lord_player_uid, ":player_unique_id"),
					(call_script, "script_player_set_lord", ":player_id", ":faction_id"),
				(try_end),
			(try_end),
		(else_try), # otherwise, set default attributes
			(assign, ":troop_id", playable_troops_begin),
			(assign, ":faction_id", factions_begin),
			(try_begin),
				(neq, "$g_game_type", "mt_no_money"),
				(neq, "$g_game_type", "mt_permanent_death"),
				(store_random_in_range, ":gold_value", 30, 100),
				(val_mul, ":gold_value", "$g_starting_gold_multiplier"),
				(val_div, ":gold_value", 100),
			(else_try),
				(assign, ":gold_value", 0),
			(try_end),
			(assign, ":outlaw_rating", 0),
		(try_end),
		(player_set_troop_id, ":player_id", ":troop_id"),
		(player_set_slot, ":player_id", slot_player_faction_id, ":faction_id"),
		(call_script, "script_player_adjust_gold", ":player_id", ":gold_value", 0),
		(player_set_slot, ":player_id", slot_player_outlaw_rating, ":outlaw_rating"),
		(troop_get_slot, ":spawn_health_percent", ":troop_id", slot_troop_spawn_health_percent),
		(player_set_slot, ":player_id", slot_player_next_spawn_health_percent, ":spawn_health_percent"),
		(try_begin),
			(neq, ":faction_id", "fac_commoners"),
			(str_store_player_username, s0, ":player_id"),
			(str_store_faction_name, s1, ":faction_id"),
			(server_add_message_to_log, "str_s0_joined_the_s1"),
		(try_end),
		(try_for_range, ":other_player_id", 1, ":max_players"),
			(neq, ":other_player_id", ":player_id"),
			(player_is_active, ":other_player_id"),
			(player_get_slot, ":other_faction_id", ":other_player_id", slot_player_faction_id),
			(try_begin),
				(neq, ":other_faction_id", 0),
				(multiplayer_send_4_int_to_player, ":player_id", server_event_player_set_slot, ":other_player_id", slot_player_faction_id, ":other_faction_id", change_faction_type_no_respawn),
			(try_end),
			(player_get_score, ":score", ":other_player_id"),
			(player_get_kill_count, ":kills", ":other_player_id"),
			(player_get_death_count, ":deaths", ":other_player_id"),
			(multiplayer_send_4_int_to_player, ":player_id", server_event_set_player_score_kill_death, ":other_player_id", ":score", ":kills", ":deaths"),
			(try_begin),
				(player_slot_eq, ":other_player_id", slot_player_is_lord, 1),
				(multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":other_player_id", slot_player_is_lord, 1),
			(try_end),
		(try_end),
		(try_for_agents, ":other_agent_id"),
			(agent_get_attached_scene_prop, ":attached_instance_id", ":other_agent_id"),
			(ge, ":attached_instance_id", 0),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_set_attached_scene_prop, ":other_agent_id", ":attached_instance_id"),
		(try_end),
		(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_respawn_period, "$g_respawn_period"),
		#(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_num_bots_voteable, "$g_num_bots_voteable"),
		(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_maps_voteable, "$g_scenes_voteable"),
		#(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_factions_voteable, "$g_factions_voteable"),
		(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_kick_voteable, "$g_kick_voteable"),
		(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_ban_voteable, "$g_ban_voteable"),
		(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_force_default_armor, "$g_force_weather"),
		(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_disallow_ranged_weapons, "$g_full_respawn_health"),
		(store_mission_timer_a, ":mission_timer"),
		(multiplayer_send_2_int_to_player, ":player_id", server_event_return_game_rules, command_set_server_mission_timer, ":mission_timer"),
		]),

	("after_client_is_setup", # clients: called after the server has finished sending the initial module data updates
	 [
		(assign, "$g_preset_message_display_enabled", 1),
		(call_script, "script_redraw_castle_banners", redraw_client_banner_positions, -1),
		]),

	("cf_save_player_exit", # server: when a player disconnects, save attributes to the inactive players list
	 [(store_script_param, ":player_id", 1), # must be valid
	###Arthur begins: check that player has been initialized already
	(player_slot_eq, ":player_id", slot_player_initialized, 1),
	(player_get_unique_id, reg1, ":player_id"),
	###	
	##arthur: code serves no purpose..
	 #(try_begin), #schauen ob player exploited
	#		(player_get_agent_id, ":my_agent_id", ":player_id"),
	#		(neq, ":my_agent_id", -1),
	#		(agent_is_active, ":my_agent_id"),
	#		(neg|agent_is_alive, ":my_agent_id"),
	#		(agent_get_player_id, ":player_id", ":my_agent_id"),
	#		(call_script, "script_player_death_update", ":player_id"), #removes gear from database of the player
	# (try_end),
	
		#Wir speichern jetzt
	(send_message_to_url, "@http://localhost/backendDsDvC/changestatus.php?playeruid={reg1}"), #arthur: change the status for php
	 (try_begin),
	 		#arthur begins
	 		(call_script, "script_cf_player_can_leave", ":player_id"),

			(assign, reg0, ":player_id"),	
			(player_is_active, ":player_id"), #
			#(server_add_message_to_log, "@break1"),
			(neg|player_slot_ge, ":player_id", slot_player_fight_state, 1), #GGG:debug
			#(player_slot_eq, ":player_id", slot_player_has_disconnected_ok, 1),  #make sure player pass the time
			(assign, ":can_continue", 1),
			#(server_add_message_to_log, "@break2"),
			#arthur begins.. dun wanna run the check more times than needed its fairly expensive.. using or in case of a ddos attack
			(try_begin),
			#	(server_add_message_to_log, "@break3"),
				(neg|player_slot_eq, ":player_id", slot_player_check_passed, 1),
			#	(server_add_message_to_log, "@break3"),
				(call_script, "script_cf_player_can_leave", ":player_id"),
				(neq, reg10, 1),
			#	(server_add_message_to_log, "@break4"),
				(assign, ":can_continue", 0), #rip equipments
			(try_end),
			(eq, ":can_continue", 1),
			(player_set_slot, ":player_id", slot_player_check_passed, 1),
			#(server_add_message_to_log, "@break5"),
			(player_get_agent_id, ":agent_id", reg0),
			(agent_is_active, ":agent_id"),
			(agent_is_alive, ":agent_id"),
			(neq, ":agent_id", -1),
			(player_get_unique_id, ":player_unique_id", ":player_id"),
			(agent_get_item_slot, ":item0", ":agent_id", 0),
			(agent_get_item_slot, ":item1", ":agent_id", 1),
			(agent_get_item_slot, ":item2", ":agent_id", 2),
			(agent_get_item_slot, ":item3", ":agent_id", 3),
			(player_get_slot, ":head", ":player_id", slot_player_equip_head),
			(player_get_slot, ":body", ":player_id", slot_player_equip_body),
			(player_get_slot, ":foot", ":player_id", slot_player_equip_foot),
			(player_get_slot, ":gloves", ":player_id", slot_player_equip_gloves),
			(store_agent_hit_points, ":original_hit_points", ":agent_id", 0),
			(player_get_troop_id, ":this_troop_id", ":player_id"),
			(is_between, ":this_troop_id", playable_troops_begin, playable_troops_end),
			#GGG:skill
			(try_begin),
				(is_between, ":this_troop_id", hero_begin, hero_end),
				(troop_set_slot, ":this_troop_id", slot_troop_hero_is_used, 0),
			(try_end),
			#
			(player_get_slot, ":faction", ":player_id", slot_player_faction_id),
			(assign, reg1, ":player_unique_id"),
			(assign, reg2, ":head"),
			(assign, reg3, ":body"),
			(assign, reg4, ":foot"),
			(assign, reg5, ":gloves"),
			(assign, reg6, ":item0"),
			(assign, reg7, ":item1"),
			(assign, reg8, ":item2"),
			(assign, reg9, ":item3"),
			(assign, reg10, ":original_hit_points"),
			(assign, reg20, ":this_troop_id"),
			(assign, reg11, ":faction"),
			(player_get_gold, ":original_player_gold", ":player_id"),
			(assign, reg12, ":original_player_gold"),
			(agent_get_position, pos1, ":agent_id"),
			(position_get_x, ":pos_x", pos1),
			(position_get_y, ":pos_y", pos1),
			(position_get_z, ":pos_z", pos1),
			(assign, reg13, ":pos_x"),
			(assign, reg14, ":pos_y"),
			(assign, reg15, ":pos_z"),
			(agent_get_slot, ":food_amount", ":agent_id", slot_agent_food_amount),
			(assign, reg16, ":food_amount"),
			###GGG:thirst system
			(agent_get_slot, ":water_amount", ":agent_id", slot_agent_water_amount),
			(assign, reg18, ":water_amount"),
			###GGG:outlaw rating
			(player_get_slot, ":outlaw_rating", ":player_id", slot_player_outlaw_rating),
			(assign, reg19, ":outlaw_rating"),
			
			# horse reg 17...
			(try_begin), #checken ob pferd ueberhaupt existiert
				(agent_get_horse, ":horse", ":agent_id"),
				(agent_is_active, ":horse"),
				(agent_is_alive, ":horse"),
				(agent_get_item_id, ":horse_itemid", ":horse"),
				(assign, reg17, ":horse_itemid"),
				(player_slot_eq, ":player_id", slot_player_fight_state, 0),
				(agent_fade_out, ":horse"),
			(else_try),
				(assign, reg17, "@0"),
			(try_end),
			
			#Falls Admin nur Onlinestatus aendern
			#(try_begin),
			#	(player_is_admin, ":player_id"),
			#	(send_message_to_url, "@http://localhost/backendDsDvC/changestatus.php?playeruid={reg1}"),
			#(else_try),
			
				#combatlog check
				(try_begin),
				#combatlog
					#(player_slot_ge, ":player_id", slot_player_fight_state, 1),
					#(call_script, "script_player_death_update", ":player_id"),
				#(else_try),
					#kein combatlog
					#Jetzt noch alle Items entfernen
					(try_begin),
						(gt, ":item0", -1),
						(call_script, "script_cf_agent_consume_item", ":agent_id", ":item0", 1),
					(try_end),
					(try_begin),
						(gt, ":item1", -1),
						(call_script, "script_cf_agent_consume_item", ":agent_id", ":item1", 1),
					(try_end),
					(try_begin),
						(gt, ":item2", -1),
						(call_script, "script_cf_agent_consume_item", ":agent_id", ":item2", 1),
					(try_end),
					(try_begin),
						(gt, ":item3", -1),
						(call_script, "script_cf_agent_consume_item", ":agent_id", ":item3", 1),
					(try_end),
					(send_message_to_url, "@http://localhost/backendDsDvC/save.php?playeruid={reg1}&head={reg2}&body={reg3}&foot={reg4}&gloves={reg5}&item1={reg6}&item2={reg7}&item3={reg8}&item4={reg9}&health={reg10}&carriedgold={reg12}&troop={reg20}&faction={reg11}&posx={reg13}&posy={reg14}&posz={reg15}&food={reg16}&horse={reg17}&water={reg18}&outlaw={reg19}"),
						#(try_begin),
						#	(gt, ":last_instance", 0),
						#	(call_script, "script_cf_save_item_bank", ":player_id"),
						#(try_end),
					#(send_message_to_url, "@http://localhost/backendDsDvC/changestatus.php?playeruid={reg1}"),
			    #(player_set_slot, ":player_id", slot_player_has_disconnected_ok, 0), #GGG:make sure player reset status
				(try_end),
			#(try_end),
			(str_store_player_username, s55, ":player_id"),
			(server_add_message_to_log, "@{s55} left the server. Guid: {reg1}|Head: {reg2}|Body: {reg3}|Legs: {reg4}|Hand: {reg5}|Bag: {reg6}/{reg7}/{reg8}/{reg9}|Hit Point: {reg10}|Troop: {reg20}|Faction: {reg11}|Gold: {reg12}|pos: x{reg13}/y{reg14}/z{reg15}|food: {reg16}|Horse: {reg17}|water: {reg18}|outlaw: {reg19}"),
			(agent_fade_out, ":agent_id"),
	 (else_try),
			(assign, reg0, ":player_id"), 
			(player_is_active, ":player_id"), 
			#(player_slot_ge, ":player_id", slot_player_fight_state, 1),
			#(player_slot_eq, ":player_id", slot_player_has_disconnected_ok, 0), why bother checking.. its one way or the other
			(call_script, "script_player_death_update", ":player_id"),

			(player_get_unique_id, ":player_unique_id", ":player_id"),
			(player_get_slot, ":head", ":player_id", slot_player_equip_head),
			(player_get_slot, ":body", ":player_id", slot_player_equip_body),
			(player_get_slot, ":foot", ":player_id", slot_player_equip_foot),
			(player_get_slot, ":gloves", ":player_id", slot_player_equip_gloves),
			(player_get_troop_id, ":this_troop_id", ":player_id"),
			(is_between, ":this_troop_id", playable_troops_begin, playable_troops_end),
			(player_get_slot, ":faction", ":player_id", slot_player_faction_id),
			(assign, reg1, ":player_unique_id"),
			(assign, reg2, 0),
			(assign, reg3, 0),
			(assign, reg4, 0),
			(assign, reg5, 0),

			(assign, reg20, ":this_troop_id"),
			#GGG:skill
			(try_begin),
				(is_between, ":this_troop_id", hero_begin, hero_end),
				(troop_set_slot, ":this_troop_id", slot_troop_hero_is_used, 0),
			(try_end),
			#
			(assign, reg11, ":faction"),
			(player_get_gold, ":original_player_gold", ":player_id"),
			(assign, reg12, 0),
			(player_get_slot, ":outlaw_rating", ":player_id", slot_player_outlaw_rating),
			(assign, reg19, ":outlaw_rating"),
			
			#(try_begin),
			#  (player_is_admin, ":player_id"),
			#  (send_message_to_url, "@http://localhost/backendDsDvC/changestatus.php?playeruid={reg1}"),
			#(try_end),
			
			(send_message_to_url, "@http://localhost/backendDsDvC/deathsave.php?playeruid={reg1}&head={reg2}&body={reg3}&foot={reg4}&gloves={reg5}&carriedgold={reg12}&troop={reg20}&faction={reg11}&outlaw={reg19}"),
			(str_store_player_username, s55, ":player_id"),
			(server_add_message_to_log, "@{s55} dead but left the server. Guid: {reg1}|Head: {reg2}|Body: {reg3}|Legs: {reg4}|Hand: {reg5}|Troop: {reg20}|Faction: {reg11}|Gold: {reg12}|Horse: {reg17}|outlaw: {reg19}"),
		#
	 (try_end),
		]),


	("cf_player_store_inactive", # server: store player attributes starting at a specified index in a list
	 [(store_script_param, ":player_id", 1), # must be valid
		(store_script_param, ":inactive_index", 2),

		(player_get_troop_id, ":troop_id", ":player_id"),
		(is_between, ":troop_id", playable_troops_begin, playable_troops_end),
		(try_begin),
			(neq, "$g_game_type", "mt_permanent_death"),
			(player_get_slot, ":faction_id", ":player_id", slot_player_faction_id),
			(player_get_gold, ":gold_value", ":player_id"),
		(else_try),
			(assign, ":troop_id", playable_troops_begin),
			(assign, ":faction_id", factions_begin),
			(assign, ":gold_value", 0),
		(try_end),
		(store_add, ":temp_index", ":inactive_index", player_array_troop_id),
		(troop_set_slot, "trp_inactive_players_array", ":temp_index", ":troop_id"),
		(store_add, ":temp_index", ":inactive_index", player_array_faction_id),
		(troop_set_slot, "trp_inactive_players_array", ":temp_index", ":faction_id"),
		(store_add, ":temp_index", ":inactive_index", player_array_gold_value),
		(troop_set_slot, "trp_inactive_players_array", ":temp_index", ":gold_value"),
		(player_get_slot, ":outlaw_rating", ":player_id", slot_player_outlaw_rating),
		(store_add, ":temp_index", ":inactive_index", player_array_outlaw_rating),
		(troop_set_slot, "trp_inactive_players_array", ":temp_index", ":outlaw_rating"),
		]),

	("apply_consequences_for_agent_death", # server and clients: when an agent dies, adjust scores, display messages, drop a loot money bag, check outlaw rating
	 [(store_script_param, ":dead_agent_id", 1),
		(store_script_param, ":killer_agent_id", 2),

		(try_begin),
			(gt, ":dead_agent_id", -1),
			(agent_get_player_id, ":dead_player_id", ":dead_agent_id"),
			(player_is_active, ":dead_player_id"),
			(try_begin),
				(gt, ":killer_agent_id", -1),
				(neq, ":killer_agent_id", ":dead_agent_id"),
				(agent_get_player_id, ":killer_player_id", ":killer_agent_id"),
				(player_is_active, ":killer_player_id"),
				(player_get_slot, ":dead_faction_id", ":dead_player_id", slot_player_faction_id),
				(player_get_slot, ":killer_faction_id", ":killer_player_id", slot_player_faction_id),
				(try_begin),
					(lt, ":dead_faction_id", castle_factions_begin),
					(lt, ":killer_faction_id", castle_factions_begin),
					(assign, ":dead_player_add_score", -1),
					(assign, ":killer_player_add_score", 1),
				(else_try),
					(call_script, "script_cf_factions_are_hostile", ":dead_faction_id", ":killer_faction_id"),
					(assign, ":dead_player_add_score", -1),
					(assign, ":killer_player_add_score", 1),
				(else_try),
					(assign, ":dead_player_add_score", 0),
					(assign, ":killer_player_add_score", -1),
					(try_begin),
						(str_store_player_username, s0, ":killer_player_id"),
						(try_begin),
							(eq, ":dead_faction_id", ":killer_faction_id"),
							(assign, ":string_id", "str_s0_killed_faction_member"),
						(else_try),
							(assign, ":string_id", "str_s0_killed_friendly_faction_member"),
						(try_end),
						(try_begin),
							(neg|multiplayer_is_server),
							(display_message, ":string_id", 0xFFAA0000),
						(else_try),
							(server_add_message_to_log, ":string_id"),
						(try_end),
					(try_end),
				(try_end),
			(else_try),
				(assign, ":dead_player_add_score", -1),
				(assign, ":killer_player_add_score", 0),
			(try_end),
		(else_try),
			(assign, ":dead_player_add_score", 0),
			(assign, ":killer_player_add_score", 0),
		(try_end),
		(try_begin),
			(le, ":dead_player_add_score", -1),
			(player_get_score, ":dead_player_score", ":dead_player_id"),
			(val_add, ":dead_player_score", ":dead_player_add_score"),
			(player_set_score, ":dead_player_id", ":dead_player_score"),
			(player_get_death_count, ":dead_player_deaths", ":dead_player_id"),
			(val_add, ":dead_player_deaths", 1),
			(player_set_death_count, ":dead_player_id", ":dead_player_deaths"),
			(try_begin),
				(multiplayer_is_server),
				(neq, "$g_game_type", "mt_no_money"),
				(call_script, "script_player_drop_loot", ":dead_player_id"),
			(try_end),
		(try_end),
		(try_begin),
			(neq, ":killer_player_add_score", 0),
			(player_get_score, ":killer_player_score", ":killer_player_id"),
			(val_add, ":killer_player_score", ":killer_player_add_score"),
			(player_set_score, ":killer_player_id", ":killer_player_score"),
			(ge, ":killer_player_add_score", 1),
			(player_get_kill_count, ":killer_player_kills", ":killer_player_id"),
			(val_add, ":killer_player_kills", 1),
			(player_set_kill_count, ":killer_player_id", ":killer_player_kills"),
		(try_end),
		(try_begin),
			(multiplayer_is_server),
			##Arthur update kills
			(try_begin),
				(player_is_active, ":killer_player_id"),
				(player_is_active, ":dead_player_id"),
				(player_get_score, ":dead_player_score", ":dead_player_id"),
				(player_get_kill_count, ":dead_player_kills", ":dead_player_id"),
				(player_get_death_count, ":dead_player_deaths", ":dead_player_id"),
				(player_get_score, ":killer_player_score", ":killer_player_id"),
				(player_get_kill_count, ":killer_player_kills", ":killer_player_id"),
				(player_get_death_count, ":killer_player_deaths", ":killer_player_id"),
				(try_for_players, ":curPlayer", 1),
					(player_is_active, ":curPlayer"),
					(multiplayer_send_4_int_to_player, ":curPlayer", server_event_set_player_score_kill_death, ":killer_player_id", ":killer_player_score", ":killer_player_kills", ":killer_player_deaths"),
					(neq, ":killer_player_id", ":dead_player_id"),
					(multiplayer_send_4_int_to_player, ":curPlayer", server_event_set_player_score_kill_death, ":dead_player_id", ":dead_player_score", ":dead_player_kills", ":dead_player_deaths"),
				(try_end),
			(try_end),
			#(try_begin),
			#  (le, ":killer_player_add_score", -1),
			#  (call_script, "script_player_change_check_outlaw_rating", ":killer_player_id", outlaw_rating_for_team_kill, 0),
			#(else_try),
			#  (player_is_active, ":killer_player_id"),
			#  (player_slot_eq, ":killer_player_id", slot_player_faction_id, "fac_outlaws"),
			#  (call_script, "script_player_change_check_outlaw_rating", ":killer_player_id", outlaw_rating_for_kill, 0),
			#(try_end),
			#GGG:outlaw rating
			(try_begin),
				(eq, ":killer_faction_id", "fac_commoners"),
				(try_begin),
					(this_or_next|eq, ":dead_faction_id", "fac_commoners"),
					(eq, ":dead_faction_id", "fac_outlaws"),
					(player_slot_eq, ":dead_player_id", slot_player_outlaw_rating, 0),
					(player_get_slot, ":not_protected", ":dead_player_id", slot_player_fight_not_good),
					(le, ":not_protected", 0),
					(call_script, "script_player_change_check_outlaw_rating", ":killer_player_id", outlaw_rating_for_team_kill, 0),
				#(else_try),
					#(neq, ":dead_faction_id", "fac_commoners"),
					#(neq, ":dead_faction_id", "fac_outlaws"),
					#(player_slot_eq, ":dead_player_id", slot_player_outlaw_rating, 0),
					#(call_script, "script_player_change_check_outlaw_rating", ":killer_player_id", outlaw_rating_for_kill, 0),
				(try_end),
			(else_try),
				(eq, ":killer_faction_id", "fac_outlaws"),
				(try_begin),
					(eq, ":dead_faction_id", "fac_commoners"),
					(player_slot_eq, ":dead_player_id", slot_player_outlaw_rating, 0),
					(player_get_slot, ":not_protected", ":dead_player_id", slot_player_fight_not_good),
					(le, ":not_protected", 0),
					(call_script, "script_player_change_check_outlaw_rating", ":killer_player_id", outlaw_rating_for_team_kill, 0),
				(else_try),
					(eq, ":dead_faction_id", "fac_outlaws"),
					(player_slot_eq, ":dead_player_id", slot_player_outlaw_rating, 0),
					(call_script, "script_player_change_check_outlaw_rating", ":killer_player_id", outlaw_rating_for_team_kill, 0),
				(try_end),
			(else_try), #caslte faction begin
				(is_between, ":killer_faction_id", castle_factions_begin, factions_end),
				(try_begin),
					#(eq, ":dead_faction_id", "fac_commoners"),
					#(player_slot_eq, ":dead_player_id", slot_player_outlaw_rating, 0),
					#(player_get_slot, ":not_protected", ":dead_player_id", slot_player_fight_not_good),
					#(le, ":not_protected", 0),
					#(call_script, "script_player_change_check_outlaw_rating", ":killer_player_id", outlaw_rating_for_kill, 0),
				#(else_try),
					(le, ":killer_player_add_score", -1),
					(neq, ":dead_faction_id", "fac_outlaws"),
					(neq, ":dead_faction_id", "fac_commoners"),
					#(try_begin),
					#  (eq, ":dead_faction_id", ":killer_faction_id"),
					#  (player_slot_eq, ":dead_player_id", slot_player_outlaw_rating, 0),
					#  (call_script, "script_player_change_check_outlaw_rating", ":killer_player_id", outlaw_rating_for_team_kill, 0),
					#(else_try),
						(neq, ":dead_faction_id", ":killer_faction_id"),
						(call_script, "script_player_change_check_outlaw_rating", ":killer_player_id", outlaw_rating_for_kill, 0),
					#(try_end),
				(try_end),
			(try_end),
			#
		(else_try),
			(agent_is_active, ":killer_agent_id"),
			(agent_is_active, ":dead_agent_id"),
			(agent_is_human, ":dead_agent_id"),
			(mission_cam_get_position, pos1),
			(agent_get_position, pos2, ":dead_agent_id"),
			(get_sq_distance_between_positions, ":sq_distance", pos1, pos2),
			(try_begin),
				(lt, ":sq_distance", sq(max_distance_local_chat)),
				(val_add, "$g_recent_nearby_deaths_factor", 50),
				(ge, "$g_recent_nearby_deaths_factor", 100),
				(music_set_situation, mtf_sit_fight),
			(try_end),
			(multiplayer_get_my_player, ":my_player_id"),
			(try_begin),
				(player_is_active, ":my_player_id"),
				(player_get_agent_id, ":my_agent_id", ":my_player_id"),
				(eq, ":dead_agent_id", ":my_agent_id"),
				(music_set_situation, mtf_sit_killed),
			(try_end),
		(try_end),
		]),

	("player_change_check_outlaw_rating", # server: update a player's outlaw rating and change faction if necessary
	 [(store_script_param, ":player_id", 1), # must be valid
		(store_script_param, ":add_rating", 2),
		(store_script_param, ":force_outlawed", 3), # change to outlaws even if the rating is not past the threshold

		(try_begin),
			(player_is_active, ":player_id"), #GGG:fix
			(player_get_slot, ":outlaw_rating", ":player_id", slot_player_outlaw_rating),
			(store_add, ":new_outlaw_rating", ":outlaw_rating", ":add_rating"),
			(val_min, ":new_outlaw_rating", outlaw_rating_maximum),
			(try_begin),
				(neq, ":new_outlaw_rating", ":outlaw_rating"),
				(player_set_slot, ":player_id", slot_player_outlaw_rating, ":new_outlaw_rating"),
				(multiplayer_send_3_int_to_server, client_event_player_set_slot, ":player_id", slot_player_outlaw_rating, ":new_outlaw_rating"), #GGG:outlaw rating
				(multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":player_id", slot_player_outlaw_rating, ":new_outlaw_rating"),
			(try_end),
			(try_begin),
				(neg|player_slot_eq, ":player_id", slot_player_faction_id, "fac_outlaws"),
				(this_or_next|eq, ":force_outlawed", 1),
				(ge, ":new_outlaw_rating", outlaw_rating_outlawed),
				(call_script, "script_player_set_worse_respawn_troop", ":player_id", "trp_ruffian"),
				(call_script, "script_change_faction", ":player_id", "fac_outlaws", change_faction_type_outlawed),
			#GGG:outlaw rating
			(else_try),
				(player_slot_eq, ":player_id", slot_player_faction_id, "fac_outlaws"),
				(this_or_next|eq, ":force_outlawed", 1),
				(eq, ":new_outlaw_rating", outlaw_rating_maximum),
				(call_script, "script_player_set_worse_respawn_troop", ":player_id", "trp_prisoner"),
			###
			(try_end),
		(try_end),
		]),

	("player_drop_loot", # server: drop a loot money bag based on amount carried and server settings
	 [(store_script_param, ":player_id", 1), # must be valid

		(try_begin),
			(neq, "$g_game_type", "mt_no_money"),
			(player_get_gold, ":gold", ":player_id"),
			(gt, ":gold", 0),
			(try_begin),
				(neq, "$g_game_type", "mt_permanent_death"),
				(store_random_in_range, ":loot_multiplier", 10, 21),
				(store_mul, ":gold_loot", ":loot_multiplier", "$g_combat_gold_multiplier"),
				(val_min, ":gold_loot", 10000),
				(val_mul, ":gold_loot", ":gold"),
				(val_div, ":gold_loot", 10000),
				(val_sub, ":gold", ":gold_loot"),
			(else_try),
				(assign, ":gold_loot", ":gold"),
				(assign, ":gold", 0),
			(try_end),
			(gt, ":gold_loot", 0),
			(call_script, "script_player_adjust_gold", ":player_id", ":gold", 0),
			(player_get_agent_id, ":agent_id", ":player_id"),
			(agent_get_position, pos1, ":agent_id"),
			(call_script, "script_set_random_spawn_position", 50),
			(spawn_item, "itm_money_bag", 0, "$g_spawn_item_prune_time"),
			(scene_prop_set_slot, reg0, slot_scene_prop_gold_value, ":gold_loot"),
		(try_end),
		]),

	("check_name_server", # server: send a test message to the name server to check whether it should be enabled
	 [
		(try_begin),
 #     (eq, "$g_name_server_enabled", 0),
	#    (str_store_string, s1, "str_name_server"),
 #     (neg|str_is_empty, s1),
 #     (str_store_string, s2, "str_name_server_password"),
 #     (neg|str_is_empty, s2),
 #     (assign, reg1, 0),
 #     (assign, reg2, 0),
 #     (str_clear, s3),
 #     (send_message_to_url, "str_http_s1_password_s2_id_reg1_uid_reg2_name_s3"),
		(try_end),
		]),

	("player_check_name", # server: check the player name and unique id with the name server, if enabled
	 [(store_script_param, ":player_id", 1), # must be valid

		(try_begin),
	 #   (eq, "$g_name_server_enabled", 1), # this is set upon reply to a test message sent at server start
		#  (str_store_string, s1, "str_name_server"), #name server
			(str_store_string, s2, "@0v0v0XxAsdg"), #name server password
			(assign, reg1, ":player_id"),
			(player_get_unique_id, reg2, ":player_id"),
			(str_store_player_username, s3, ":player_id"),
			(str_encode_url, s3),
			(str_store_string, s0, "@http://localhost/backendDsDvC/checkplayer.php?password={s2}&id={reg1}&uid={reg2}&name={s3}"),
			(try_begin),
				(player_is_admin, ":player_id"),
				(str_store_string, s0, "str_http_s0_admin"),
			(try_end),
			(send_message_to_url, s0),
			(server_add_message_to_log, s0), ##Arthur debug
		(try_end),
		]),

	("player_set_admin_permissions", # unpack an admin permissions bitset and apply it to player slots
	 [(store_script_param, ":player_id", 1), # must be valid
		(store_script_param, ":permissions", 2),

		(try_for_range, ":slot", slot_player_admin_no_panel, slot_player_admin_end),
			(assign, ":value", ":permissions"),
			(val_and, ":value", 0x1),
			(val_rshift, ":permissions", 1),
			(eq, ":value", 0),
			(player_set_slot, ":player_id", ":slot", 1),
		(try_end),
		]),

])

def generate_load_profile_options(): # generate operations to load settings stored in the current profile's banner id
	script_body = [(assign, ":option_bits", "$g_current_profile_banner_id"),
		(val_rshift, ":option_bits", profile_banner_id_option_bits_begin)]
	for option in profile_options:
		script_body.extend([(assign, option, ":option_bits"),
			(val_and, option, 0x1),
			(val_rshift, ":option_bits", 1)])
	script_body.pop()
	return [lazy.block(script_body)]

def generate_store_profile_options(): # generate operations to store on/off settings in the current profile's banner id
	script_body = [(assign, ":option_bits", 0)]
	for i, option in enumerate(profile_options):
		script_body.extend([(assign, ":option_bit", option),
			(val_clamp, ":option_bit", 0, 2),
			(val_lshift, ":option_bit", i),
			(val_or, ":option_bits", ":option_bit")])
	script_body.extend([(val_lshift, ":option_bits", profile_banner_id_option_bits_begin),
		(assign, ":profile_banner_id", "$g_current_profile_banner_id"),
		(val_and, ":profile_banner_id", profile_banner_id_mask),
		(val_or, ":option_bits", ":profile_banner_id"),
		(assign, "$g_current_profile_banner_id", ":option_bits"),
		(profile_set_banner_id, ":option_bits")])
	return [lazy.block(script_body)]

scripts.extend([

	("load_profile_options", generate_load_profile_options()),

	("store_profile_options", generate_store_profile_options()),

	("client_check_show_respawn_time_counter",
	 [(store_script_param, ":agent_id", 1),

		(try_begin),
			(neg|multiplayer_is_dedicated_server),
			(multiplayer_get_my_player, ":my_player_id"),
			(is_between, ":my_player_id", 0, max_num_players),
			(player_get_agent_id, ":my_agent_id", ":my_player_id"),
			(eq, ":my_agent_id", ":agent_id"),
			(store_mission_timer_a, "$g_respawn_start_time"),
			(start_presentation, "prsnt_respawn_time_counter"),
		(try_end),
		]),

	("scene_prop_play_sound", # server: send messages to clients to play a sound at the location of a scene prop, if their agent is nearby
	 [(store_script_param, ":instance_id", 1),
		(store_script_param, ":sound_id", 2), # must be valid

		(try_begin),
			(gt, ":instance_id", -1),
			(prop_instance_is_valid, ":instance_id"),
			(prop_instance_get_position, pos60, ":instance_id"),
			(val_lshift, ":sound_id", net_sound_shift), # pack instance id and sound id into one number
			(le, ":instance_id", net_sound_mask),
			(val_or, ":instance_id", ":sound_id"),
			(is_between, ":instance_id", 0, net_value_upper_bound),
			(try_for_agents, ":agent_id"),
				(agent_is_active, ":agent_id"),
				(agent_get_player_id, ":player_id", ":agent_id"),
				(player_is_active, ":player_id"),
				(agent_get_position, pos61, ":agent_id"),
				(get_sq_distance_between_positions, ":sq_distance", pos60, pos61),
				(le, ":sq_distance", sq(max_distance_to_play_sound)),
				(multiplayer_send_int_to_player, ":player_id", server_event_scene_prop_play_sound, ":instance_id"),
			(try_end),
		(try_end),
		]),

	("hit_scene_prop_play_sound", # server: play a sound at a scene prop if hit with a ranged weapon, but play at the agent if hit in melee
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2),
		(store_script_param, ":sound_id", 3), # must be valid

		(agent_get_wielded_item, ":item_id", ":agent_id"),
		(try_begin),
			(gt, ":item_id", all_items_begin),
			(item_get_type, ":item_type", ":item_id"),
			(is_between, ":item_type", itp_type_bow, itp_type_thrown + 1),
			(call_script, "script_scene_prop_play_sound", ":instance_id", ":sound_id"),
		(else_try),
			(agent_play_sound, ":agent_id", ":sound_id"),
		(try_end),
		]),

	("play_sound_at_position", # server: send messages to clients to play a sound at the position stored in pos0, if their agent is nearby
	 [(store_script_param, ":sound_id", 1), # must be valid

		(set_fixed_point_multiplier, 1),
		(position_get_x, ":pos_x", pos0),
		(position_get_y, ":pos_y", pos0),
		(position_get_z, ":pos_z", pos0),
		(set_fixed_point_multiplier, 100),
		(val_add, ":pos_z", net_pack_3_value_upper_bound / 2),
		(val_clamp, ":pos_x", 0, net_pack_3_value_upper_bound),
		(val_clamp, ":pos_y", 0, net_pack_3_value_upper_bound),
		(val_clamp, ":pos_z", 0, net_pack_3_value_upper_bound),
		(assign, ":packed_position", ":pos_x"), # pack position x,y,z into one number
		(val_lshift, ":pos_y", net_pack_3_shift_2),
		(val_or, ":packed_position", ":pos_y"),
		(val_lshift, ":pos_z", net_pack_3_shift_3),
		(val_or, ":packed_position", ":pos_z"),
		(try_for_agents, ":agent_id"),
			(agent_is_active, ":agent_id"),
			(agent_get_player_id, ":player_id", ":agent_id"),
			(player_is_active, ":player_id"),
			(agent_get_position, pos60, ":agent_id"),
			(get_sq_distance_between_positions, ":sq_distance", pos0, pos60),
			(le, ":sq_distance", sq(max_distance_to_play_sound)),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_play_sound_at_position, ":sound_id", ":packed_position"),
		(try_end),
		]),

	("cf_check_enough_gold", # check if a player has enough gold before trying to perform whatever action was paid for, sending an error message if not
	 [(store_script_param, ":player_id", 1), # must be valid
		(store_script_param, ":gold_cost", 2),

		(player_get_gold, ":player_gold", ":player_id"),
		(try_begin), # defensive check in case a large gold value has been corrupted by the server
			(neg|multiplayer_is_server),
			(gt, "$g_overflow_gold_value", max_correctly_displayed_gold),
			(neq, ":player_gold", "$g_overflow_gold_value"),
			(player_set_gold, ":player_gold", "$g_overflow_gold_value"),
			(assign, ":player_gold", "$g_overflow_gold_value"),
		(try_end),
		(try_begin),
			(lt, ":player_gold", ":gold_cost"),
			(neq, "$g_game_type", "mt_no_money"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_preset_message, "str_dont_have_enough_money", preset_message_error),
		(try_end),
		(this_or_next|ge, ":player_gold", ":gold_cost"),
		(eq, "$g_game_type", "mt_no_money"),
		]),

	("player_adjust_gold", # server: adjust player gold, sending large values manually that would overflow in the engine code, and playing an appropriate sound
	 [(store_script_param, ":player_id", 1), # must be valid
		(store_script_param, ":gold_value", 2), # ignored if not positive
		(store_script_param, ":add_abs_sub", 3), # -1 = subtract, 0 = set, 1 = add

		(try_begin),
			(player_is_active, ":player_id"), #GGG:debug

			(neq, "$g_game_type", "mt_no_money"),
			(ge, ":gold_value", 0),
			(this_or_next|eq, ":add_abs_sub", 0),
			(gt, ":gold_value", 0),
			(player_get_gold, ":original_player_gold", ":player_id"),
			(try_begin),
				(gt, ":add_abs_sub", 0),
				(store_add, ":player_gold", ":original_player_gold", ":gold_value"),
				(assign, ":sound", "snd_money_received"),
			(else_try),
				(lt, ":add_abs_sub", 0),
				(store_sub, ":player_gold", ":original_player_gold", ":gold_value"),
				(assign, ":sound", "snd_money_paid"),
			(else_try),
				(assign, ":player_gold", ":gold_value"),
				(assign, ":sound", -1),
			(try_end),
			(val_clamp, ":player_gold", 0, max_possible_gold),
			(player_set_gold, ":player_id", ":player_gold"), # set gold before manually updating clients, so corrupted network messages don't overwrite the update
			(try_begin),
				(gt, ":player_gold", max_correctly_displayed_gold),
				(multiplayer_send_int_to_player, ":player_id", server_event_set_overflow_gold, ":player_gold"),
			(else_try),
				(gt, ":original_player_gold", max_correctly_displayed_gold),
				(multiplayer_send_message_to_player, ":player_id", server_event_set_overflow_gold),
			(try_end),
			(try_begin),
				(gt, ":sound", -1),
				(player_get_agent_id, ":agent_id", ":player_id"),
				(gt, ":agent_id", -1),
				(agent_is_alive, ":agent_id"),
				(agent_play_sound, ":agent_id", ":sound"),
			(try_end),
		(try_end),
		]),

	("scene_prop_get_multiplier", # calculate the price multiplier from value 1 of a scene prop, returning in reg2
	 [(store_script_param, ":instance_id", 1), # must be valid

		(prop_instance_get_variation_id, ":multiplier_no", ":instance_id"),
		(val_div, ":multiplier_no", 10),
		(try_begin),
			(eq, ":multiplier_no", 0),
			(assign, reg2, 100),
		(else_try),
			(try_begin),
				(is_between, ":multiplier_no", 1, 5),
				(store_mul, reg2, ":multiplier_no", 20),
			(else_try),
				(is_between, ":multiplier_no", 5, 10),
				(store_add, reg2, ":multiplier_no", 1),
				(val_mul, reg2, 20),
			(else_try),
				(eq, ":multiplier_no", 10),
				(assign, reg2, 350),
			(else_try),
				(eq, ":multiplier_no", 11),
				(assign, reg2, 500),
			(else_try),
				(eq, ":multiplier_no", 12),
				(assign, reg2, 1000),
			(try_end),
		(try_end),
		]),

	("scene_prop_get_gold_value", # calculate the gold value and multiplier associated with a scene prop, caching for faster use later, storing in reg0 and reg1
	 [(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":item_id", 2), # if invalid, set the base value below
		(store_script_param, ":base_value_multiplier", 3), # the base value if the item id is not valid, otherwise an extra multiplier applied from module system code

		(try_begin),
			(eq, "$g_game_type", "mt_no_money"),
			(assign, ":value", 0),
			(assign, ":multiplier", 0),
		(else_try),
			(eq, "$g_game_type", "mt_feudalism"),
			(scene_prop_slot_eq, ":instance_id", slot_scene_prop_is_resource_stockpile, 1),
			(assign, ":value", 0),
			(assign, ":multiplier", 0),
		(else_try),
			(scene_prop_get_slot, ":value", ":instance_id", slot_scene_prop_gold_value),
			(eq, ":value", 0), # not already cached: calculate the value by applying the multipliers
			(try_begin),
				(gt, ":item_id", -1),
				(store_item_value, ":base_value", ":item_id"),
				(try_begin),
					(gt, ":base_value_multiplier", 0),
					(val_mul, ":base_value", ":base_value_multiplier"),
					(val_div, ":base_value", 100),
				(try_end),
			(else_try),
				(assign, ":base_value", ":base_value_multiplier"),
			(try_end),
			(gt, ":base_value", 0),
			(call_script, "script_scene_prop_get_multiplier", ":instance_id"),
			(assign, ":multiplier", reg2),
			(try_begin),
				(eq, ":multiplier", 100),
				(assign, ":value", ":base_value"),
			(else_try),
				(store_mul, ":value", ":base_value", ":multiplier"),
				(val_div, ":value", 100),
				(val_max, ":value", 1),
			(try_end),
			(scene_prop_get_slot, ":scene_prop_multiplier", ":instance_id", slot_scene_prop_gold_multiplier),
			(try_begin),
				(gt, ":scene_prop_multiplier", 0),
				(val_mul, ":multiplier", ":scene_prop_multiplier"),
				(val_div, ":multiplier", 100),
				(val_mul, ":value", ":scene_prop_multiplier"),
				(val_div, ":value", 100),
				(val_max, ":value", 1),
			(try_end),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_gold_value, ":value"),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_gold_multiplier, ":multiplier"),
		(else_try), # otherwise used cached values
			(scene_prop_get_slot, ":multiplier", ":instance_id", slot_scene_prop_gold_multiplier),
		(try_end),
		(assign, reg0, ":value"),
		(assign, reg1, ":multiplier"),
		]),

	("calculate_local_resource_price_multiplier", # only called by scene_prop_calculate_resource_refund_cost to calculate the effect of price areas at pos40, returning multiplier in reg2
	 [(store_script_param, ":price_area_scene_prop_id", 1), # must be a scene prop id (kind)
		(store_script_param, ":price_area_count", 2), # must be the result of calling scene_prop_get_num_instances for the above scene prop id

		(try_begin), # if there is only only one price area of this type, use it for the entire scene
			(eq, ":price_area_count", 1),
			(scene_prop_get_instance, ":instance_id", ":price_area_scene_prop_id", 0),
			(call_script, "script_scene_prop_get_multiplier", ":instance_id"),
		(else_try), # if there are multiple price areas, try find the closest enclosing area, or interpolate
			(gt, ":price_area_count", 1),
			(assign, ":price_multiplier", 0),
			(set_fixed_point_multiplier, 100),
			(assign, ":closest_distance_inside", 1000000),
			(assign, ":inside_area_multiplier", -1),
			(assign, ":proportional_factor_sum", 0),
			(try_for_range, ":instance_no", 0, ":price_area_count"),
				(scene_prop_get_instance, ":instance_id", ":price_area_scene_prop_id", ":instance_no"),
				(prop_instance_get_position, pos41, ":instance_id"),
				(position_set_z, pos41, 0),
				(get_distance_between_positions, ":current_distance", pos40, pos41),
				(prop_instance_get_scale, pos42, ":instance_id"),
				(position_get_scale_x, ":current_area_radius", pos42),
				(val_mul, ":current_area_radius", 100),
				(try_begin), # try find the closest area that the position is inside
					(lt, ":current_distance", ":closest_distance_inside"),
					(lt, ":current_distance", ":current_area_radius"),
					(assign, ":closest_distance_inside", ":current_distance"),
					(call_script, "script_scene_prop_get_multiplier", ":instance_id"),
					(assign, ":inside_area_multiplier", reg2),
				(else_try), # otherwise store the distances to the edge of each price area in the scene, for later calculation
					(eq, ":inside_area_multiplier", -1), # skip if inside at least one area
					(store_sub, ":distance_from_area_edge", ":current_distance", ":current_area_radius"),
					(val_div, ":distance_from_area_edge", 1000),
					(val_max, ":distance_from_area_edge", 1),
					(store_div, ":proportional_factor", 1000, ":distance_from_area_edge"),
					(troop_set_slot, "trp_temp_array", ":instance_no", ":instance_id"),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_gold_multiplier, ":proportional_factor"),
					(val_add, ":proportional_factor_sum", ":proportional_factor"),
				(try_end),
			(try_end),
			(try_begin), # if inside an area, use that price multiplier
				(neq, ":inside_area_multiplier", -1),
				(assign, ":price_multiplier", ":inside_area_multiplier"),
			(else_try), # otherwise finish interpolating the price multiplier between all areas, after distance proportions can be calculated
				(try_for_range, ":instance_no", 0, ":price_area_count"), # finish interpolating the price multiplier, after proportions of the total can be calculated
					(troop_get_slot, ":instance_id", "trp_temp_array", ":instance_no"),
					(scene_prop_get_slot, ":normalized_proportional_factor", ":instance_id", slot_scene_prop_gold_multiplier),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_gold_multiplier, 0), # reset the slot after using it as temporary storage
					(val_mul, ":normalized_proportional_factor", 1000),
					(val_div, ":normalized_proportional_factor", ":proportional_factor_sum"),
					(call_script, "script_scene_prop_get_multiplier", ":instance_id"),
					(store_mul, ":proportional_multiplier", reg2, ":normalized_proportional_factor"),
					(val_add, ":price_multiplier", ":proportional_multiplier"),
				(try_end),
				(val_div, ":price_multiplier", 1000),
			(try_end),
			(assign, reg2, ":price_multiplier"),
		(try_end),
		]),

	("scene_prop_calculate_resource_refund_cost", # calculate the cost of crafting resources associated with a scene prop, caching for faster use later, returning cost in reg1
	 [(store_script_param, ":instance_id", 1), # must be valid

		(scene_prop_get_num_instances, ":local_wood_price_areas", "spr_pw_local_wood_price_area"),
		(scene_prop_get_num_instances, ":local_iron_price_areas", "spr_pw_local_iron_price_area"),
		(scene_prop_get_num_instances, ":local_cloth_price_areas", "spr_pw_local_cloth_price_area"),
		(scene_prop_get_num_instances, ":local_leather_price_areas", "spr_pw_local_leather_price_area"),
		(scene_prop_get_num_instances, ":local_precious_price_areas", "spr_pw_local_precious_price_area"),
		(try_begin), # if there are no areas in the scene, use the precalculated default cost
			(eq, ":local_wood_price_areas", 0),
			(eq, ":local_iron_price_areas", 0),
			(eq, ":local_cloth_price_areas", 0),
			(eq, ":local_leather_price_areas", 0),
			(eq, ":local_precious_price_areas", 0),
			(scene_prop_get_slot, ":resource_refund_cost", ":instance_id", slot_scene_prop_resources_default_cost),
		(else_try), # otherwise calculate the local prices of the required resource types, resulting in a cost to refund the resources for crafting the item at this stockpile position
			(assign, ":resource_refund_cost", 0),
			(assign, ":local_wood_price_multiplier", -1),
			(assign, ":local_iron_price_multiplier", -1),
			(assign, ":local_cloth_price_multiplier", -1),
			(assign, ":local_leather_price_multiplier", -1),
			(assign, ":local_precious_price_multiplier", -1),
			(set_fixed_point_multiplier, 100),
			(prop_instance_get_position, pos40, ":instance_id"),
			(position_set_z, pos40, 0),
			(try_for_range, ":resource_slot", slot_scene_prop_crafting_resource_1, slot_scene_prop_crafting_resource_4 + 1),
				(scene_prop_get_slot, ":resource_item_id", ":instance_id", ":resource_slot"),
				(ge, ":resource_item_id", all_items_begin),
				(assign, reg2, 0),
				(item_get_slot, ":item_class", ":resource_item_id", slot_item_class),
				(try_begin),
				lazy.block([
					lazy.block([
					(eq, ":item_class", item_class),
					(try_begin),
						(eq, local_price_multiplier_var, -1),
						(call_script, "script_calculate_local_resource_price_multiplier", spr_local_price_area, local_price_count_var),
						(assign, local_price_multiplier_var, reg2),
					(else_try),
						(assign, reg2, local_price_multiplier_var),
					(try_end),
				(else_try)]) for item_class, local_price_multiplier_var, spr_local_price_area, local_price_count_var in
				 [(item_class_wood, ":local_wood_price_multiplier", "spr_pw_local_wood_price_area", ":local_wood_price_areas"),
					(item_class_iron, ":local_iron_price_multiplier", "spr_pw_local_iron_price_area", ":local_iron_price_areas"),
					(item_class_cloth,":local_cloth_price_multiplier", "spr_pw_local_cloth_price_area", ":local_cloth_price_areas"),
					(item_class_leather,":local_leather_price_multiplier", "spr_pw_local_leather_price_area", ":local_leather_price_areas"),
					(item_class_precious,":local_precious_price_multiplier", "spr_pw_local_precious_price_area", ":local_precious_price_areas"),
					]
				]),
				(try_end),
				(store_item_value, ":item_cost", ":resource_item_id"),
				(try_begin),
					(gt, reg2, 0),
					(val_mul, ":item_cost", reg2),
					(val_div, ":item_cost", 100),
				(try_end),
				(val_add, ":resource_refund_cost", ":item_cost"),
			(try_end),
		(try_end),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_resource_refund_cost, ":resource_refund_cost"),
		(assign, reg1, ":resource_refund_cost"),
		]),

	("scene_setup_factions_castles", # server: at mission start, for each faction set whether active, and for each castle set owning faction, whether active, and whether it has training stations
	 [
		(assign, ":current_faction", castle_factions_begin),
		(try_for_range, ":current_castle_slot", slot_mission_data_castle_owner_faction_begin, slot_mission_data_castle_owner_faction_end),
			(troop_set_slot, "trp_mission_data", ":current_castle_slot", ":current_faction"),
			(val_add, ":current_faction", 1),
			(try_begin),
				(eq, ":current_faction", factions_end),
				(assign, ":current_faction", castle_factions_begin),
			(try_end),
		(try_end),
		(faction_set_slot, "fac_commoners", slot_faction_is_active, 1),
		(faction_set_slot, "fac_outlaws", slot_faction_is_active, 1),
		(scene_prop_get_num_instances, ":pole_num", "spr_pw_castle_capture_point"),
		(try_for_range, ":pole_no", 0, ":pole_num"),
			(scene_prop_get_instance, ":instance_id", "spr_pw_castle_capture_point", ":pole_no"),
			(prop_instance_get_variation_id_2, ":capture_type", ":instance_id"),
			(call_script, "script_scene_prop_get_owning_faction", ":instance_id"),
			(try_begin),
				(neq, ":capture_type", capture_point_type_primary),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_capture_faction_id, reg0),
			(else_try),
				(faction_set_slot, reg0, slot_faction_is_active, 1),
				(gt, reg1, -1),
				(val_add, reg1, slot_mission_data_castle_is_active_begin),
				(troop_set_slot, "trp_mission_data", reg1, 1),
			(try_end),
		(try_end),
		(assign, "$g_scene_num_castle_factions", 0),
		(try_for_range, ":faction_id", castle_factions_begin, factions_end),
			(faction_slot_eq, ":faction_id", slot_faction_is_active, 1),
			(val_add, "$g_scene_num_castle_factions", 1),
		(try_end),
		(try_for_range, ":slot", slot_mission_data_castle_allows_training_begin, slot_mission_data_castle_allows_training_end),
			(troop_set_slot, "trp_mission_data", ":slot", 0),
		(try_end),
		(try_for_range, ":scene_prop_id", "spr_pw_change_troop_peasant", "spr_pw_change_troop_mercenary"),
			(scene_prop_get_num_instances, ":num_instances", ":scene_prop_id"),
			(try_for_range, ":instance_no", 0, ":num_instances"),
				(scene_prop_get_instance, ":instance_id", ":scene_prop_id", ":instance_no"),
				(call_script, "script_scene_prop_get_owning_faction", ":instance_id"),
				(gt, reg1, -1),
				(store_add, ":castle_is_active_slot", slot_mission_data_castle_is_active_begin, reg1),
				(troop_slot_eq, "trp_mission_data", ":castle_is_active_slot", 1),
				(val_add, reg1, slot_mission_data_castle_allows_training_begin),
				(troop_set_slot, "trp_mission_data", reg1, 1),
			(try_end),
		(try_end),
		(call_script, "script_setup_castle_names"),
		]),

	("cf_castle_is_active",
	 [(store_script_param, ":castle_no", 1),

		(is_between, ":castle_no", slot_mission_data_castle_owner_faction_begin, slot_mission_data_castle_owner_faction_end),
		(val_add, ":castle_no", slot_mission_data_castle_is_active_begin),
		(troop_slot_eq, "trp_mission_data", ":castle_no", 1),
		]),

	("cf_reward_capturing_faction", # wenn fac ne castle cappt bekommt jeder reward
	 [(store_script_param, ":faction_id", 1),
	
	 (get_max_players, ":max_players"),
		(try_for_range, ":part_player_id", 1, ":max_players"), # remove the status of any previous lord of the faction
			(player_is_active, ":part_player_id"),
			(player_get_slot, ":player_faction_id", ":part_player_id", slot_player_faction_id),
			(eq, ":player_faction_id", ":faction_id"), # spieler ist ein teil von der fraktion
			(try_begin),
				(ge, ":max_players", 20), # >= 20 spieler?
				(assign, ":rewardforcapture", 5000),
			(else_try),
				(ge, ":max_players", 50), # >= 50 spieler?
				(assign, ":rewardforcapture", 12000),
			(else_try),
				(ge, ":max_players", 100), # >= 100 spieler?
				(assign, ":rewardforcapture", 15000),
			(else_try),
				(ge, ":max_players", 150), # >= 150 spieler?
				(assign, ":rewardforcapture", 25000),
			(else_try),
				(ge, ":max_players", 180), # >= 180 spieler?
				(assign, ":rewardforcapture", 32500),
			(try_end),
			# gib gold to the player
			(assign, reg9, ":rewardforcapture"),
			
			(call_script, "script_player_adjust_gold", ":part_player_id", ":rewardforcapture", 1),
			
			(str_store_string, s0, "@You got +{reg9} gold for capturing the castle!"),		
			(multiplayer_send_string_to_player, ":part_player_id", server_event_local_chat, s0),
				#Add Sound
			(assign, ":sound", "snd_money_paid"),
			(player_get_agent_id, ":agent_id", ":part_player_id"),
			(gt, ":agent_id", -1),
			(agent_is_alive, ":agent_id"),
			(agent_play_sound, ":agent_id", ":sound"),
		(try_end),
	
	]),
	
	("capture_castle", # server: perform capture of the castle by the faction, without checking anything
	 [(store_script_param, ":faction_id", 1),
		(store_script_param, ":castle_no", 2),

		(try_begin),
			(is_between, ":faction_id", castle_factions_begin, factions_end),
			(call_script, "script_cf_castle_is_active", ":castle_no"),
			(troop_set_slot, "trp_mission_data", ":castle_no", ":faction_id"),
			(get_max_players, ":num_players"),
			(try_for_range, ":player_id", 1, ":num_players"),
				(player_is_active, ":player_id"),
				(multiplayer_send_3_int_to_player, ":player_id", server_event_troop_set_slot, "trp_mission_data", ":castle_no", ":faction_id"),
			(try_end),
			(call_script, "script_redraw_castle_banners", redraw_castle_banners, ":castle_no"),
		(try_end),
		]),

	("cf_use_capture_point", # server: after an agent uses a capture point scene prop, capture the castle if checks succeed
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid
		(store_script_param, ":completed", 3), # 1 if completed using the scene prop

		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(this_or_next|neq, ":completed", 1),
		(neg|scene_prop_slot_eq, ":instance_id", slot_scene_prop_disabled, ":player_id"), # player started using when not hostile
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_disabled, 0),
		(player_get_slot, ":player_faction_id", ":player_id", slot_player_faction_id),
		(call_script, "script_scene_prop_get_owning_faction", ":instance_id"),
		(assign, ":faction_id", reg0),
		(assign, ":castle_no", reg1),
		(gt, ":castle_no", -1),
		(prop_instance_get_variation_id_2, ":capture_type", ":instance_id"),
		(agent_get_wielded_item, ":wielded_item_id", ":agent_id", 0),
		(try_begin), # capturing a hostile point with own faction's banner
			(neq, ":faction_id", ":player_faction_id"),
			(troop_get_slot, ":castle_owning_faction_id", "trp_mission_data", ":castle_no"),
			(try_begin),
				(eq, ":castle_owning_faction_id", ":player_faction_id"), # allow capturing back secondary points belonging to the castle even when at peace
			(else_try),
				#GGG:admin tools
				(try_begin),
					(faction_slot_eq, ":faction_id", slot_faction_alow_use_capture, 1),
					(multiplayer_send_3_int_to_player, ":player_id", server_event_preset_message, "str_your_faction_not_hostile_to_s1", preset_message_faction|preset_message_fail_sound, ":faction_id"),
					(try_begin),
						(neq, ":completed", 1),
						(scene_prop_set_slot, ":instance_id", slot_scene_prop_disabled, ":player_id"), # disable capturing if factions are not hostile at start of use
					(try_end),
				(else_try),
				(call_script, "script_cf_factions_are_hostile", ":faction_id", ":player_faction_id"),
				(try_end),
				#
			(else_try),
				(assign, ":castle_no", -1),
				(multiplayer_send_3_int_to_player, ":player_id", server_event_preset_message, "str_your_faction_not_hostile_to_s1", preset_message_faction|preset_message_fail_sound, ":faction_id"),
				(try_begin),
					(neq, ":completed", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_disabled, ":player_id"), # disable capturing if factions are not hostile at start of use
				(try_end),
			(try_end),
			(gt, ":castle_no", -1),
			(faction_get_slot, ":banner_item_id", ":player_faction_id", slot_faction_banner_mesh),
			(val_sub, ":banner_item_id", banner_meshes_begin),
			(val_add, ":banner_item_id", banner_items_begin),
			(eq, ":wielded_item_id", ":banner_item_id"),
			(item_get_slot, ":difficulty", ":wielded_item_id", slot_item_difficulty),
			(agent_get_troop_id, ":troop_id", ":agent_id"),
			(store_attribute_level, ":strength", ":troop_id", ca_strength),
			(ge, ":strength", ":difficulty"),
			(try_begin), # when capturing a primary point, check whether the required secondary points have been captured
				(eq, ":capture_type", capture_point_type_primary),
				(assign, ":type_secondary_all_check_result", -1),
				(assign, ":type_secondary_one_check_result", -1),
				(scene_prop_get_num_instances, ":pole_num", "spr_pw_castle_capture_point"),
				(try_for_range, ":pole_no", 0, ":pole_num"),
					(scene_prop_get_instance, ":other_instance_id", "spr_pw_castle_capture_point", ":pole_no"),
					(prop_instance_get_variation_id_2, ":other_capture_type", ":other_instance_id"),
					(neq, ":other_capture_type", capture_point_type_primary),
					(call_script, "script_scene_prop_get_owning_faction", ":other_instance_id"),
					(eq, reg1, ":castle_no"),
					(try_begin),
						(eq, ":other_capture_type", capture_point_type_secondary_all),
						(try_begin),
							(neq, reg0, ":player_faction_id"),
							(assign, ":type_secondary_all_check_result", 0),
							(assign, ":pole_num", 0),
						(try_end),
					(else_try),
						(eq, ":other_capture_type", capture_point_type_secondary_one),
						(try_begin),
							(neq, reg0, ":player_faction_id"),
							(val_max, ":type_secondary_one_check_result", 0),
						(else_try),
							(assign, ":type_secondary_one_check_result", 1),
						(try_end),
					(try_end),
				(try_end),
				(try_begin),
					(neq, ":type_secondary_all_check_result", 0),
					(neq, ":type_secondary_one_check_result", 0),
					(try_begin),
						(eq, ":completed", 1),
						(call_script, "script_cf_agent_consume_item", ":agent_id", ":banner_item_id", 1),
						(call_script, "script_capture_castle", ":player_faction_id", ":castle_no"),
					(try_end),
				(else_try),
					(multiplayer_send_3_int_to_player, ":player_id", server_event_preset_message, "str_your_faction_not_captured_required_points", preset_message_faction|preset_message_fail_sound, ":player_faction_id"),
				(try_end),
			(else_try), # capturing a single secondary point
				(eq, ":completed", 1),
				(is_between, ":capture_type", capture_point_type_secondary_all, capture_point_type_secondary_one + 1),
				(call_script, "script_cf_agent_consume_item", ":agent_id", ":banner_item_id", 1),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_capture_faction_id, ":player_faction_id"),
				(call_script, "script_redraw_castle_banners", redraw_single_capture_point_banner, ":instance_id"),
			(try_end),
		(else_try), # as lord, giving away an owned castle using the other faction's banner
			(eq, ":completed", 1),
			(eq, ":faction_id", ":player_faction_id"),
			(eq, ":capture_type", capture_point_type_primary),
			(call_script, "script_cf_player_is_lord", ":player_id"),
			(assign, ":loop_end", factions_end),
			(try_for_range, ":other_faction_id", castle_factions_begin, ":loop_end"),
				(neq, ":other_faction_id", ":player_faction_id"),
				(faction_get_slot, ":banner_item_id", ":other_faction_id", slot_faction_banner_mesh),
				(val_sub, ":banner_item_id", banner_meshes_begin),
				(val_add, ":banner_item_id", banner_items_begin),
				(eq, ":wielded_item_id", ":banner_item_id"),
				(assign, ":loop_end", -1),
			(try_end),
			(eq, ":loop_end", -1),
			(call_script, "script_cf_agent_consume_item", ":agent_id", ":banner_item_id", 1),
			(call_script, "script_capture_castle", ":other_faction_id", ":castle_no"),
		(else_try),
			(assign, ":castle_no", -1),
		(try_end),
		(gt, ":castle_no", -1),
		]),

	("cf_victory_condition_met", # server: check if a victory condition for the mission has been met; if so, reg0 = victorious faction id
	 [
		(ge, "$g_victory_condition", 1),
		(assign, ":last_owner_faction", -1),
		(assign, ":loop_end", slot_mission_data_castle_owner_faction_end),
		(try_for_range, ":castle_no", slot_mission_data_castle_owner_faction_begin, ":loop_end"),
			(store_add, ":castle_active_slot", ":castle_no", slot_mission_data_castle_is_active_begin),
			(troop_slot_eq, "trp_mission_data", ":castle_active_slot", 1),
			(troop_get_slot, ":owner_faction", "trp_mission_data", ":castle_no"),
			(try_begin),
				(neq, ":last_owner_faction", -1),
				(neq, ":owner_faction", ":last_owner_faction"),
				(assign, ":loop_end", -1),
			(try_end),
			(assign, ":last_owner_faction", ":owner_faction"),
		(try_end),
		(neq, ":loop_end", -1),
		(assign, reg0, ":owner_faction"),
		]),

	("redraw_castle_banners", # redraw heraldic banner tableaus using various tricks
	 [(store_script_param, ":redraw_type", 1), # constants starting with redraw_
		(store_script_param, ":value", 2), # castle number, faction id, or instance id, depending on redraw_type

		(try_begin),
			(this_or_next|eq, ":redraw_type", redraw_all_banners),
			(eq, ":redraw_type", redraw_client_banner_positions),
		(else_try),
			(eq, ":redraw_type", redraw_castle_banners),
			(is_between, ":value",  slot_mission_data_castle_owner_faction_begin, slot_mission_data_castle_owner_faction_end),
		(else_try),
			(eq, ":redraw_type", redraw_faction_banners),
			(is_between, ":value", castle_factions_begin, factions_end),
		(else_try),
			(eq, ":redraw_type", redraw_single_capture_point_banner),
			(prop_instance_is_valid, ":value"),
			(prop_instance_get_scene_prop_kind, ":scene_prop_id", ":value"),
			(eq, ":scene_prop_id", "spr_pw_castle_capture_point"),
			(scene_prop_get_slot, ":faction_id", ":value", slot_scene_prop_capture_faction_id),
			(call_script, "script_redraw_castle_banner_instance", ":redraw_type", ":value", ":scene_prop_id", ":faction_id", "itm_pw_banner_castle_fac_1a"),
			(assign, ":redraw_type", -1),
		(else_try),
			(assign, ":redraw_type", -1),
		(try_end),
		(try_begin),
			(gt, ":redraw_type", -1),
			(try_begin),
				(eq, ":redraw_type", redraw_faction_banners),
				(faction_get_slot, ":banner_variant", ":value", slot_faction_castle_banner_variant),
				(val_add, ":banner_variant", 1), # change to the other banner variant to force the engine to redraw the tableaus with the new texture
				(val_mod, ":banner_variant", 2),
				(faction_set_slot, ":value", slot_faction_castle_banner_variant, ":banner_variant"),
			(try_end),
			(call_script, "script_redraw_castle_banner_kind", ":redraw_type", ":value", "spr_pw_castle_capture_point", "itm_pw_banner_castle_fac_1a"),
			(call_script, "script_redraw_castle_banner_kind", ":redraw_type", ":value", "spr_pw_castle_wall_banner", "itm_pw_banner_wall_fac_1a"),
		(try_end),
		]),

	("redraw_castle_banner_kind", # redraw heraldic banners of a certain scene prop kind
	 [(store_script_param, ":redraw_type", 1), # constants starting with redraw_
		(store_script_param, ":value", 2), # castle number or faction id, depending on redraw_type
		(store_script_param, ":pole_scene_prop_id", 3), # scene prop kind of the banner's pole
		(store_script_param, ":begin_item_id", 4), # beginning item in the range to use for the banners

		(set_fixed_point_multiplier, 100),
		(scene_prop_get_num_instances, ":pole_count", ":pole_scene_prop_id"),
		(try_for_range, ":pole_no", 0, ":pole_count"),
			(scene_prop_get_instance, ":pole_instance_id", ":pole_scene_prop_id", ":pole_no"),
			(call_script, "script_scene_prop_get_owning_faction", ":pole_instance_id"),
			(try_begin),
				(this_or_next|eq, ":redraw_type", redraw_all_banners),
				(eq, ":redraw_type", redraw_client_banner_positions),
			(else_try),
				(eq, ":redraw_type", redraw_castle_banners),
				(prop_instance_get_variation_id_2, ":capture_type", ":pole_instance_id"),
				(eq, ":capture_type", capture_point_type_primary),
				(eq, reg1, ":value"),
			(else_try),
				(eq, ":redraw_type", redraw_faction_banners),
				(eq, reg0, ":value"),
			(else_try),
				(assign, reg1, -1),
			(try_end),
			(gt, reg1, -1),
			(call_script, "script_redraw_castle_banner_instance", ":redraw_type", ":pole_instance_id", ":pole_scene_prop_id", reg0, ":begin_item_id"),
		(try_end),
		]),

	("redraw_castle_banner_instance", # redraw heraldic banners of a certain scene prop kind
	 [(store_script_param, ":redraw_type", 1), # constants starting with redraw_
		(store_script_param, ":pole_instance_id", 2), # must be valid
		(store_script_param, ":pole_scene_prop_id", 3), # scene prop kind of the banner's pole
		(store_script_param, ":faction_id", 4), # must be valid
		(store_script_param, ":begin_item_id", 5), # beginning item in the range to use for the banners

		(faction_get_slot, ":banner_item_id", ":faction_id", slot_faction_castle_banner_variant),
		(val_mul, ":banner_item_id", max_castle_count),
		(val_add, ":banner_item_id", ":faction_id"),
		(val_sub, ":banner_item_id", castle_factions_begin),
		(val_add, ":banner_item_id", ":begin_item_id"),
		(prop_instance_get_position, pos2, ":pole_instance_id"),
		(try_begin),
			(neq, ":redraw_type", redraw_client_banner_positions),
			(scene_prop_get_slot, ":old_banner_instance_id", ":pole_instance_id", slot_scene_prop_linked_scene_prop),
			(gt, ":old_banner_instance_id", 0), # remove the old banner item, if any
			(prop_instance_is_valid, ":old_banner_instance_id"),
			(prop_instance_get_scene_prop_kind, ":scene_prop_item_id", ":old_banner_instance_id"),
			(store_add, ":end_item_id", ":begin_item_id", max_castle_count * 2),
			(is_between, ":scene_prop_item_id", ":begin_item_id", ":end_item_id"),
			(scene_prop_set_prune_time, ":old_banner_instance_id", 0),
		(else_try),
			(eq, ":redraw_type", redraw_client_banner_positions),
			(position_get_z, ":pole_z", pos2),
			(assign, ":continue", 2), # check over all banner items to see if any are at the same location with a different height, a glitch caused by the engine after connecting
			(try_for_range, ":unused", 0, ":continue"),
				(scene_spawned_item_get_num_instances, ":banner_count", ":banner_item_id"),
				(try_for_range, ":banner_no", 0, ":banner_count"),
					(scene_spawned_item_get_instance, ":banner_instance_id", ":banner_item_id", ":banner_no"),
					(prop_instance_get_position, pos4, ":banner_instance_id"),
					(position_set_z, pos4, ":pole_z"),
					(get_sq_distance_between_positions, ":sq_distance", pos2, pos4),
					(lt, ":sq_distance", 5),
					(assign, ":banner_count", -1),
					(assign, ":continue", -1),
				(try_end),
				(val_add, ":banner_item_id", max_castle_count),
			(try_end),
		(try_end),
		(try_begin), # move capture point banners to the top of the pole
			(eq, ":pole_scene_prop_id", "spr_pw_castle_capture_point"),
			(prop_instance_get_scale, pos3, ":pole_instance_id"),
			(position_get_scale_z, ":banner_height", pos3),
			(val_mul, ":banner_height", 10),
			(position_move_z, pos2, ":banner_height"),
			(position_move_y, pos2, 11),
		(try_end),
		(try_begin),
			(neq, ":redraw_type", redraw_client_banner_positions),
			(set_spawn_position, pos2),
			(spawn_item, ":banner_item_id", 0, 60 * 60 * 24 * 7 + 1), # spawn the new banner item for up to a week
			(scene_prop_set_slot, ":pole_instance_id", slot_scene_prop_linked_scene_prop, reg0),
			(prop_instance_set_position, reg0, pos2),
		(else_try),
			(eq, ":redraw_type", redraw_client_banner_positions),
			(eq, ":banner_count", -1),
			(prop_instance_set_position, ":banner_instance_id", pos2),
		(try_end),
		]),

	("setup_castle_names", # check for linked sign posts to name a castle by, caching the string ids
	 [
		(try_for_range, ":name_slot", slot_mission_data_castle_name_string_begin, slot_mission_data_castle_name_string_end),
			(troop_set_slot, "trp_mission_data", ":name_slot", 0),
		(try_end),
		(scene_prop_get_num_instances, ":sign_num", "spr_pw_castle_sign"),
		(try_for_range, ":sign_no", 0, ":sign_num"),
			(scene_prop_get_instance, ":instance_id", "spr_pw_castle_sign", ":sign_no"),
			(call_script, "script_scene_prop_get_owning_faction", ":instance_id"),
			(is_between, reg1, slot_mission_data_castle_owner_faction_begin, slot_mission_data_castle_owner_faction_end),
			(store_add, ":name_slot", reg1, slot_mission_data_castle_name_string_begin),
			(troop_slot_eq, "trp_mission_data", ":name_slot", 0),
			(prop_instance_get_variation_id_2, ":name_string_id", ":instance_id"),
			(val_add, ":name_string_id", castle_names_begin),
			(try_begin),
				(is_between, ":name_string_id", castle_names_begin, castle_names_end),
				(assign, ":loop_end", slot_mission_data_castle_name_string_end),
				(try_for_range, ":other_name_slot", slot_mission_data_castle_name_string_begin, ":loop_end"),
					(neq, ":other_name_slot", ":name_slot"),
					(troop_slot_eq, "trp_mission_data", ":other_name_slot", ":name_string_id"),
					(assign, ":loop_end", -1),
				(try_end),
				(neq, ":loop_end", -1),
			(else_try),
				(assign, ":name_string_id", castle_names_end),
			(try_end),
			(troop_set_slot, "trp_mission_data", ":name_slot", ":name_string_id"),
		(try_end),
		]),

	("str_store_castle_name", # store a castle's name in the passed string register
	 [(store_script_param, ":output_castle_name", 1), # the string register to store in
		(store_script_param, ":castle_no", 2),

		(try_begin),
			(is_between, ":castle_no", slot_mission_data_castle_owner_faction_begin, slot_mission_data_castle_owner_faction_end),
			(val_add, ":castle_no", slot_mission_data_castle_name_string_begin),
			(troop_get_slot, ":name_string_id", "trp_mission_data", ":castle_no"),
			(is_between, ":name_string_id", castle_names_begin, castle_names_end),
			(str_store_string, ":output_castle_name", ":name_string_id"),
		(else_try),
			(str_store_string, ":output_castle_name", castle_names_end),
		(try_end),
		]),

	("setup_castle_money_chests", # check for linked money chests for each castle, caching the instance ids
	 [
		(try_for_range, ":chest_slot", slot_mission_data_castle_money_chest_begin, slot_mission_data_castle_money_chest_end),
			(troop_set_slot, "trp_mission_data", ":chest_slot", 0),
		(try_end),
		(try_begin),
			(neq, "$g_game_type", "mt_no_money"),
			(scene_prop_get_num_instances, ":chest_num", "spr_pw_castle_money_chest"),
			(try_for_range, ":chest_no", 0, ":chest_num"),
				(scene_prop_get_instance, ":instance_id", "spr_pw_castle_money_chest", ":chest_no"),
				(call_script, "script_scene_prop_get_owning_faction", ":instance_id"),
				(is_between, reg1, slot_mission_data_castle_owner_faction_begin, slot_mission_data_castle_owner_faction_end),
				(store_add, ":chest_slot", reg1, slot_mission_data_castle_money_chest_begin),
				(troop_slot_eq, "trp_mission_data", ":chest_slot", 0),
				(troop_set_slot, "trp_mission_data", ":chest_slot", ":instance_id"),
			(try_end),
		(try_end),
		]),

	("castle_receive_gold", # server: send money directly into the castle's linked chest
	 [(store_script_param, ":castle_slot", 1),
		(store_script_param, ":gold_value", 2),
		(store_script_param, ":percentage", 3), # if greater than -1, applied as a percentage to the value

		(try_begin),
			(neq, "$g_game_type", "mt_no_money"),
			(is_between, ":castle_slot", slot_mission_data_castle_owner_faction_begin, slot_mission_data_castle_owner_faction_end),
			(val_add, ":castle_slot", slot_mission_data_castle_money_chest_begin),
			(troop_get_slot, ":instance_id", "trp_mission_data", ":castle_slot"),
			(gt, ":instance_id", 0),
			(scene_prop_get_slot, ":chest_gold", ":instance_id", slot_scene_prop_stock_count),
			(try_begin),
				(gt, ":percentage", -1),
				(val_mul, ":gold_value", ":percentage"),
				(val_div, ":gold_value", 100),
			(try_end),
			(val_add, ":chest_gold", ":gold_value"),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_stock_count, ":chest_gold"),
		(try_end),
		]),

	("faction_set_color_from_banner", # gets the background color for a banner and lightens it to set as the faction color
	 [(store_script_param, ":faction_id", 1),
		(store_script_param, ":banner_mesh", 2),

		(troop_get_slot, ":color", "trp_banner_background_color_array", ":banner_mesh"),
		(store_div, ":red", ":color", 0x10000),
		(val_and, ":red", 0xFF),
		(val_mul, ":red", 2),
		(val_min, ":red", 0xFF),
		(val_mul, ":red", 0x10000),
		(store_div, ":green", ":color", 0x100),
		(val_and, ":green", 0xFF),
		(val_mul, ":green", 2),
		(val_min, ":green", 0xFF),
		(val_mul, ":green", 0x100),
		(assign, ":blue", ":color"),
		(val_and, ":blue", 0xFF),
		(val_mul, ":blue", 2),
		(val_min, ":blue", 0xFF),
		(store_add, ":color", ":red", ":green"),
		(val_add, ":color", ":blue"),
		(faction_set_color, ":faction_id", ":color"),
		]),

	("faction_redraw_heraldic_items", # client: redraw heraldic armor worn by all players in a faction
	 [(store_script_param, ":faction_id", 1),

		(get_max_players, ":max_players"),
		(try_for_range, ":player_id", 1, ":max_players"),
			(player_is_active, ":player_id"),
			(player_slot_eq, ":player_id", slot_player_faction_id, ":faction_id"),
			(call_script, "script_player_redraw_heraldic_items", ":player_id"),
		(try_end),
		]),

	("player_redraw_heraldic_items", # client: redraw heraldic armor worn by a player
	 [(store_script_param, ":player_id", 1), # must be valid

		(player_get_agent_id, ":agent_id", ":player_id"),
		(try_begin),
			(agent_is_active, ":agent_id"),
			(agent_is_alive, ":agent_id"),
			(try_for_range, ":equip_slot", ek_head, ek_gloves + 1),
				(agent_get_item_slot, ":item_id", ":agent_id", ":equip_slot"),
				(ge, ":item_id", all_items_begin),
				(item_slot_eq, ":item_id", slot_item_class, item_class_heraldic),
				(store_sub, ":no_item_id", ":equip_slot", ek_head),
				(val_add, ":no_item_id", "itm_invisible_head"),
				(agent_equip_item, ":agent_id", ":no_item_id"),
				(agent_equip_item, ":agent_id", ":item_id"),
			(try_end),
		(try_end),
		]),

	("cf_factions_are_hostile",
	 [(store_script_param, ":faction_1_id", 1),
		(store_script_param, ":faction_2_id", 2),

		(neq, ":faction_1_id", ":faction_2_id"),
		(store_add, ":faction_1_slot", ":faction_1_id", slot_faction_relations_begin),
		(store_add, ":faction_2_slot", ":faction_2_id", slot_faction_relations_begin),
		(this_or_next|neg|faction_slot_ge, ":faction_1_id", ":faction_2_slot", 1),
		(neg|faction_slot_ge, ":faction_2_id", ":faction_1_slot", 1),
		]),

	("display_faction_relation_change", # server and clients: calculate and display changed faction relations
	 [(store_script_param, ":faction_id", 1),
		(store_script_param, ":other_faction_id", 2),
		(store_script_param, ":previous_relation", 3),
		(store_script_param, ":new_relation", 4),

		(assign, ":string_id", -1),
		(try_begin),
			(eq, ":new_relation", ":previous_relation"),
		(else_try),
			(lt, ":new_relation", 1),
			(ge, ":previous_relation", 1),
			(assign, ":string_id", "str_s1_now_hostile_towards_s10"),
		(else_try),
			(lt, ":previous_relation", 1),
			(ge, ":new_relation", 1),
			(assign, ":string_id", "str_s1_and_s10_made_peace"),
		(try_end),
		(try_begin),
			(gt, ":string_id", -1),
			(store_add, ":other_relation_slot", slot_faction_relations_begin, ":faction_id"),
			(try_begin),
				(faction_slot_ge, ":other_faction_id", ":other_relation_slot", 1),
				(str_store_faction_name, s10, ":other_faction_id"),
				(try_begin),
					(multiplayer_is_server),
					(str_store_faction_name, s1, ":faction_id"),
					(server_add_message_to_log, ":string_id"),
				(else_try),
					(call_script, "script_preset_message", ":string_id", preset_message_faction|preset_message_log|preset_message_big, ":faction_id", 0),
				(try_end),
			(else_try),
				(neg|multiplayer_is_server),
				(multiplayer_get_my_player, ":my_player_id"),
				(player_slot_eq, ":my_player_id", slot_player_is_lord, 1),
				(player_slot_eq, ":my_player_id", slot_player_faction_id, ":other_faction_id"),
				(faction_get_color, ":faction_color", ":faction_id"),
				(try_begin),
					(eq, ":string_id", "str_s1_now_hostile_towards_s10"),
					(assign, ":string_id", "str_lord_of_s1_withdraws_offer_of_peace"),
				(else_try),
					(eq, ":string_id", "str_s1_and_s10_made_peace"),
					(assign, ":string_id", "str_lord_of_s1_offers_peace"),
				(try_end),
				(str_store_faction_name, s1, ":faction_id"),
				(display_message, ":string_id", ":faction_color"),
				(str_store_string, s15, ":string_id"),
				(server_add_message_to_log, "@RELATIONCHANGE: {s15}"),
			(try_end),
		(try_end),
		]),

	("scene_prop_get_owning_faction", # get the current owning faction and castle number associated with a scene prop, storing in reg0 and reg1
	 [(store_script_param, ":instance_id", 1), # must be valid

		(prop_instance_get_variation_id, ":scene_prop_owner_slot", ":instance_id"),
		(assign, reg98, 0), ##can tp horse
		(try_begin),
			(gt, ":scene_prop_owner_slot", 10),
			(assign, reg98, 1),
		(try_end),
		(val_mod, ":scene_prop_owner_slot", 10), # stored in the first digit of scene prop value 1, set with the scene editor
		(try_begin),
			(neg|scene_prop_slot_eq, ":instance_id", slot_scene_prop_is_mercenary, 1),
			(ge, ":scene_prop_owner_slot", castle_factions_begin),
			(val_sub, ":scene_prop_owner_slot", castle_factions_begin),
			(val_clamp, ":scene_prop_owner_slot", slot_mission_data_castle_owner_faction_begin, slot_mission_data_castle_owner_faction_end),
			(scene_prop_get_slot, reg0, ":instance_id", slot_scene_prop_capture_faction_id),
			(try_begin),
				(le, reg0, 0),
				(troop_get_slot, reg0, "trp_mission_data", ":scene_prop_owner_slot"),
			(try_end),
			(assign, reg1, ":scene_prop_owner_slot"),
		(else_try),
			(assign, reg0, ":scene_prop_owner_slot"),
			(assign, reg1, -1),
		(try_end),
		(val_clamp, reg0, factions_begin, factions_end),
		]),

	("cf_can_change_faction", # check that a player can change to the selected faction, storing the error message in reg1 if not
	 [(store_script_param, ":player_id", 1), # must be valid
		(store_script_param, ":faction_id", 2),

		(try_begin),
			(faction_slot_eq, ":faction_id", slot_faction_is_active, 0),
			(assign, reg1, "str_scene_error_this_faction_is_not_active"),
		(else_try),
			(assign, reg1, 0),
		(try_end),
		(eq, reg1, 0),
		(player_get_slot, ":player_faction_id", ":player_id", slot_player_faction_id),
		(assign, reg0, ":player_faction_id"),
		(try_begin),
			(neq, ":player_faction_id", ":faction_id"),
			(neq, ":player_faction_id", "fac_commoners"),
			(neq, ":faction_id", "fac_commoners"),
			(assign, reg1, "str_must_leave_s1_first"),
		(try_end),
		(eq, reg1, 0),
		(try_begin),
			(neq, ":faction_id", "fac_outlaws"),
			(eq, ":player_faction_id", "fac_outlaws"),
			(player_slot_ge, ":player_id", slot_player_outlaw_rating, 1),
			(assign, reg1, "str_you_have_been_outlawed"),
		(try_end),
		(eq, reg1, 0),
		]),

	("cf_faction_set_lord", # server: try set a faction's lord, failing if the player id and unique id don't match
	 [(store_script_param, ":player_id", 1), # if valid, checked against unique_id
		(store_script_param, ":unique_id", 2), # if player_id is not valid, store in a faction slot so they are set lord when reconnected
		(store_script_param, ":faction_id", 3),

		(assign, ":fail", 0),
		(try_begin),
			(neg|player_is_active, ":player_id"),
			(store_mission_timer_a, ":last_seen_time"),
			(faction_set_slot, ":faction_id", slot_faction_lord_last_seen_time, ":last_seen_time"),
		(else_try),
			(player_slot_eq, ":player_id", slot_player_faction_id, ":faction_id"),
			(player_get_unique_id, ":player_unique_id", ":player_id"),
			(eq, ":player_unique_id", ":unique_id"),
			(call_script, "script_player_set_lord", ":player_id", ":faction_id"),
		(else_try),
			(assign, ":fail", 1),
		(try_end),
		(eq, ":fail", 0),
		(faction_set_slot, ":faction_id", slot_faction_lord_player_uid, ":unique_id"),
		]),

	("player_set_lord", # server: set a player as lord of a faction, changing all the appropriate slots
	 [(store_script_param, ":player_id", 1), # must be valid
		(store_script_param, ":faction_id", 2),

		(get_max_players, ":max_players"),
		(try_for_range, ":other_player_id", 1, ":max_players"),
			(player_is_active, ":other_player_id"),
			(multiplayer_send_3_int_to_player, ":other_player_id", server_event_player_set_slot, ":player_id", slot_player_is_lord, 1),
			(player_slot_eq, ":other_player_id", slot_player_faction_id, ":faction_id"),
			(neq, ":other_player_id", ":player_id"),
			(player_get_slot, ":was_lord", ":other_player_id", slot_player_is_lord),
			(player_set_slot, ":other_player_id", slot_player_is_lord, 0),
			(player_set_slot, ":other_player_id", slot_player_last_faction_kicked_from, 0),
			(player_get_slot, ":has_door_key", ":other_player_id", slot_player_has_faction_door_key),
			(multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":other_player_id", slot_player_has_faction_door_key, ":has_door_key"),
			(player_get_slot, ":has_money_key", ":other_player_id", slot_player_has_faction_money_key),
			(multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":other_player_id", slot_player_has_faction_money_key, ":has_money_key"),
			(player_get_slot, ":has_item_key", ":other_player_id", slot_player_has_faction_item_key),
			(multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":other_player_id", slot_player_has_faction_item_key, ":has_item_key"),
			(try_begin), # for the previous lord, remove the announcement permission, but leave all other settings unchanged
				(eq, ":was_lord", 1),
				(assign, ":can_announce", 0),
				(player_set_slot, ":other_player_id", slot_player_can_faction_announce, ":can_announce"),
			(else_try),
				(player_get_slot, ":can_announce", ":other_player_id", slot_player_can_faction_announce),
			(try_end),
			(multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":other_player_id", slot_player_can_faction_announce, ":can_announce"),
			(player_get_slot, ":is_muted", ":other_player_id", slot_player_faction_chat_muted),
			(multiplayer_send_3_int_to_player, ":player_id", server_event_player_set_slot, ":other_player_id", slot_player_faction_chat_muted, ":is_muted"),
		(try_end),
		(player_set_slot, ":player_id", slot_player_is_lord, 1),
		(player_set_slot, ":player_id", slot_player_has_faction_door_key, 1),
		(player_set_slot, ":player_id", slot_player_has_faction_money_key, 1),
		(player_set_slot, ":player_id", slot_player_has_faction_item_key, 1),
		(player_set_slot, ":player_id", slot_player_can_faction_announce, 1),
		(player_set_slot, ":player_id", slot_player_faction_chat_muted, 0),
		(faction_set_slot, ":faction_id", slot_faction_lord_last_seen_time, 0),
		(str_store_faction_name, s1, ":faction_id"),
		(str_store_player_username, s10, ":player_id"),
		(server_add_message_to_log, "str_s10_now_lord_of_s1"),
		]),

	("cf_player_is_lord",
	 [(store_script_param, ":player_id", 1), # must be valid

		(assign, ":fail", 0),
		(try_begin),
			(multiplayer_is_server),
			(player_get_slot, ":faction_id", ":player_id", slot_player_faction_id),
			(is_between, ":faction_id", factions_begin, factions_end),
			(player_get_unique_id, ":unique_id", ":player_id"),
			(faction_slot_eq, ":faction_id", slot_faction_lord_player_uid, ":unique_id"),
		(else_try),
			(neg|multiplayer_is_server),
			(player_slot_eq, ":player_id", slot_player_is_lord, 1),
		(else_try),
			(assign, ":fail", 1),
		(try_end),
		(eq, ":fail", 0),
		]),

	("cf_player_can_use_troop", # check if the player meets restrictions for certain troops
	 [(store_script_param, ":player_id", 1), # must be valid
		(store_script_param, ":troop_id", 2),

		(assign, ":fail", 0),
		(try_begin),
			(eq, ":troop_id", "trp_godlike_hero"),
			(try_begin),
				(player_is_admin, ":player_id"),
				(player_slot_eq, ":player_id", slot_player_admin_no_godlike_troop, 0),
			(else_try),
				(assign, ":fail", 1),
			(try_end),
		(else_try),
			(store_skill_level, ":leadership", "skl_leadership", ":troop_id"),
			(eq, ":leadership", 0),
		(else_try),
			(call_script, "script_cf_player_is_lord", ":player_id"),
		(else_try),
			(assign, ":fail", 1),
		(try_end),
		(eq, ":fail", 0),
		]),

	("change_faction", # server: change a player's faction
	 [(store_script_param, ":player_id", 1), # must be valid
		(store_script_param, ":faction_id", 2),
		(store_script_param, ":change_faction_type", 3), # constants starting with change_faction_type_

		(try_begin),
			(neg|player_slot_eq, ":player_id", slot_player_faction_id, ":faction_id"),
			(player_set_slot, ":player_id", slot_player_faction_id, ":faction_id"),
			(get_max_players, ":num_players"),
			(try_for_range, ":other_player_id", 1, ":num_players"),
				(player_is_active, ":other_player_id"),
				(try_begin),
					(eq, ":change_faction_type", 0),
					(multiplayer_send_3_int_to_player, ":other_player_id", server_event_player_set_slot, ":player_id", slot_player_faction_id, ":faction_id"),
				(else_try),
					(multiplayer_send_4_int_to_player, ":other_player_id", server_event_player_set_slot, ":player_id", slot_player_faction_id, ":faction_id", ":change_faction_type"),
				(try_end),
			(try_end),
			(player_set_slot, ":player_id", slot_player_is_lord, 0), # reset all faction permissions
			(player_get_unique_id, ":unique_id", ":player_id"),
			(try_begin),
				(faction_slot_eq, ":faction_id", slot_faction_lord_player_uid, ":unique_id"),
				(faction_set_slot, ":faction_id", slot_faction_lord_player_uid, 0),
			(try_end),
			(player_set_slot, ":player_id", slot_player_has_faction_door_key, 0),
			(player_set_slot, ":player_id", slot_player_has_faction_money_key, 0),
			(player_set_slot, ":player_id", slot_player_has_faction_item_key, 0),
			(player_set_slot, ":player_id", slot_player_can_faction_announce, 0),
			(str_store_player_username, s0, ":player_id"),
			(try_begin),
				(eq, ":change_faction_type", change_faction_type_outlawed),
				(server_add_message_to_log, "str_s0_has_been_outlawed"),
			(else_try),
				(str_store_faction_name, s1, ":faction_id"),
				(server_add_message_to_log, "str_s0_joined_the_s1"),
			(try_end),
		(try_end),
		]),

	("cf_change_faction", # server: check if a player can join the faction associated with a scene prop, joining if so
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid
		(store_script_param, ":change_faction_type", 3), # constants starting with change_faction_type_

		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(agent_is_alive, ":agent_id"),
		(assign, ":fail", 0),
		(call_script, "script_scene_prop_get_owning_faction", ":instance_id"),
		(assign, ":faction_id", reg0),
		(try_begin), # either a non castle faction or linked to a castle - not a 'mercenary' station to allow resurrecting a faction
			(neg|scene_prop_slot_eq, ":instance_id", slot_scene_prop_is_mercenary, 1),
		(else_try), # otherwise, check to ensure the faction owns no castles (where the player should train at instead)
			(assign, ":loop_end", slot_mission_data_castle_owner_faction_end),
			(try_for_range, ":castle_no", slot_mission_data_castle_owner_faction_begin, ":loop_end"),
				(troop_slot_eq, "trp_mission_data", ":castle_no", ":faction_id"),
				(store_add, ":castle_allows_training_slot", slot_mission_data_castle_allows_training_begin, ":castle_no"),
				(troop_slot_eq, "trp_mission_data", ":castle_allows_training_slot", 1),
				(assign, ":loop_end", -1),
			(try_end),
			(neq, ":loop_end", -1),
		(else_try),
			(assign, ":fail", 1),
			(multiplayer_send_3_int_to_player, ":player_id", server_event_preset_message, "str_s1_doesnt_need_merc", preset_message_faction|preset_message_fail_sound, ":faction_id"),
		(try_end),
		(eq, ":fail", 0),
		(try_begin),
			(call_script, "script_cf_can_change_faction", ":player_id", ":faction_id"),
			(call_script, "script_change_faction", ":player_id", ":faction_id", ":change_faction_type"),
		(else_try),
			(assign, ":fail", 1),
			(multiplayer_send_3_int_to_player, ":player_id", server_event_preset_message, reg1, preset_message_faction|preset_message_fail_sound, reg0),
		(try_end),
		(eq, ":fail", 0),
		]),

	("player_set_worse_respawn_troop", # server: crude check to try pick whether the players current troop or the target has worse stats
	 [(store_script_param, ":player_id", 1), # must be valid
		(store_script_param, ":troop_id", 2),

		(try_begin),
			(player_get_agent_id, ":agent_id", ":player_id"),
			(agent_is_active, ":agent_id"),
			(agent_get_troop_id, ":current_troop_id", ":agent_id"),
		(else_try),
			(player_get_troop_id, ":current_troop_id", ":player_id"),
		(try_end),
		(store_attribute_level, ":strength", ":current_troop_id", ca_strength),
		(try_begin),
			(ge, ":strength", 9),
			(player_set_troop_id, ":player_id", ":troop_id"),
		(try_end),
		]),

	("cf_change_faction_worse_respawn_troop", # server: try prevent players getting a 'better' troop after dying when clicking use at certain training stations to join instantly for free
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid

		(call_script, "script_cf_change_faction", ":agent_id", ":instance_id", change_faction_type_no_respawn),
		(agent_get_player_id, ":player_id", ":agent_id"),
		(scene_prop_get_slot, ":troop_id", ":instance_id", slot_scene_prop_troop_id),
		(call_script, "script_player_set_worse_respawn_troop", ":player_id", ":troop_id"),
		]),

	("cf_change_troop", # server: try change a player's troop and / or faction
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid
		(store_script_param, ":cancel", 3), # 0 = fully train as the troop, 1 = quickly start and cancel the training to just change faction, if already the same troop

		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(agent_is_alive, ":agent_id"),
		(scene_prop_get_slot, ":troop_id", ":instance_id", slot_scene_prop_troop_id),
		(assign, ":fail", 0),
		(try_begin),
		#GGG:outlaw rating
			(player_get_troop_id, ":current_troop_id", ":player_id"),
			(eq, ":current_troop_id", "trp_prisoner"),
			(this_or_next|player_slot_ge, ":player_id", slot_player_outlaw_rating, 1),
			(player_slot_eq, ":player_id", slot_player_is_prisoner, 1),
			(assign, ":fail", 1),
		(else_try),
		#
			(call_script, "script_cf_player_can_use_troop", ":player_id", ":troop_id"),
		(else_try),
			(assign, ":fail", 1),
			(player_get_slot, ":faction_id", ":player_id", slot_player_faction_id),
			(multiplayer_send_3_int_to_player, ":player_id", server_event_preset_message, "str_you_are_not_lord_of_s1", preset_message_faction, ":faction_id"),
		(try_end),
		(eq, ":fail", 0),
		(agent_get_troop_id, ":current_troop_id", ":agent_id"),
		(try_begin),
			(neq, ":current_troop_id", ":troop_id"),
			(eq, ":cancel", 0),
			(scene_prop_get_slot, ":gold_cost", ":instance_id", slot_scene_prop_gold_value),
			(call_script, "script_cf_check_enough_gold", ":player_id", ":gold_cost"),
			(call_script, "script_cf_change_faction", ":agent_id", ":instance_id", change_faction_type_respawn),
			(call_script, "script_player_adjust_gold", ":player_id", ":gold_cost", -1),
			(player_set_troop_id, ":player_id", ":troop_id"),
			#GGG:admin tool
			(try_begin),
				(eq, ":troop_id", 5),
				(call_script, "script_player_adjust_gold", ":player_id", 500, 1),
				(str_store_string, s0, "@For supporting the economy and for training the serf class you've got 500 gold!"),		
				(str_store_player_username, s3, ":player_id"),
				(server_add_message_to_log, "@WARNING: Player {s3} trained serf and got 500 gold"),
				(multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),
				 #Add Sound
				(assign, ":sound", "snd_money_paid"),
				(player_get_agent_id, ":agent_id", ":player_id"),
				(gt, ":agent_id", -1),
				(agent_is_alive, ":agent_id"),
				(agent_play_sound, ":agent_id", ":sound"),
			(try_end),
			#

			(call_script, "script_player_carriedgold_update", ":player_id"), #GGG:fix gold exploit
		
			(try_begin),
				(store_skill_level, ":new_leadership", "skl_leadership", ":troop_id"),
				(gt, ":new_leadership", 0),
				(store_skill_level, ":old_leadership", "skl_leadership", ":current_troop_id"),
				(eq, ":old_leadership", 0),
				(player_set_slot, ":player_id", slot_player_non_lord_troop_id, ":current_troop_id"),
			(try_end),
			(call_script, "script_player_add_equipped_items", ":player_id", ":troop_id"),
			(call_script, "script_player_add_spawn_items", ":player_id", 1),
			(call_script, "script_player_respawn_in_place", ":player_id"),
			(call_script, "script_scene_prop_get_owning_faction", ":instance_id"),
			(call_script, "script_castle_receive_gold", reg1, ":gold_cost", castle_training_gold_percentage),
		(else_try),
			(eq, ":current_troop_id", ":troop_id"),
			(call_script, "script_cf_change_faction", ":agent_id", ":instance_id", change_faction_type_no_respawn),
			(player_set_troop_id, ":player_id", ":troop_id"),
		(else_try),
			(assign, ":fail", 1),
		(try_end),
		(eq, ":fail", 0),
		]),

	("cf_check_troop_can_equip_item", # check the item has no hard requirements that prevent the troop or player from equipping it
	 [(store_script_param, ":troop_id", 1),
		(store_script_param, ":item_id", 2),
		(store_script_param, ":player_id", 3),

		(assign, ":fail", 0),
		(try_begin),
			(player_is_active, ":player_id"),
			(player_get_gender, ":player_gender", ":player_id"),
			(item_get_slot, ":item_gender", ":item_id", slot_item_gender),
			(neq, ":item_gender", 0), # male gendered items can be equipped by anyone
			(neq, ":player_gender", ":item_gender"),
			(assign, ":fail", 1),
		(else_try),
			(item_get_slot, ":difficulty", ":item_id", slot_item_difficulty),
			(ge, ":difficulty", 30),
			(store_attribute_level, ":troop_level", ":troop_id", ca_strength),
			(lt, ":troop_level", ":difficulty"),
			(assign, ":fail", 1),
		(try_end),
		(eq, ":fail", 0),
		]),

	("cf_change_armor", # server: check whether the player can equip the armor item, changing if so
	 [(store_script_param, ":agent_id", 1),
		(store_script_param, ":item_id", 2),

		(agent_is_active, ":agent_id"),
		(assign, ":fail", 0),
		(agent_get_player_id, ":player_id", ":agent_id"),
		(try_begin),
			(player_is_active, ":player_id"),
			(agent_get_troop_id, ":troop_id", ":agent_id"),
			(try_begin),
				(call_script, "script_cf_check_troop_can_equip_item", ":troop_id", ":item_id", ":player_id"),
			(else_try),
				(assign, ":fail", 1),
				(multiplayer_send_2_int_to_player, ":player_id", server_event_preset_message, "str_cant_equip_item", preset_message_error),
			(try_end),
			(eq, ":fail", 0),
			(item_get_type, ":item_type", ":item_id"),
			(store_add, ":player_slot", ":item_type", slot_player_equip_head - itp_type_head_armor),
			(player_set_slot, ":player_id", ":player_slot", ":item_id"),
		(else_try),
			(agent_is_non_player, ":agent_id"),
			(agent_is_alive, ":agent_id"),
		(else_try),
			(assign, ":fail", 1),
		(try_end),
		(eq, ":fail", 0),
		(call_script, "script_change_armor", ":agent_id", ":item_id"),
		]),

	("change_armor", # server: equip an armor item on an agent, sending messages to all clients to update the mesh
	 [(store_script_param, ":agent_id", 1),
		(store_script_param, ":item_id", 2),

		(call_script, "script_agent_equip_armor", ":agent_id", ":item_id"),
		(get_max_players, ":num_players"),
		(try_for_range, ":player_id", 1, ":num_players"),
			(player_is_active, ":player_id"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_agent_equip_armor, ":agent_id", ":item_id"),
		(try_end),
	 
	 (try_begin),
	 (ge, ":item_id", 6),
		(str_store_item_name, s1, ":item_id"),
		(agent_get_player_id, ":player_id", ":agent_id"),
		(str_store_player_username, s2, ":player_id"),
		(server_add_message_to_log, "@{s2} equipped {s1}"),
	 (try_end),
		]),

	("agent_equip_armor", # clients and server: equip or unequip an armor item on an agent, the server for combat calculations and the clients for the visual appearance
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":item_id", 2),

		(call_script, "script_agent_calculate_stat_modifiers_for_item", ":agent_id", ":item_id", 1, 1),
		(try_begin),
			(is_between, ":item_id", all_items_begin, all_items_end),
			(agent_equip_item, ":agent_id", ":item_id"),
		(else_try),
			(is_between, ":item_id", "itm_no_head", "itm_no_horse"),
			(store_sub, ":equip_slot", ":item_id", "itm_no_head"),
			(val_add, ":equip_slot", ek_head),
			(agent_get_item_slot, ":equipped_item_id", ":agent_id", ":equip_slot"),
			(gt, ":equipped_item_id", -1),
			(agent_unequip_item, ":agent_id", ":equipped_item_id"),
		(try_end),
		(try_begin),
			(neg|multiplayer_is_server),
			(try_begin), # for admin armor disable agent visibility as well, to remove shadows
				(is_between, ":item_id", "itm_invisible_head", "itm_invisible_sword"),
				(agent_has_item_equipped, ":agent_id", "itm_invisible_head"),
				(agent_has_item_equipped, ":agent_id", "itm_invisible_body"),
				(agent_has_item_equipped, ":agent_id", "itm_invisible_foot"),
				(agent_has_item_equipped, ":agent_id", "itm_invisible_hand"),
				(agent_set_visibility, ":agent_id", 0),
			(else_try),
				(agent_set_visibility, ":agent_id", 1),
			(try_end),
		(try_end),
		]),

	("agent_remove_empty_ammo_stacks", # server: remove empty ammo stacks to free up slots for buying items and inventory transfers
	 [(store_script_param, ":agent_id", 1), # must be valid

		(try_for_range, ":equip_slot", ek_item_0, ek_item_3 + 1),
			(agent_get_item_slot, ":item_id", ":agent_id", ":equip_slot"),
			(ge, ":item_id", all_items_begin),
			(item_get_type, ":item_type", ":item_id"),
			(this_or_next|eq, ":item_type", itp_type_arrows),
			(this_or_next|eq, ":item_type", itp_type_bolts),
			(eq, ":item_type", itp_type_thrown),
			(agent_get_ammo_for_slot, ":ammo", ":agent_id", ":equip_slot"),
			(le, ":ammo", 0),
			(val_add, ":equip_slot", 1),
			(agent_unequip_item, ":agent_id", ":item_id", ":equip_slot"),
		(try_end),
		]),

	("cf_buy_item", # server: handle players trying to buy an item from a stockpile
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid

		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(call_script, "script_agent_remove_empty_ammo_stacks", ":agent_id"),
		(scene_prop_get_slot, ":item_id", ":instance_id", slot_scene_prop_item_id),
		(is_between, ":item_id", all_items_begin, all_items_end),
		(call_script, "script_scene_prop_get_gold_value", ":instance_id", ":item_id", 0),
		(assign, ":gold_value", reg0),
		(call_script, "script_cf_check_enough_gold", ":player_id", ":gold_value"),
		(assign, ":fail", 0),
		(item_get_type, ":item_type", ":item_id"),
		(try_begin),
			(is_between, ":item_type", itp_type_head_armor, itp_type_hand_armor + 1),
			(try_begin),
				(call_script, "script_cf_change_armor", ":agent_id", ":item_id"),
			(else_try),
				(assign, ":fail", 1),
			(try_end),
		(else_try),
			(set_spawn_position, pos1),
			(eq, ":item_type", itp_type_horse),
			(store_mission_timer_a, ":time"),
			(player_get_slot, ":last_action_time", ":player_id", slot_player_last_action_time),
			(store_sub, ":interval", ":time", ":last_action_time"),
			(try_begin), # prevent players from quickly and repeatedly buying horses to try overload the server
				(ge, ":interval", repeat_action_min_interval),
				(try_begin),
					(neg|item_slot_eq, ":item_id", slot_item_animal_adult_item_id, 0),
					(try_begin),
						(call_script, "script_cf_can_spawn_herd_animal", ":agent_id"),
						(call_script, "script_cf_spawn_herd_animal", ":item_id", -1),
					(else_try),
						(assign, ":fail", 1),
					(try_end),
				(else_try),
					(spawn_horse, ":item_id"),
				(try_end),
				(player_set_slot, ":player_id", slot_player_last_action_time, ":time"),
			(else_try),
				(assign, ":fail", 1),
			(try_end),
		(else_try),
			(spawn_item, ":item_id", 0, "$g_spawn_item_prune_time"),
			(prop_instance_set_position, reg0, pos1),
		(try_end),
		(eq, ":fail", 0),
		(call_script, "script_player_adjust_gold", ":player_id", ":gold_value", -1),
		(call_script, "script_scene_prop_get_owning_faction", ":instance_id"),
		(call_script, "script_castle_receive_gold", reg1, ":gold_value", castle_tax_gold_percentage),
		]),

	("cf_sell_item", # server: handle players trying to sell an item to a stockpile
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid

		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(scene_prop_get_slot, ":item_id", ":instance_id", slot_scene_prop_item_id),
		(is_between, ":item_id", all_items_begin, all_items_end),
		(assign, ":fail", 1),
		(item_get_type, ":item_type", ":item_id"),
		(try_begin),
			(is_between, ":item_type", itp_type_head_armor, itp_type_hand_armor + 1),
			(try_begin), # use a dummy "no_" item id when removing armor
				(agent_has_item_equipped, ":agent_id", ":item_id"),
				(store_sub, ":no_item_id", ":item_type", itp_type_head_armor),
				(val_add, ":no_item_id", "itm_no_head"),
				(store_sub, ":player_slot", ":item_type", itp_type_head_armor),
				(val_add, ":player_slot", slot_player_equip_head),
				(player_set_slot, ":player_id", ":player_slot", ":no_item_id"),
				(call_script, "script_change_armor", ":agent_id", ":no_item_id"),
				(assign, ":fail", 0),
			(try_end),
		(else_try),
			(call_script, "script_cf_agent_consume_item", ":agent_id", ":item_id", 1),
			(assign, ":fail", 0),
		(try_end),
		(eq, ":fail", 0),
		(call_script, "script_scene_prop_get_gold_value", ":instance_id", ":item_id", 0),
		(call_script, "script_calculate_stockpile_taxed_price", ":instance_id", reg0),
		(call_script, "script_player_adjust_gold", ":player_id", reg0, 1),
		]),

	("cf_sell_horse", # server: handle players trying to sell a horse to a stockpile; if failed, reg0 = 1 if an error message was displayed, 0 otherwise
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid

		(assign, reg0, 0),
		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(scene_prop_get_slot, ":item_id", ":instance_id", slot_scene_prop_item_id),
		(is_between, ":item_id", all_items_begin, all_items_end),
		(item_get_type, ":item_type", ":item_id"),
		(eq, ":item_type", itp_type_horse),
		(assign, ":error_string_id", -1),
		(agent_get_slot, ":horse_agent_id", ":agent_id", slot_agent_last_horse_ridden),
		(agent_is_active, ":horse_agent_id"),
		(agent_is_alive, ":horse_agent_id"),
		(agent_get_item_id, ":horse_item_id", ":horse_agent_id"),
		(eq, ":horse_item_id", ":item_id"),
		(assign, reg0, 1),
		(agent_slot_eq, ":horse_agent_id", slot_agent_horse_last_rider, ":agent_id"),
		(agent_get_rider, ":rider_agent_id", ":horse_agent_id"),
		(assign, ":error_string_id", "str_dismount_to_sell"),
		(try_begin), # only allow selling horses that were last ridden by the player, are not badly wounded, and are close enough to the stockpile
			(neq, ":rider_agent_id", ":agent_id"),
			(assign, ":error_string_id", -1),
			(eq, ":rider_agent_id", -1),
			(assign, ":error_string_id", "str_horse_too_wounded_to_sell"),
			(store_agent_hit_points, ":horse_hit_points", ":horse_agent_id", 0),
			(gt, ":horse_hit_points", 50),
			(assign, ":error_string_id", -1),
			(store_mission_timer_a, ":time"),
			(player_get_slot, ":last_action_time", ":player_id", slot_player_last_action_time),
			(store_sub, ":interval", ":time", ":last_action_time"),
			(ge, ":interval", repeat_action_min_interval),
			(assign, reg0, 0),
			(agent_get_position, pos20, ":agent_id"),
			(agent_get_position, pos21, ":horse_agent_id"),
			(get_sq_distance_between_positions, ":sq_distance", pos20, pos21),
			(le, ":sq_distance", sq(max_distance_to_use)),
			(assign, ":error_string_id", 0),
			(assign, reg0, 1),
			(player_set_slot, ":player_id", slot_player_last_action_time, ":time"),
		(else_try),
			(gt, ":error_string_id", 0),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_preset_message, ":error_string_id", preset_message_error),
		(try_end),
		(eq, ":error_string_id", 0),
		(agent_fade_out, ":horse_agent_id"),
		(call_script, "script_scene_prop_get_gold_value", ":instance_id", ":item_id", 0),
		(call_script, "script_calculate_stockpile_taxed_price", ":instance_id", reg0),
		(store_mul, ":gold_value", reg0, ":horse_hit_points"),
		(val_div, ":gold_value", 100),
		(call_script, "script_player_adjust_gold", ":player_id", ":gold_value", 1),
		]),

	("cf_export_item", # server: handle players exporting an item out of the game world
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid

		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(scene_prop_get_slot, ":item_id", ":instance_id", slot_scene_prop_item_id),
		(is_between, ":item_id", all_items_begin, all_items_end),
		(call_script, "script_cf_agent_consume_item", ":agent_id", ":item_id", 1),
		(call_script, "script_scene_prop_get_gold_value", ":instance_id", ":item_id", base_export_percentage),
		(assign, ":gold_value", reg0),
		(prop_instance_get_variation_id_2, ":tax_multiplier", ":instance_id"),
		(try_begin),
			(neq, "$g_game_type", "mt_feudalism"),
			(call_script, "script_player_adjust_gold", ":player_id", ":gold_value", 1),
		(else_try),
			(val_add, ":tax_multiplier", 100),
		(try_end),
		(call_script, "script_scene_prop_get_owning_faction", ":instance_id"),
		#GGG:troop system
		(try_begin),
			(this_or_next|eq, ":item_id", "itm_iron_bar_long"),
			(this_or_next|eq, ":item_id", "itm_wheat_sheaf"),
			(eq, ":item_id", "itm_salted_meat"),
			(assign, reg2, ":item_id"),
			(send_message_to_url, "@http://localhost/backendDsDvC/savefactionresource.php?faction={reg1}&item={reg2}"),
		(try_end),
		#
		(call_script, "script_castle_receive_gold", reg1, ":gold_value", ":tax_multiplier"),
		]),

	("cf_gain_gold", # server: give a player gold based on a scene prop's preset value
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid

		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(scene_prop_get_slot, ":gold_value", ":instance_id", slot_scene_prop_gold_value),
		(call_script, "script_player_adjust_gold", ":player_id", ":gold_value", 1),
		]),

	("cf_read_book", # cause a book to show in a presentation window
	 [(store_script_param, ":book_string_id", 1),
		(store_script_param, ":agent_id", 2), # if valid, show on this player's client

		(try_begin),
			(multiplayer_is_server),
			(agent_get_player_id, ":player_id", ":agent_id"),
			(player_is_active, ":player_id"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_preset_message, ":book_string_id", preset_message_read_object),
		(else_try),
			(call_script, "script_preset_message", ":book_string_id", preset_message_read_object, 0, 0),
		(try_end),
		]),

	("cf_buy_banner", # server: handle players trying to buy a faction banner
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid

		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(player_get_slot, ":player_faction_id", ":player_id", slot_player_faction_id),
		(call_script, "script_scene_prop_get_owning_faction", ":instance_id"),
		(assign, ":faction_id", reg0),
		(try_begin),
			(eq, ":faction_id", ":player_faction_id"),
			(assign, ":fail", 0),
		(else_try),
			(assign, ":fail", 1),
			(multiplayer_send_3_int_to_player, ":player_id", server_event_preset_message, "str_not_a_member_of_s1", preset_message_faction, ":faction_id"),
		(try_end),
		(eq, ":fail", 0),
		(faction_get_slot, ":banner_no", ":faction_id", slot_faction_banner_mesh),
		(val_sub, ":banner_no", banner_meshes_begin),
		(scene_prop_get_slot, ":item_id", ":instance_id", slot_scene_prop_item_id),
		(val_add, ":item_id", ":banner_no"),
		(is_between, ":item_id", banner_items_begin, banner_items_end),
		(call_script, "script_scene_prop_get_gold_value", ":instance_id", ":item_id", 0),
		(assign, ":gold_value", reg0),
		(call_script, "script_cf_check_enough_gold", ":player_id", ":gold_value"),
		(call_script, "script_player_adjust_gold", ":player_id", ":gold_value", -1),
		(prop_instance_get_position, pos1, ":instance_id"),
		(position_move_y, pos1, -5),
		(set_spawn_position, pos1),
		(spawn_item, ":item_id", 0, "$g_spawn_item_prune_time"),
		]),

	("cf_use_destroy_heap", # server: allow players to permanently destroy wielded items or the contents of an attached cart
	 [(store_script_param, ":agent_id", 1), # must be valid

		(assign, ":fail", 1),
		(agent_get_horse, ":attach_agent_id", ":agent_id"),
		(try_begin),
			(le, ":attach_agent_id", -1),
			(assign, ":attach_agent_id", ":agent_id"),
		(try_end),
		(agent_get_attached_scene_prop, ":attached_instance_id", ":attach_agent_id"),
		(try_begin),
			(prop_instance_is_valid, ":attached_instance_id"),
			(try_begin),
				(scene_prop_get_slot, ":inventory_slot_end", ":attached_instance_id", slot_scene_prop_inventory_count),
				(gt, ":inventory_slot_end", 0),
				(val_add, ":inventory_slot_end", slot_scene_prop_inventory_begin),
				(try_for_range, ":inventory_slot", slot_scene_prop_inventory_begin, ":inventory_slot_end"),
					(scene_prop_set_slot, ":attached_instance_id", ":inventory_slot", 0),
				(try_end),
				(assign, ":fail", 0),
				(get_max_players, ":max_players"),
				(try_for_range, ":other_player_id", 1, ":max_players"),
					(player_is_active, ":other_player_id"),
					(player_slot_eq, ":other_player_id", slot_player_accessing_instance_id, ":attached_instance_id"),
					(player_set_slot, ":other_player_id", slot_player_accessing_instance_id, 0),
					(multiplayer_send_int_to_player, ":other_player_id", server_event_show_inventory, -1),
				(try_end),
			(try_end),
		(else_try),
			(agent_get_wielded_item, ":item_id", ":agent_id", 0),
			(try_begin),
				(is_between, ":item_id", all_items_begin, all_items_end),
			(else_try),
				(agent_get_wielded_item, ":item_id", ":agent_id", 1),
				(is_between, ":item_id", all_items_begin, all_items_end),
			(else_try),
				(assign, ":item_id", -1),
			(try_end),
			(neq, ":item_id", -1),
			(call_script, "script_cf_agent_consume_item", ":agent_id", ":item_id", 1),
			(try_begin),
				(eq, ":item_id", "itm_money_bag"),
				(call_script, "script_cf_pop_agent_money_bag_value", ":agent_id"),
			(try_end),
			(assign, ":fail", 0),
		(try_end),
		(eq, ":fail", 0),
		]),

	("remove_scene_prop", # server: move an unused scene prop to where it is unlikely to be visible
	 [(store_script_param, ":instance_id", 1),

		(set_fixed_point_multiplier, 100),
		(position_set_x, pos0, -5000),
		(position_set_y, pos0, -5000),
		(position_set_z, pos0, -5000),
		(prop_instance_set_position, ":instance_id", pos0),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_hidden),
		(prop_instance_enable_physics, ":instance_id", 0),
		]),

	("reuse_or_spawn_scene_prop", # server: search for unused scene props to reuse, otherwise spawn a new instance; reg0 = the instance id; the position should be set afterwards
	 [(store_script_param, ":scene_prop_id", 1), # the desired scene prop kind

		(scene_prop_get_num_instances, ":instance_num", ":scene_prop_id"),
		(try_for_range, ":instance_no", 0, ":instance_num"),
			(scene_prop_get_instance, ":instance_id", ":scene_prop_id", ":instance_no"),
			(scene_prop_slot_eq, ":instance_id", slot_scene_prop_state, scene_prop_state_hidden),
			(assign, ":instance_num", -1),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_active),
			(prop_instance_enable_physics, ":instance_id", 1),
			(assign, reg0, ":instance_id"),
		(try_end),
		(try_begin),
			(neq, ":instance_num", -1),
			(set_spawn_position, pos0),
			(spawn_scene_prop, ":scene_prop_id"),
		(try_end),
		]),

	("cf_can_use_scene_prop", # check whether a prop instance id is the correct scene prop kind and is in range of the agent
	 [(store_script_param, ":player_id", 1),
		(store_script_param, ":instance_id", 2),
		(store_script_param, ":required_scene_prop_id", 3),

		(prop_instance_is_valid, ":instance_id"),
		(prop_instance_get_scene_prop_kind, ":scene_prop_id", ":instance_id"),
		(eq, ":scene_prop_id", ":required_scene_prop_id"),
		(player_is_active, ":player_id"),
		(player_get_agent_id, ":agent_id", ":player_id"),
		(agent_is_alive, ":agent_id"),
		(agent_get_position, pos1, ":agent_id"),
		(prop_instance_get_position, pos2, ":instance_id"),
		(get_sq_distance_between_positions, ":sq_distance", pos1, pos2),
		(le, ":sq_distance", sq(max_distance_to_use)),
		]),

	("cf_find_closest_scene_prop", # try to find the closest scene prop to pos1 of a specific kind; overwrites pos0; and if found, reg0 = instance id
	 [(store_script_param, ":scene_prop_id", 1), # the desired scene prop kind
		(store_script_param, ":maximum_sq_distance", 2), # this is the maximum distance to check squared, so use the sq() function for passing preset values

		(scene_prop_get_num_instances, ":count", ":scene_prop_id"),
		(gt, ":count", 0),
		(assign, ":closest_sq_distance", ":maximum_sq_distance"),
		(try_for_range, ":instance_no", 0, ":count"),
			(scene_prop_get_instance, ":instance_id", ":scene_prop_id", ":instance_no"),
			(prop_instance_get_position, pos0, ":instance_id"),
			(get_sq_distance_between_positions, ":sq_distance", pos0, pos1),
			(lt, ":sq_distance", ":closest_sq_distance"),
			(assign, ":closest_sq_distance", ":sq_distance"),
			(assign, reg0, ":instance_id"),
		(try_end),
		(lt, ":closest_sq_distance", ":maximum_sq_distance"),
		]),

	("cf_use_castle_money_chest", # server and clients: handle depositing to and withdrawing from a money chest. the client version just does the checks, the server version also applies changes
	 [(store_script_param, ":player_id", 1), # must be valid
		(store_script_param, ":instance_id", 2),
		(store_script_param, ":gold_value", 3), # positive values to deposit, negative to withdraw

		(assign, ":fail_message", -1),
		(try_begin),
			(neq, "$g_game_type", "mt_no_money"),
			(neq, ":gold_value", 0),
			(assign, ":fail_message", "str_no_money_chest_nearby"),
			(call_script, "script_cf_can_use_scene_prop", ":player_id", ":instance_id", "spr_pw_castle_money_chest"),
			(scene_prop_get_slot, ":chest_gold", ":instance_id", slot_scene_prop_stock_count),
			(try_begin),
				(lt, ":gold_value", 0),
				(call_script, "script_scene_prop_get_owning_faction", ":instance_id"),
				(try_begin),
					(eq, reg1, -1),
				(else_try),
					(neg|multiplayer_is_server),
				(else_try),
					(scene_prop_slot_eq, ":instance_id", slot_scene_prop_unlocked, 1),
				(else_try),
					(player_slot_eq, ":player_id", slot_player_faction_id, reg0),
					(player_slot_eq, ":player_id", slot_player_has_faction_money_key, 1),
				(else_try),
					(player_slot_eq, ":player_id", slot_player_faction_id, reg0),
					(call_script, "script_cf_player_is_lord", ":player_id"),
				(else_try),
					(assign, ":fail_message", "str_cant_open_money_chest"),
				(try_end),
				(neq, ":fail_message", "str_cant_open_money_chest"),
				(assign, ":fail_message", "str_not_enough_money_in_chest"),
				(store_mul, ":gold_requested", ":gold_value", -1),
				(ge, ":chest_gold", ":gold_requested"),
				(try_begin),
					(multiplayer_is_server),
					(val_sub, ":chest_gold", ":gold_requested"),
					(call_script, "script_player_adjust_gold", ":player_id", ":gold_requested", 1),
					(assign, reg3, ":gold_value"),
					(str_store_player_username, s1, ":player_id"),
					(str_store_faction_name, s2, reg0),
					###GGG:bug
					(try_begin),
						(assign, ":faction_id", reg0),
						(le, ":faction_id", "fac_factions_end"),
						(ge, ":faction_id", 0),
						(faction_get_slot, ":is_active", ":faction_id", slot_faction_is_active),
						(eq, ":is_active", 1),
						(str_store_faction_name, s2, ":faction_id"),
						(neg|str_is_empty, s2),
						(server_add_message_to_log, "@{s1} took {reg3} gold out of the chest of faction: {s2}"),
					(try_end),
					###
				(try_end),
				(assign, ":fail_message", 0),
			(else_try),
				(gt, ":gold_value", 0),
				(assign, ":fail_message", "str_dont_have_enough_money"),
				(call_script, "script_cf_check_enough_gold", ":player_id", ":gold_value"),
				(try_begin),
					(multiplayer_is_server),
					(call_script, "script_player_adjust_gold", ":player_id", ":gold_value", -1),
					(val_add, ":chest_gold", ":gold_value"),
					(val_clamp, ":chest_gold", 0, max_possible_gold),
					(assign, reg3, ":gold_value"),
					(str_store_faction_name, s2, reg0),
					(str_store_player_username, s1, ":player_id"),
					 ###GGG:bug
					(try_begin),
						(assign, ":faction_id", reg0),
						(le, ":faction_id", "fac_factions_end"),
						(ge, ":faction_id", 0),        
						(faction_get_slot, ":is_active", ":faction_id", slot_faction_is_active),
						(eq, ":is_active", 1),
						(str_store_faction_name, s2, ":faction_id"),
						(neg|str_is_empty, s2),
						(server_add_message_to_log, "@{s1} deposited {reg3} gold in the chest of faction: {s2}"),
					(try_end),
					###
				(try_end),
				(assign, ":fail_message", 0),
			(try_end),
		(try_end),
		(try_begin),
			(eq, ":fail_message", 0),
			(try_begin),
				(multiplayer_is_server),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_stock_count, ":chest_gold"),
				(multiplayer_send_3_int_to_player, ":player_id", server_event_scene_prop_set_slot, ":instance_id", slot_scene_prop_stock_count, ":chest_gold"),
			(else_try),
				(multiplayer_send_3_int_to_server, client_event_transfer_gold, ":instance_id", ":gold_value"),
			(try_end),
		(else_try),
			(multiplayer_is_server),
			(gt, ":fail_message", 0),
			(neq, ":fail_message", "str_dont_have_enough_money"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_preset_message, ":fail_message", preset_message_error),
		(try_end),
		(assign, reg0, ":fail_message"),
		(eq, ":fail_message", 0),
		]),
	
("cf_pickup",
	[(store_trigger_param_1, ":agent_id"),
		(store_trigger_param_2, ":item_id"),
	
			(try_begin),
			(eq, ":item_id", "itm_money_bag"), #If money bag then don't log
			(else_try),
				(agent_get_player_id, ":player_id", ":agent_id"),
				(str_store_player_username, s1, ":player_id"),
				(str_store_item_name, s0, ":item_id"),
				(server_add_message_to_log, "@{s1} picked {s0} up"),
			(try_end),

	]),
	
("cf_dropd",
	[(store_trigger_param_1, ":agent_id"),
		(store_trigger_param_2, ":item_id"),
	
			(try_begin),
			(eq, ":item_id", "itm_money_bag"), #If money bag then don't log
			(else_try),
				(agent_get_player_id, ":player_id", ":agent_id"),
				(str_store_player_username, s1, ":player_id"),
				(str_store_item_name, s0, ":item_id"),
				(server_add_message_to_log, "@{s1} dropped {s0}"),
			(try_end),
	]),
	
("cf_hit_logging",
	[(store_trigger_param, ":attacked_agent_id", 1),
	(store_trigger_param, ":attacker_agent_id", 2),
	(store_trigger_param, ":damage_dealt", 3),
	(store_script_param, ":weapon_item_id", 4),
	
	(agent_is_active, ":attacker_agent_id"), 
	(agent_is_active, ":attacked_agent_id"),

	(try_begin), #lets find out whats happening
		#ggg:bots
		 (neg|agent_is_non_player, ":attacker_agent_id"),
		 (neg|agent_is_non_player, ":attacked_agent_id"),
		#
		 (agent_is_human, ":attacker_agent_id"), #2 players hit each other
		 (agent_is_human, ":attacked_agent_id"),

		 (agent_get_player_id, ":attacker_id", ":attacker_agent_id"),
		 (agent_get_player_id, ":attacked_id", ":attacked_agent_id"),
		 
		 (gt, ":attacker_id", 0), #prevent illegal spam like bots
		 (gt, ":attacked_id", 0), #prevent illegal spam like bots
		 
		 (str_store_player_username, s0, ":attacker_id"),
		 (str_store_player_username, s1, ":attacked_id"),
		 (assign, reg1, ":damage_dealt"),
		 (try_begin),
				(gt, ":weapon_item_id", 1),
				(str_store_item_name, s2, ":weapon_item_id"),
		 (else_try),
				(str_store_string, s2, "@Invalid weapon/Self damage"),
		 (try_end),
		 (server_add_message_to_log, "@{s0} attacked {s1} with {s2} and dealt {reg1} damage"),
		 
		 #GGG:outlaw rating
		 (try_begin),
				(neq, ":attacker_id", ":attacked_id"),
				(player_slot_eq, ":attacker_id", slot_player_fight_not_good, 0),
				(player_slot_eq, ":attacker_id", slot_player_outlaw_rating, 0), 
				(player_set_slot, ":attacker_id", slot_player_fight_not_good, 10), 

				(str_store_string, s3, "@You are not protected now!"),    
				(multiplayer_send_string_to_player, ":attacker_id", server_event_local_chat, s3),
		 (try_end),
		 #

		 (player_set_slot, ":attacked_id", slot_player_fight_state, 10),
		 (multiplayer_send_3_int_to_player, ":attacked_id", server_event_player_set_slot, ":attacked_id", slot_player_exiting, 10),     #GGG:delay downline
		 (str_store_string, s3, "@You are in combat state!"), 
		 (multiplayer_send_string_to_player, ":attacked_id", server_event_local_chat, s3),
		 ##Arthur: attacker in combat state as well
		 (player_set_slot, ":attacker_id", slot_player_fight_state, 10),
		 (multiplayer_send_3_int_to_player, ":attacker_id", server_event_player_set_slot, ":attacker_id", slot_player_exiting, 10),     #GGG:delay downline
		 (str_store_string, s3, "@You are in combat state!"), 
		 (multiplayer_send_string_to_player, ":attacker_id", server_event_local_chat, s3),
	(else_try), #someone hits a horse of a player
		#ggg:bots
		 (neg|agent_is_non_player, ":attacker_agent_id"),
		 (neg|agent_is_human, ":attacked_agent_id"),
		#
		 (agent_is_human, ":attacker_agent_id"), #Attacker would be the Human and the attacked one the horse of Player B
		 (agent_is_non_player, ":attacked_agent_id"), #attacked one is horse
		 (agent_get_player_id, ":attacker_id", ":attacker_agent_id"),
		 (agent_get_slot, ":last_rider_agent", ":attacked_agent_id", slot_agent_horse_last_rider),
		 (str_store_player_username, s0, ":attacker_id"),
		 (try_begin),
				(gt, ":last_rider_agent", 0),
				(agent_is_alive, ":last_rider_agent"),
				(agent_is_active, ":last_rider_agent"),
				(agent_get_player_id, ":last_rider_id", ":last_rider_agent"),
				(str_store_player_username, s1, ":last_rider_id"),
				(assign, reg1, ":damage_dealt"),
				(try_begin),
					(gt, ":weapon_item_id", 1),
					(str_store_item_name, s2, ":weapon_item_id"),
				(else_try),
					(str_store_string, s2, "@Invalid weapon/Self damage"),
				(try_end),
				(server_add_message_to_log, "@{s0} attacked the horse of {s1} with {s2} and dealt {reg1} damage"),
		 (else_try),
				(assign, reg1, ":damage_dealt"),
				(try_begin),
					(gt, ":weapon_item_id", 1),
					(str_store_item_name, s2, ":weapon_item_id"),
				(else_try),
					(str_store_string, s2, "@Invalid weapon/Self damage"),
				(try_end),
				(server_add_message_to_log, "@{s0} attacked a stray horse with {s2} and dealt {reg1} damage"),
		 (try_end),
	(else_try), #a horse bumped a player
		#ggg:bots
		 (neg|agent_is_human, ":attacker_agent_id"),
		 (neg|agent_is_non_player, ":attacked_agent_id"),
		#
		 (agent_is_human, ":attacked_agent_id"), #Attacked person would be the Human and the attacker would be on the horse
		 (agent_is_non_player, ":attacker_agent_id"), #attacker is horse
		 (agent_get_player_id, ":attacked_id", ":attacked_agent_id"),
		 (agent_get_slot, ":attacker_id", ":attacker_agent_id", slot_agent_horse_last_rider),
		 (gt, ":attacker_id", 0),
		 (str_store_player_username, s0, ":attacked_id"),
		 (try_begin),
				(gt, ":attacker_id", 0),
				(agent_is_alive, ":attacker_id"),
				(agent_is_active, ":attacker_id"),
				(agent_get_player_id, ":last_rider_id", ":attacker_id"),
				(str_store_player_username, s1, ":last_rider_id"),
				(assign, reg1, ":damage_dealt"),
				(server_add_message_to_log, "@{s0} got attacked by the horse of {s1} and got {reg1} damage"),
		 (else_try),
				(assign, reg1, ":damage_dealt"),
				(server_add_message_to_log, "@{s0} got attacked by stray horse and got {reg1} damage"),
		 (try_end),
	#GGG:fixed bug
	(else_try), #somethings attack player
		 (agent_is_human, ":attacked_agent_id"), 
		 (agent_get_player_id, ":attacked_id", ":attacked_agent_id"),
		 (gt, ":attacked_id", 0), #prevent illegal spawn like bots

		 (str_store_player_username, s1, ":attacked_id"),
		 (assign, reg1, ":damage_dealt"),
		 (gt, ":weapon_item_id", 1),
		 (str_store_string, s2, "@Invalid weapon/Self damage"),
		 (server_add_message_to_log, "@bot/animal attacked {s1} with {s2} and dealt {reg1} damage"),

		 (player_set_slot, ":attacked_id", slot_player_fight_state, 10),
		 (multiplayer_send_3_int_to_player, ":attacked_id", server_event_player_set_slot, ":attacked_id", slot_player_exiting, 10),     #GGG:delay downline
		 (str_store_string, s3, "@You are in combat state!"),    
		 (multiplayer_send_string_to_player, ":attacked_id", server_event_local_chat, s3),

	(else_try), #player has been attack by somethings
		 (agent_is_human, ":attacker_agent_id"),
		 (agent_get_player_id, ":attacker_id", ":attacker_agent_id"),
		 (gt, ":attacker_id", 0), #prevent illegal spam like bots

		 (str_store_player_username, s0, ":attacker_id"),
		 (assign, reg1, ":damage_dealt"),
		 (try_begin),
				(gt, ":weapon_item_id", 1),
				(str_store_item_name, s2, ":weapon_item_id"),
		 (else_try),
				(str_store_string, s2, "@Invalid weapon/Self damage"),
		 (try_end),
		 (server_add_message_to_log, "@{s0} attacked bot/animal with {s2} and dealt {reg1} damage"),
	(try_end),
	 ]), 
	
	("cf_drop_money_bag_item", # server: handle players dropping money bags
	 [(store_script_param, ":player_id", 1), # must be valid
		(store_script_param, ":gold_amount", 2),

		(player_get_agent_id, ":agent_id", ":player_id"),
		(agent_is_alive, ":agent_id"),
		(call_script, "script_cf_check_enough_gold", ":player_id", ":gold_amount"),
		(store_mission_timer_a, ":time"),
		(player_get_slot, ":last_action_time", ":player_id", slot_player_last_action_time),
		(store_sub, ":interval", ":time", ":last_action_time"),
		(this_or_next|ge, ":interval", repeat_action_min_interval),
		(player_is_admin, ":player_id"),
		(player_set_slot, ":player_id", slot_player_last_action_time, ":time"),
		(call_script, "script_player_adjust_gold", ":player_id", ":gold_amount", -1),
		(agent_get_position, pos1, ":agent_id"),
		(position_move_y, pos1, 50),
		(set_spawn_position, pos1),
		(spawn_item, "itm_money_bag", 0, "$g_spawn_item_prune_time"),
		(scene_prop_set_slot, reg0, slot_scene_prop_gold_value, ":gold_amount"),
		(str_store_player_username, s0, ":player_id"),
		#GGG
		(assign, reg1, ":gold_amount"),
		(try_begin),
			(gt, reg1, 49000),
			(server_add_message_to_log, "@WARNING: {s0} dropped a money bag with the value {reg1}"),
		(else_try),
			(server_add_message_to_log, "@{s0} dropped a money bag with the value {reg1}"),
		(try_end),
	
		(try_begin),
			(gt, reg1, 8500),
			(call_script, "script_player_carriedgold_update", ":player_id"), #fix gold exploit
		(try_end),
		]),

	("cf_pop_agent_money_bag_value", # remove the last added money bag amount from the agent's slots
	 [(store_script_param, ":agent_id", 1), # must be valid

		(assign, ":last_value", 0),
		(try_for_range_backwards, ":value_slot", slot_agent_money_bag_1_value, slot_agent_money_bag_4_value + 1),
			(agent_get_slot, ":value", ":agent_id", ":value_slot"),
			(agent_set_slot, ":agent_id", ":value_slot", ":last_value"),
			(assign, ":last_value", ":value"),
		(try_end),
		(assign, reg0, ":last_value"),
		(gt, ":last_value", 0),
		]),

	("cf_use_money_bag_item", # server: handle players retrieving the contents of equipped money bags
	 [(store_script_param, ":agent_id", 1), # must be valid

		(neq, "$g_game_type", "mt_no_money"),
		(call_script, "script_cf_agent_consume_item", ":agent_id", "itm_money_bag", 1),
		(call_script, "script_cf_pop_agent_money_bag_value", ":agent_id"),
		(assign, ":gold_value", reg0),
		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(call_script, "script_player_adjust_gold", ":player_id", ":gold_value", 1),
		#GGG:admin tools
		(str_store_player_username, s0, ":player_id"),
		(server_add_message_to_log, "@{s0} take a money bag with the value {reg0}"),
		#
		]),

	("check_on_item_picked_up", # server: extra checks when an agent picks up an item
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":item_id", 2),
		(store_script_param, ":instance_id", 3), # must be the item instance's id

		(try_begin),
			(eq, ":item_id", "itm_money_bag"), # since the item instance will be removed immediately aftewards, transfer the contents to an agent slot
			(neq, "$g_game_type", "mt_no_money"),
			(scene_prop_get_slot, ":value", ":instance_id", slot_scene_prop_gold_value),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_gold_value, 0),
			(try_for_range, ":value_slot", slot_agent_money_bag_1_value, slot_agent_money_bag_4_value + 1),
				(agent_get_slot, ":next_value", ":agent_id", ":value_slot"),
				(agent_set_slot, ":agent_id", ":value_slot", ":value"),
				(assign, ":value", ":next_value"),
			(try_end),
		(else_try),
			(this_or_next|eq, ":item_id", "itm_invisible_sword"),
			(eq, ":item_id", "itm_admin_scalpel"),
			(agent_get_player_id, ":player_id", ":agent_id"),
			(player_is_active, ":player_id"),
			(neg|player_is_admin, ":player_id"),
			(agent_unequip_item, ":agent_id", ":item_id"),
		(try_end),
		]),

	("check_on_item_dropped", # server: extra checks when an agent drops an item
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":item_id", 2),
		(store_script_param, ":instance_id", 3), # must be the dropped item instance's id
		(store_script_param, ":agent_died", 4), # set to 1 for dropping when the agent dies

		(set_fixed_point_multiplier, 100),
		(try_begin), # only check for items over a certain id, near the end of the list
			(le, ":item_id", "itm_lock_pick"),
		(else_try),
			(eq, ":item_id", "itm_money_bag"),
			(try_begin),
				(neq, "$g_game_type", "mt_no_money"),
				(call_script, "script_cf_pop_agent_money_bag_value", ":agent_id"), # transfer from the agent slot into the new dropped item instance
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_gold_value, reg0),
			(try_end),
		(else_try),
			(is_between, ":item_id", "itm_pw_banner_pole_a01", "itm_pw_banner_castle_fac_1a"),
			(neq, ":agent_died", 1), # if not dropped because the agent died, plant the flag pole upright
			(prop_instance_get_position, pos1, ":instance_id"),
			(position_rotate_x, pos1, 90),
			(prop_instance_set_position, ":instance_id", pos1),
			(assign, ":flag_prune_time", "$g_spawn_item_prune_time"),
			(val_max, ":flag_prune_time", 3600), # prevent it disappearing for at least an hour
			(scene_prop_set_prune_time, ":instance_id", ":flag_prune_time"),
		(else_try),
			(eq, ":item_id", "itm_fishing_net"),
			(prop_instance_get_position, pos1, ":instance_id"),
			(position_get_z, ":height", pos1),
			(try_begin),
				(lt, ":height", -100),
				(agent_get_troop_id, ":troop_id", ":agent_id"),
				(store_skill_level, ":placement_skill", "skl_labouring", ":troop_id"),
			(else_try),
				(assign, ":placement_skill", 0),
			(try_end),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_position, ":placement_skill"),
		(else_try),
			(eq, ":item_id", "itm_scythe"),
			(prop_instance_get_position, pos1, ":instance_id"),
			(position_rotate_x, pos1, 11),
			(prop_instance_set_position, ":instance_id", pos1),
		(else_try),
			(this_or_next|eq, ":item_id", "itm_beer_jug"),
			(eq, ":item_id", "itm_wheat_sheaf"),
			(prop_instance_get_position, pos1, ":instance_id"),
			(position_rotate_x, pos1, 90),
			(position_move_z, pos1, 21, 1),
			(prop_instance_set_position, ":instance_id", pos1),
		(else_try),
			(this_or_next|eq, ":item_id", "itm_flour_sack"),
			(this_or_next|eq, ":item_id", "itm_beer_cask"),
			(this_or_next|eq, ":item_id", "itm_must_barrel"),
			(eq, ":item_id", "itm_wine_barrel"),
			(prop_instance_get_position, pos1, ":instance_id"),
			(position_move_z, pos1, 16, 1),
			(prop_instance_set_position, ":instance_id", pos1),
		(else_try),
			(eq, ":item_id", "itm_die"),
			(prop_instance_get_position, pos1, ":instance_id"),
			(position_move_y, pos1, 50),
			(store_random_in_range, ":throw_result", 0, 6),
			(try_begin),
				(eq, ":throw_result", 0),
			(else_try),
				(eq, ":throw_result", 1),
				(position_rotate_x, pos1, 90),
			(else_try),
				(eq, ":throw_result", 2),
				(position_rotate_y, pos1, 90),
			(else_try),
				(eq, ":throw_result", 3),
				(position_rotate_y, pos1, -90),
			(else_try),
				(eq, ":throw_result", 4),
				(position_rotate_x, pos1, -90),
			(else_try),
				(position_rotate_x, pos1, 180),
			(try_end),
			(prop_instance_set_position, ":instance_id", pos1),
		(else_try), # remove admin items dropped on the ground
			(this_or_next|eq, ":item_id", "itm_invisible_sword"),
			(this_or_next|eq, ":item_id", "itm_admin_lock_pick"),
			(this_or_next|eq, ":item_id", "itm_admin_scalpel"),
			(eq, ":item_id", "itm_wand_of_law"), #GGG:wand of law
			(init_position, pos1),
			(position_set_z, pos1, z_position_to_hide_object),
			(prop_instance_set_position, ":instance_id", pos1),
			(scene_prop_set_prune_time, ":instance_id", 1),
		(try_end),
		]),

	("agent_calculate_stat_modifiers_for_item", # clients: return the modifiers in reg10 - reg14; server: apply the modifiers if that parameter is set
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":item_id", 2),
		(store_script_param, ":equipped", 3), # 1 = the item was equipped and wielded so add modifiers, 0 = the item was unwielded, so remove modifiers
		(store_script_param, ":apply", 4), # server only: 1 = apply the modifiers to the agent rather than returning them

		(try_begin),
			(multiplayer_is_server),
			(eq, ":equipped", 1),
			(eq, ":apply", 1), # if the item is the same as the last calcuated for this agent, skip the redundant calculations
			(agent_slot_eq, ":agent_id", slot_agent_last_apply_factors_item_id, ":item_id"),
		(else_try),
			(assign, ":handled", 1),
			(assign, ":cannot_attack", 0),
			(item_get_slot, ":difficulty", ":item_id", slot_item_difficulty),
			(item_get_type, ":item_type", ":item_id"),
			(try_begin),
				(is_between, ":item_type", itp_type_head_armor, itp_type_hand_armor + 1),
				(try_begin), # if the armor has restrictions, calculate the modifier factors
					(gt, ":difficulty", 0),
					(eq, ":equipped", 1),
					(agent_get_troop_id, ":troop_id", ":agent_id"),
					(store_attribute_level, ":troop_level", ":troop_id", ca_strength),
					(store_sub, ":difficulty_level", ":difficulty", ":troop_level"),
					(val_max, ":difficulty_level", 0),
					(store_mul, ":damage_factor", ":difficulty_level", armor_damage_reduction_factor),
					(try_begin),
						(eq, ":item_type", itp_type_head_armor),
						(store_mul, ":speed_factor", ":difficulty_level", head_armor_speed_reduction_factor),
						(store_mul, ":accuracy_factor", ":difficulty_level", head_armor_accuracy_reduction_factor),
						(store_mul, ":reload_factor", ":difficulty_level", head_armor_reload_reduction_factor),
					(else_try),
						(eq, ":item_type", itp_type_body_armor),
						(store_mul, ":speed_factor", ":difficulty_level", body_armor_speed_reduction_factor),
						(store_mul, ":accuracy_factor", ":difficulty_level", body_armor_accuracy_reduction_factor),
						(store_mul, ":reload_factor", ":difficulty_level", body_armor_reload_reduction_factor),
					(else_try),
						(eq, ":item_type", itp_type_foot_armor),
						(store_mul, ":speed_factor", ":difficulty_level", foot_armor_speed_reduction_factor),
						(store_mul, ":accuracy_factor", ":difficulty_level", foot_armor_accuracy_reduction_factor),
						(store_mul, ":reload_factor", ":difficulty_level", foot_armor_reload_reduction_factor),
					(else_try),
						(eq, ":item_type", itp_type_hand_armor),
						(store_mul, ":speed_factor", ":difficulty_level", hand_armor_speed_reduction_factor),
						(store_mul, ":accuracy_factor", ":difficulty_level", hand_armor_accuracy_reduction_factor),
						(store_mul, ":reload_factor", ":difficulty_level", hand_armor_reload_reduction_factor),
					(try_end),
				(else_try),
					(assign, ":damage_factor", 0),
					(assign, ":speed_factor", 0),
					(assign, ":accuracy_factor", 0),
					(assign, ":reload_factor", 0),
				(try_end),
				(assign, ":item_damage_factor", ":damage_factor"),
				(assign, ":item_speed_factor", ":speed_factor"),
				(assign, ":item_accuracy_factor", ":accuracy_factor"),
				(assign, ":item_reload_factor", ":reload_factor"),
				(assign, ":slot", slot_agent_head_damage_factor),
				(try_for_range, ":current_type", itp_type_head_armor, itp_type_hand_armor + 1),
					(neq, ":current_type", ":item_type"), # add cached factors for armor equipped in other slots
					(agent_get_slot, ":existing_damage_factor", ":agent_id", ":slot"),
					(val_add, ":damage_factor", ":existing_damage_factor"),
					(val_add, ":slot", 1),
					(agent_get_slot, ":existing_speed_factor", ":agent_id", ":slot"),
					(val_add, ":speed_factor", ":existing_speed_factor"),
					(val_add, ":slot", 1),
					(agent_get_slot, ":existing_accuracy_factor", ":agent_id", ":slot"),
					(val_add, ":accuracy_factor", ":existing_accuracy_factor"),
					(val_add, ":slot", 1),
					(agent_get_slot, ":existing_reload_factor", ":agent_id", ":slot"),
					(val_add, ":reload_factor", ":existing_reload_factor"),
					(val_add, ":slot", 1),
				(else_try), # if applying, cache the factors for the current armor item's slot
					(eq, ":apply", 1),
					(agent_set_slot, ":agent_id", ":slot", ":item_damage_factor"),
					(val_add, ":slot", 1),
					(agent_set_slot, ":agent_id", ":slot", ":item_speed_factor"),
					(val_add, ":slot", 1),
					(agent_set_slot, ":agent_id", ":slot", ":item_accuracy_factor"),
					(val_add, ":slot", 1),
					(agent_set_slot, ":agent_id", ":slot", ":item_reload_factor"),
					(val_add, ":slot", 1),
				(else_try), # otherwise skip the slots for the current armor item
					(val_add, ":slot", 4),
				(try_end),
				(try_begin),
					(eq, ":apply", 1), # if applying, cache the total armor factors
					(agent_set_slot, ":agent_id", slot_agent_armor_damage_factor, ":damage_factor"),
					(agent_set_slot, ":agent_id", slot_agent_armor_speed_factor, ":speed_factor"),
					(agent_set_slot, ":agent_id", slot_agent_armor_accuracy_factor, ":accuracy_factor"),
					(agent_set_slot, ":agent_id", slot_agent_armor_reload_factor, ":reload_factor"),
					(assign, ":damage_through", ":speed_factor"),
					(val_min, ":damage_through", 100),
					(agent_set_slot, ":agent_id", slot_agent_armor_damage_through, ":damage_through"),
				(try_end), # add existing weapon factors
				(agent_get_slot, ":weapon_damage_factor", ":agent_id", slot_agent_weapon_damage_factor),
				(val_add, ":damage_factor", ":weapon_damage_factor"),
				(agent_get_slot, ":weapon_speed_factor", ":agent_id", slot_agent_weapon_speed_factor),
				(val_add, ":speed_factor", ":weapon_speed_factor"),
				(agent_get_slot, ":weapon_accuracy_factor", ":agent_id", slot_agent_weapon_accuracy_factor),
				(val_add, ":accuracy_factor", ":weapon_accuracy_factor"),
				(agent_get_slot, ":weapon_reload_factor", ":agent_id", slot_agent_weapon_reload_factor),
				(val_add, ":reload_factor", ":weapon_reload_factor"),
			(else_try),
				(try_begin),
					(assign, ":damage_factor", 0),
					(assign, ":speed_factor", 0),
					(try_begin), # for crossbows, apply extra accuracy and reload factors based on proficiency
						(eq, ":item_type", itp_type_crossbow),
						(eq, ":equipped", 1),
						(agent_get_troop_id, ":troop_id", ":agent_id"),
						(store_proficiency_level, ":crossbow", ":troop_id", wpt_crossbow),
						(lt, ":crossbow", 100),
						(store_sub, ":accuracy_factor", 100, ":crossbow"),
						(val_div, ":accuracy_factor", 2),
						(assign, ":reload_factor", ":accuracy_factor"),
					(else_try),
						(assign, ":accuracy_factor", 0),
						(assign, ":reload_factor", 0),
					(try_end),
					(gt, ":difficulty", 0),
					(eq, ":equipped", 1),
					(agent_get_troop_id, ":troop_id", ":agent_id"),
					(try_begin),
					#GGG:engineer
						(this_or_next|eq, ":item_id", "itm_maul"),
						(this_or_next|eq, ":item_id", "itm_sledgehammer"),
						(eq, ":item_id", "itm_warhammer"),
						(try_begin),
							(is_between, ":troop_id", playable_troops_begin, playable_troops_end),
							(store_skill_level, ":engineer_level", "skl_engineer", ":troop_id"),
							(try_begin),
								(le, ":engineer_level", 6),
								(neq, ":troop_id", "trp_engineer"),
								(assign, ":cannot_attack", 1),
							(else_try),
								(neg|is_between, ":troop_id", hero_begin, hero_end),
								(assign, ":cannot_attack", 1),
							(try_end),
						#(else_try),
						#  (neq, ":troop_id", "trp_engineer"),
						#  (assign, ":cannot_attack", 1),
						(try_end),
					(else_try),
					###
						(is_between, ":item_type", itp_type_one_handed_wpn, itp_type_polearm + 1),
						(store_attribute_level, ":troop_level", ":troop_id", ca_strength),
						(store_sub, ":difficulty_level", ":difficulty", ":troop_level"),
						(val_max, ":difficulty_level", 0),
						(store_mul, ":damage_factor", ":difficulty_level", melee_damage_reduction_factor),
						(store_mul, ":speed_factor", ":difficulty_level", melee_speed_reduction_factor),
						(try_begin),
							(gt, ":difficulty_level", melee_max_level_difference),
							(assign, ":cannot_attack", 1),
						(try_end),
					(else_try),
						(eq, ":item_type", itp_type_crossbow),
						(store_attribute_level, ":troop_level", ":troop_id", ca_strength),
						(store_sub, ":difficulty_level", ":difficulty", ":troop_level"),
						(val_max, ":difficulty_level", 0),
						(store_mul, ":damage_factor", ":difficulty_level", crossbow_damage_reduction_factor),
						(store_mul, ":speed_factor", ":difficulty_level", crossbow_speed_reduction_factor),
						(store_mul, ":accuracy_factor_2", ":difficulty_level", crossbow_accuracy_reduction_factor),
						(val_add, ":accuracy_factor", ":accuracy_factor_2"),
						(store_mul, ":reload_factor_2", ":difficulty_level", crossbow_reload_reduction_factor),
						(val_add, ":reload_factor", ":reload_factor_2"),
						(try_begin),
							(gt, ":difficulty_level", crossbow_max_level_difference),
							(assign, ":cannot_attack", 1),
						(try_end),
					(else_try),
						(this_or_next|eq, ":item_type", itp_type_bow),
						(eq, ":item_type", itp_type_thrown),
						(try_begin),
							(eq, ":item_type", itp_type_bow),
							(store_skill_level, ":troop_level", "skl_power_draw", ":troop_id"),
						(else_try),
							(eq, ":item_type", itp_type_thrown),
							(store_skill_level, ":troop_level", "skl_power_throw", ":troop_id"),
						(try_end),
						(store_sub, ":difficulty_level", ":difficulty", ":troop_level"),
						(val_max, ":difficulty_level", 0),
						(store_mul, ":damage_factor", ":difficulty_level", bow_thrown_damage_reduction_factor),
						(store_mul, ":speed_factor", ":difficulty_level", bow_thrown_speed_reduction_factor),
						(store_mul, ":accuracy_factor", ":difficulty_level", bow_thrown_accuracy_reduction_factor),
						(try_begin),
							(gt, ":troop_level", 0),
							(le, ":difficulty_level", bow_ranged_max_level_difference),
						(else_try),
							(assign, ":cannot_attack", 1),
						(try_end),
					(else_try),
						(assign, ":handled", 0), # an unhandled item type
					(try_end),
				(else_try),
					(neg|is_between, ":item_type", itp_type_one_handed_wpn, itp_type_polearm + 1),
					(neg|is_between, ":item_type", itp_type_bow, itp_type_thrown + 1),
					(assign, ":handled", 0), # an unhandled item type
				(try_end),
				(eq, ":handled", 1),
				(try_begin),
					(eq, ":apply", 1), # if applying, cache the weapon factors
					(agent_set_slot, ":agent_id", slot_agent_weapon_damage_factor, ":damage_factor"),
					(agent_set_slot, ":agent_id", slot_agent_weapon_speed_factor, ":speed_factor"),
					(agent_set_slot, ":agent_id", slot_agent_weapon_accuracy_factor, ":accuracy_factor"),
					(agent_set_slot, ":agent_id", slot_agent_weapon_reload_factor, ":reload_factor"),
				(try_end), # add existing armor factors
				(agent_get_slot, ":armor_damage_factor", ":agent_id", slot_agent_armor_damage_factor),
				(val_add, ":damage_factor", ":armor_damage_factor"),
				(agent_get_slot, ":armor_speed_factor", ":agent_id", slot_agent_armor_speed_factor),
				(val_add, ":speed_factor", ":armor_speed_factor"),
				(agent_get_slot, ":armor_accuracy_factor", ":agent_id", slot_agent_armor_accuracy_factor),
				(val_add, ":accuracy_factor", ":armor_accuracy_factor"),
				(agent_get_slot, ":armor_reload_factor", ":agent_id", slot_agent_armor_reload_factor),
				(val_add, ":reload_factor", ":armor_reload_factor"),
			(try_end),
			(assign, ":damage_modifier", 100),
			(assign, ":speed_modifier", 100),
			(assign, ":accuracy_modifier", 100),
			(assign, ":reload_modifier", 100),
			(try_begin), # convert the total factors (additive) into modifiers (subtracting from 100)
				(eq, ":handled", 1),
				(try_begin),
					(gt, ":damage_factor", 0),
					(store_sub, ":damage_modifier", reduction_factor_base, ":damage_factor"),
					(val_max, ":damage_modifier", 0),
				(try_end),
				(try_begin),
					(gt, ":speed_factor", 0),
					(store_sub, ":speed_modifier", reduction_factor_base, ":speed_factor"),
					(val_max, ":speed_modifier", 0),
				(try_end),
				(try_begin),
					(gt, ":accuracy_factor", 0),
					(store_sub, ":accuracy_modifier", reduction_factor_base, ":accuracy_factor"),
					(val_max, ":accuracy_modifier", 0),
				(try_end),
				(try_begin),
					(gt, ":reload_factor", 0),
					(store_sub, ":reload_modifier", reduction_factor_base, ":reload_factor"),
					(val_max, ":reload_modifier", 0),
				(try_end),
				(try_begin), # get the agent's wielded item type if the one being checked is not a weapon
					(neg|is_between, ":item_type", itp_type_head_armor, itp_type_hand_armor + 1),
					(assign, ":wielded_item_type", ":item_type"),
				(else_try),
					(agent_get_wielded_item, ":wielded_item_id", ":agent_id", 0),
					(gt, ":wielded_item_id", -1),
					(item_get_type, ":wielded_item_type", ":wielded_item_id"),
				(else_try),
					(assign, ":wielded_item_type", -1),
				(try_end),
				(try_begin), # prevent attacking if relevant modifiers are zero
					(neq, ":cannot_attack", 1),
					(neq, ":speed_modifier", 0),
					(neq, ":damage_modifier", 0),
					(this_or_next|neq, ":accuracy_modifier", 0),
					(neg|is_between, ":wielded_item_type", itp_type_bow, itp_type_thrown + 1),
					(this_or_next|neq, ":reload_modifier", 0),
					(neq, ":wielded_item_type", itp_type_crossbow),
					(assign, ":cannot_attack", 0),
				(else_try),
					(assign, ":cannot_attack", 1),
				(try_end),
				(eq, ":apply", 1),
				(agent_set_slot, ":agent_id", slot_agent_cannot_attack, ":cannot_attack"),
				(try_begin), # only apply modifiers on the server: it seems to cause memory leaks on clients
					(multiplayer_is_server),
					(agent_set_damage_modifier, ":agent_id", ":damage_modifier"),
					(agent_set_ranged_damage_modifier, ":agent_id", ":damage_modifier"),
					(agent_set_speed_modifier, ":agent_id", ":speed_modifier"),
					(agent_set_accuracy_modifier, ":agent_id", ":accuracy_modifier"),
					(agent_set_reload_speed_modifier, ":agent_id", ":reload_modifier"),
					(try_begin), # remember the item id to avoid duplicate calculation if the script is called twice, by hard coded triggers or whatever
						(eq, ":equipped", 1),
						(agent_set_slot, ":agent_id", slot_agent_last_apply_factors_item_id, ":item_id"),
					(else_try),
						(agent_set_slot, ":agent_id", slot_agent_last_apply_factors_item_id, -1),
					(try_end),
				(try_end),
			(else_try),
				(neq, ":apply", 1),
				(assign, reg10, ":cannot_attack"),
				(assign, reg11, ":damage_modifier"),
				(assign, reg12, ":speed_modifier"),
				(assign, reg13, ":accuracy_modifier"),
				(assign, reg14, ":reload_modifier"),
			(try_end),
		(try_end),
		]),

	("scene_prop_adjust_hit", # server: adjust hit damage by an agent on a resource scene prop for tools, skill, and more; reg0 = agent id
	 [(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":hit_damage", 2),
		(store_script_param, ":hardness", 3), # divides the damage dealt by this number
		(store_script_param, ":tool_class", 4), # constants starting with item_class_
		(store_script_param, ":skill_id", 5),
		(store_script_param, ":attack_direction_range", 6), # second digit = direction from agent_get_action_dir, first digit = subsequent directions to include
		(set_fixed_point_multiplier, 1),
		(position_get_x, ":agent_id", pos2), # expects agent id in pos2.x from ti_on_scene_prop_hit
		(set_fixed_point_multiplier, 100),

		(try_begin),
			(gt, ":skill_id", -1),
			(agent_get_troop_id, ":troop_id", ":agent_id"),
			(store_skill_level, ":skill", ":skill_id", ":troop_id"),
			(try_begin),
				(le, ":skill", 0),
				(val_mul, ":hit_damage", 10),
			(else_try),
				(val_mul, ":hit_damage", 50),
				(val_mul, ":hit_damage", ":skill"),
			(try_end),
		(else_try),
			(val_mul, ":hit_damage", 100),
		(try_end),
		(try_begin),
			(ge, ":hit_damage", 100), # will be divided by 100 later, so checking if the damage can be greater than 0
			(try_begin),
				(gt, ":attack_direction_range", -1),
				(store_div, ":attack_direction_end", ":attack_direction_range", 10),
				(val_mod, ":attack_direction_range", 10),
				(val_add, ":attack_direction_end", ":attack_direction_range"),
				(val_add, ":attack_direction_end", 1),
				(agent_get_action_dir, ":attack_direction", ":agent_id"),
				(neg|is_between, ":attack_direction", ":attack_direction_range", ":attack_direction_end"),
				(val_div, ":hit_damage", 3),
			(try_end),
			(ge, ":hit_damage", 100),
			(try_begin),
				(gt, ":tool_class", -1),
				(agent_get_wielded_item, ":wielded_item", ":agent_id", 0),
				(try_begin),
					(gt, ":wielded_item", -1),
					(item_get_slot, ":wielded_item_class", ":wielded_item", slot_item_class),
					(eq, ":wielded_item_class", ":tool_class"),
				(else_try),
					(val_div, ":hit_damage", 5),
				(try_end),
			(try_end),
			(val_max, ":hardness", 1),
			(val_div, ":hit_damage", ":hardness"),
			(agent_get_slot, ":food_amount", ":agent_id", slot_agent_food_amount),
			(store_sub, ":hunger_factor", max_food_amount, ":food_amount"),
			(val_mul, ":hunger_factor", ":hardness"),
			(val_mul, ":hunger_factor", ":hit_damage"),
			(val_div, ":hunger_factor", max_food_amount * 7),
			(val_sub, ":hit_damage", ":hunger_factor"),
			(val_max, ":hit_damage", 0),
			(try_begin), # decrease food amount based on a probability to simulate an average of less than one point per hit
				(gt, ":food_amount", 0),
				(store_random_in_range, ":random", ":hardness", 16),
				(gt, ":random", 12),
				(val_sub, ":food_amount", 1),
				(agent_set_slot, ":agent_id", slot_agent_food_amount, ":food_amount"),
				(store_mod, ":remainder", ":food_amount", 5),
				(eq, ":remainder", 0), # only send food bar updates to the player's client about every 5% used
				(agent_get_player_id, ":player_id", ":agent_id"),
				(player_is_active, ":player_id"),
				(multiplayer_send_3_int_to_player, ":player_id", server_event_agent_set_slot, ":agent_id", slot_agent_food_amount, ":food_amount"),
			(try_end),
		(try_end),
		(val_div, ":hit_damage", 100),
		(call_script, "script_scene_prop_damage_no_destroy", ":instance_id", ":hit_damage"),
		(assign, reg0, ":agent_id"),
		]),

	("scene_prop_damage_no_destroy", # server: adjust damage to a scene prop so it is never destroyed; reg1 = adjusted damage, reg2 = adjusted hit points
	 [(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":hit_damage", 2),

		(scene_prop_get_hit_points, ":hit_points", ":instance_id"),
		(val_sub, ":hit_points", ":hit_damage"),
		(try_begin),
			(lt, ":hit_points", min_scene_prop_hit_points),
			(val_add, ":hit_damage", ":hit_points"),
			(val_sub, ":hit_damage", min_scene_prop_hit_points),
			(assign, ":hit_points", min_scene_prop_hit_points),
		(try_end),
		(set_trigger_result, ":hit_damage"),
		(assign, reg1, ":hit_damage"),
		(assign, reg2, ":hit_points"),
		]),

	("cf_check_drop_resource", # server: check if scene prop hit points have decreased enough to drop resources; storing the number to drop in reg0
	 [(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":hit_points", 2), # current hit points
		(store_script_param, ":hit_points_for_resource", 3), # hit damage required per resource dropped
		(store_script_param, ":random_adjustment", 4), # maximum random adjustment to the above value

		(scene_prop_get_slot, ":next_resource_hp", ":instance_id", slot_scene_prop_next_resource_hp),
		(assign, reg0, 0),
		(assign, ":loop_condition", 10), # only check for a maximum of 10 iterations, to prevent long or infinite loops
		(try_for_range, ":unused", 0, ":loop_condition"),
			(ge, ":next_resource_hp", ":hit_points"),
			(val_sub, ":next_resource_hp", ":hit_points_for_resource"),
			(try_begin),
				(gt, ":random_adjustment", 0),
				(store_random_in_range, ":random_hp", 0, ":random_adjustment"),
				(val_sub, ":next_resource_hp", ":random_hp"),
			(try_end),
			(val_add, reg0, 1),
		(else_try),
			(assign, ":loop_condition", -1),
		(try_end),
		(neq, reg0, 0),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_next_resource_hp, ":next_resource_hp"),
		]),

	("cf_hit_tree", # server: handle agents damaging a tree, should be called from ti_on_scene_prop_hit; reg0 = agent id, reg1 = hit damage, reg2 = hit points
	 [(multiplayer_is_server),
		(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":hit_damage", 2),
		(store_script_param, ":fell_tree_hit_points", 3), # hit points when the tree should be rotated to lie along the ground and produce blocks rather than branches
		(store_script_param, ":hit_points_for_resource", 4),
		(store_script_param, ":hardness", 5),
		(store_script_param, ":resource_imod", 6), # item mesh variation to match the visual appearance
		(store_script_param, ":regrow_interval", 7),

		(scene_prop_get_slot, ":state", ":instance_id", slot_scene_prop_state),
		(assign, ":break_effect", 0),
		(try_begin),
			(this_or_next|eq, ":state", scene_prop_state_active),
			(eq, ":state", scene_prop_state_destroyed),
			(call_script, "script_scene_prop_adjust_hit", ":instance_id", ":hit_damage", ":hardness", item_class_wood_cutting, "skl_labouring", 11),
			(assign, ":agent_id", reg0),
			(assign, ":hit_damage", reg1),
			(assign, ":hit_points", reg2),
			(try_begin),
				(lt, ":hit_points", ":fell_tree_hit_points"),
				(try_begin),
					(eq, ":state", scene_prop_state_destroyed),
					(le, ":hit_points", min_scene_prop_hit_points),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_hidden),
					(prop_instance_get_position, pos2, ":instance_id"),
					(position_move_z, pos2, -5000, 1),
					(prop_instance_animate_to_position, ":instance_id", pos2, 2000),
					(call_script, "script_add_resource_to_regrow_list", ":instance_id", ":regrow_interval"),
				(else_try),
					(eq, ":state", scene_prop_state_active),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_destroyed),
					(prop_instance_get_starting_position, pos2, ":instance_id"),
					(copy_position, pos3, pos2), # calculate the best angle to match the terrain by measuring at multiple distances along the felled length
					(assign, ":trunk_angle", 90),
					(try_for_range, ":count", 1, 4),
						(position_move_x, pos3, 500),
						(position_get_distance_to_ground_level, ":ground_distance", pos3),
						(store_sub, ":slope_ratio", ":ground_distance", 30),
						(val_abs, ":slope_ratio"),
						(convert_to_fixed_point, ":slope_ratio"),
						(store_mul, ":trunk_distance", ":count", 500),
						(val_div, ":slope_ratio", ":trunk_distance"),
						(store_atan, ":test_angle", ":slope_ratio"),
						(convert_from_fixed_point, ":test_angle"),
						(try_begin),
							(lt, ":ground_distance", 0),
							(val_mul, ":test_angle", -1),
						(try_end),
						(val_min, ":trunk_angle", ":test_angle"),
					(try_end),
					(val_add, ":trunk_angle", 90),
					(position_rotate_y, pos2, ":trunk_angle"),
					(prop_instance_animate_to_position, ":instance_id", pos2, 300),
					(assign, ":break_effect", 1),
					(scene_prop_get_slot, ":attached_item_count", ":instance_id", slot_scene_prop_inventory_count), # drop attached items on the ground
					(val_add, ":attached_item_count", slot_scene_prop_inventory_begin),
					(try_for_range, ":slot", slot_scene_prop_inventory_begin, ":attached_item_count"),
						(scene_prop_get_slot, ":attached_instance_id", ":instance_id", ":slot"),
						(prop_instance_is_valid, ":attached_instance_id"),
						(scene_prop_slot_eq, ":attached_instance_id", slot_scene_prop_linked_scene_prop, ":instance_id"),
						(prop_instance_get_position, pos4, ":attached_instance_id"),
						(position_move_z, pos4, -50),
						(position_set_z_to_ground_level, pos4),
						(prop_instance_set_position, ":attached_instance_id", pos4),
					(try_end),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_count, 0),
				(try_end),
				(assign, ":resource_item_id", "itm_wood_block"),
			(else_try),
				(assign, ":resource_item_id", "itm_branch"),
			(try_end),
			(try_begin),
				(call_script, "script_cf_check_drop_resource", ":instance_id", ":hit_points", ":hit_points_for_resource", 0),
				(assign, ":resource_count", reg0),
				(try_for_range, ":unused", 0, ":resource_count"),
					(call_script, "script_set_random_spawn_position", 200),
					(spawn_item, ":resource_item_id", ":resource_imod", "$g_spawn_item_prune_time"),
				(try_end),
				(assign, ":break_effect", 1),
			(try_end),
		(else_try), # don't allow damaging destroyed and hidden trees, for whatever reason
			(assign, ":hit_damage", 0),
			(set_trigger_result, 0),
			(set_fixed_point_multiplier, 1),
			(position_get_x, ":agent_id", pos2),
			(set_fixed_point_multiplier, 100),
		(try_end),
		(try_begin),
			(eq, ":break_effect", 1),
			(particle_system_burst, "psys_dummy_straw", pos1, 40),
			(particle_system_burst, "psys_gourd_piece_2", pos1, 5),
			(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_cut_wood_break"),
		(else_try),
			(ge, ":hit_damage", 5),
			(particle_system_burst, "psys_dummy_straw", pos1, 10),
			(particle_system_burst, "psys_gourd_piece_2", pos1, 2),
			(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_cut_wood"),
		(else_try),
			(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_cut_wood_scratch"),
		(try_end),
		]),

	("add_resource_to_regrow_list", # server: add a scene prop instance id to a list for calling a specified script after the regrowing time interval
	 [(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":regrow_interval", 2),

		(prop_instance_get_variation_id_2, ":regrow_interval_multiplier", ":instance_id"),
		(val_max, ":regrow_interval_multiplier", 1),
		(val_mul, ":regrow_interval", ":regrow_interval_multiplier"),
		(store_mission_timer_a, ":time"),
		(val_add, ":time", ":regrow_interval"),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_state_time, ":time"),
		(troop_get_slot, ":resources_count", "trp_removed_scene_props", slot_array_count),
		(store_add, ":loop_end", ":resources_count", slot_array_begin),
		(try_for_range, ":resource_slot", slot_array_begin, ":loop_end"),
			(neg|troop_slot_ge, "trp_removed_scene_props", ":resource_slot", 1),
			(troop_set_slot, "trp_removed_scene_props", ":resource_slot", ":instance_id"),
			(assign, ":loop_end", -1),
		(try_end),
		(try_begin),
			(neq, ":loop_end", -1),
			(troop_set_slot, "trp_removed_scene_props", ":loop_end", ":instance_id"),
			(val_add, ":resources_count", 1),
			(troop_set_slot, "trp_removed_scene_props", slot_array_count, ":resources_count"),
		(try_end),
		]),

	("regrow_resource", # server: generic regrowing script called if a custom one is not set
	 [(store_script_param, ":instance_id", 1), # must be valid

		(set_fixed_point_multiplier, 100),
		(prop_instance_get_starting_position, pos1, ":instance_id"),
		(copy_position, pos2, pos1),
		(position_move_z, pos2, -5000, 1),
		(prop_instance_set_position, ":instance_id", pos2),
		(prop_instance_animate_to_position, ":instance_id", pos1, 6000),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_regenerating),
		(prop_instance_enable_physics, ":instance_id", 1),
		]),

	("regrow_fruit_tree", # server: either regrow the tree or produce fruit
	 [(store_script_param, ":instance_id", 1), # must be valid

		(assign, ":regrow_again", 1),
		(try_begin), # tree is already active, so regrow fruit
			(scene_prop_slot_eq, ":instance_id", slot_scene_prop_state, scene_prop_state_active),
			(scene_prop_get_slot, ":attached_item_count", ":instance_id", slot_scene_prop_inventory_count), # check for fruit still unpicked
			(val_add, ":attached_item_count", slot_scene_prop_inventory_begin),
			(assign, ":first_invalid_slot", -1),
			(assign, ":existing_fruit_count", 0),
			(try_for_range, ":slot", slot_scene_prop_inventory_begin, ":attached_item_count"),
				(scene_prop_get_slot, ":attached_instance_id", ":instance_id", ":slot"),
				(prop_instance_is_valid, ":attached_instance_id"),
				(scene_prop_slot_eq, ":attached_instance_id", slot_scene_prop_linked_scene_prop, ":instance_id"),
				(val_add, ":existing_fruit_count", 1),
				(try_begin), # compress the attached fruit array to be continuous and valid
					(gt, ":first_invalid_slot", -1),
					(scene_prop_set_slot, ":instance_id", ":first_invalid_slot", ":attached_instance_id"),
					(val_add, ":first_invalid_slot", 1),
				(try_end),
			(else_try),
				(eq, ":first_invalid_slot", -1),
				(assign, ":first_invalid_slot", ":slot"),
			(try_end),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_count, ":existing_fruit_count"),
			(scene_prop_get_slot, ":fruit_count", ":instance_id", slot_scene_prop_fruit_count),
			(store_mul, ":maximum_fruit_count", ":fruit_count", 2),
			(try_begin),
				(lt, ":existing_fruit_count", ":maximum_fruit_count"), # only grow new fruit if not loaded with old
				(scene_prop_get_slot, ":fruit_item_id", ":instance_id", slot_scene_prop_resource_item_id),
				(scene_prop_get_slot, ":fruit_height", ":instance_id", slot_scene_prop_height),
				(scene_prop_get_slot, ":fruit_width", ":instance_id", slot_scene_prop_width),
				(store_random_in_range, ":random_factor", 50, 101),
				(store_mul, ":new_fruit_count", ":fruit_count", ":random_factor"),
				(val_div, ":new_fruit_count", 100),
				(prop_instance_get_position, pos1, ":instance_id"),
				(init_position, pos3),
				(position_move_z, pos1, ":fruit_height"),
				(store_add, ":fruit_item_index", ":existing_fruit_count", slot_scene_prop_inventory_begin),
				(try_for_range, ":unused", 0, ":new_fruit_count"),
					(copy_position, pos2, pos1), # produce fruit items within a sphere of radius fruit_width, centered at fruit_height above the tree origin
					(store_random_in_range, ":random_angle", -180, 180),
					(position_rotate_z, pos2, ":random_angle"),
					(store_random_in_range, ":random_angle", -80, 81),
					(position_rotate_x, pos2, ":random_angle"),
					(store_random_in_range, ":random_distance", 30, ":fruit_width"),
					(position_move_y, pos2, ":random_distance"),
					(position_copy_rotation, pos2, pos3),
					(store_random_in_range, ":random_angle", -180, 180),
					(position_rotate_z, pos2, ":random_angle"),
					(set_spawn_position, pos2),
					(spawn_item, ":fruit_item_id", 0, "$g_spawn_item_prune_time"),
					(scene_prop_set_slot, ":instance_id", ":fruit_item_index", reg0), # store the spawned item instance ids to drop on ground if tree is cut down
					(scene_prop_set_slot, reg0, slot_scene_prop_linked_scene_prop, ":instance_id"),
					(val_add, ":fruit_item_index", 1),
				(try_end),
				(val_add, ":new_fruit_count", ":existing_fruit_count"),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_count, ":new_fruit_count"),
			(try_end),
		(else_try), # call the normal regrowing script if cut down
			(scene_prop_slot_eq, ":instance_id", slot_scene_prop_state, scene_prop_state_hidden),
			(call_script, "script_regrow_resource", ":instance_id"),
		(else_try),
			(assign, ":regrow_again", 0),
		(try_end),
		(try_begin), # set up the callback for the next fruiting cycle
			(eq, ":regrow_again", 1),
			(scene_prop_get_slot, ":regrow_interval", ":instance_id", slot_scene_prop_fruiting_interval),
			(store_random_in_range, ":random_factor", 80, 121),
			(val_mul, ":regrow_interval", ":random_factor"),
			(val_div, ":regrow_interval", 100),
			(call_script, "script_add_resource_to_regrow_list", ":instance_id", ":regrow_interval"),
		(try_end),
		]),

	("cf_resource_animation_finished", # server: called when an animation for a regrowing resource scene prop is finished, to change the state
	 [(multiplayer_is_server),
		(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":hit_points_for_resource", 2),

		(scene_prop_get_slot, ":state", ":instance_id", slot_scene_prop_state),
		(try_begin),
			(eq, ":state", scene_prop_state_regenerating),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_active),
			(scene_prop_get_slot, ":full_hit_points", ":instance_id", slot_scene_prop_full_hit_points),
			(scene_prop_set_hit_points, ":instance_id", ":full_hit_points"),
			(val_sub, ":full_hit_points", ":hit_points_for_resource"),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_next_resource_hp, ":full_hit_points"),
		(else_try),
			(eq, ":state", scene_prop_state_hidden),
			(prop_instance_enable_physics, ":instance_id", 0),
		(try_end),
		]),

	("initialize_resource_hit_points", # adjust the hit points for certain resource scene props using scene editor values
	 [(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":hit_points_for_resource", 2),

		(prop_instance_get_variation_id, ":start_hit_points", ":instance_id"),
		(val_mul, ":start_hit_points", 120),
		(val_clamp, ":start_hit_points", 120, max_correctly_displayed_hp + 1),
		(scene_prop_set_hit_points, ":instance_id", ":start_hit_points"),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_full_hit_points, ":start_hit_points"),
		(try_begin),
			(multiplayer_is_server),
			(gt, ":hit_points_for_resource", -1),
			(val_sub, ":start_hit_points", ":hit_points_for_resource"),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_next_resource_hp, ":start_hit_points"),
		(else_try),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_next_resource_hp, 1),
		(try_end),
		]),

	("cf_hit_regrowing_resource", # server: generic script for hitting a resource scene prop, should be called from ti_on_scene_prop_hit; reg0 = agent id, reg1 = hit damage, reg2 = hit points
	 [(multiplayer_is_server),
		(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":hit_damage", 2),
		(store_script_param, ":hit_points_for_resource", 3),
		(store_script_param, ":resource_item_id", 4),
		(store_script_param, ":hardness", 5),
		(store_script_param, ":tool_class", 6), # constants starting with item_class_
		(store_script_param, ":skill_id", 7),
		(store_script_param, ":attack_direction_range", 8), # second digit = direction from agent_get_action_dir, first digit = subsequent directions to include
		(store_script_param, ":spawn_on_ground", 9), # 0 = spawn resources at the hit position, 1 = spawn at a random nearby position on the ground
		(store_script_param, ":regrow_interval", 10),
		(store_script_param, ":effect_script_id", 11), # if greater than -1, called as a script to play visual or sound effects
		(store_script_param, ":random_hit_points_adjustment", 12), # maximum random adjustment to hit_points_for_resource

		(scene_prop_get_slot, ":state", ":instance_id", slot_scene_prop_state),
		(try_begin),
			(eq, ":state", scene_prop_state_active),
			(call_script, "script_scene_prop_adjust_hit", ":instance_id", ":hit_damage", ":hardness", ":tool_class", ":skill_id", ":attack_direction_range"),
			(assign, ":agent_id", reg0),
			(assign, ":hit_damage", reg1),
			(assign, ":hit_points", reg2),
			(assign, ":resource_count", 0),
			(try_begin),
				(le, ":hit_points", min_scene_prop_hit_points),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_hidden),
				(prop_instance_get_starting_position, pos2, ":instance_id"),
				(position_move_z, pos2, -1000, 1),
				(prop_instance_animate_to_position, ":instance_id", pos2, 500),
				(particle_system_burst, "psys_dummy_smoke", pos2, 10),
				(call_script, "script_add_resource_to_regrow_list", ":instance_id", ":regrow_interval"),
				(assign, ":resource_count", -1),
			(else_try),
				(call_script, "script_cf_check_drop_resource", ":instance_id", ":hit_points", ":hit_points_for_resource", ":random_hit_points_adjustment"),
				(assign, ":resource_count", reg0),
				(try_for_range, ":unused", 0, ":resource_count"),
					(try_begin),
						(eq, ":spawn_on_ground", 1),
						(call_script, "script_set_random_spawn_position", 50),
					(else_try),
						(set_spawn_position, pos1),
					(try_end),
					(spawn_item, ":resource_item_id", 0, "$g_spawn_item_prune_time"),
				(try_end),
			(try_end),
			(try_begin),
				(gt, ":effect_script_id", -1),
				(agent_is_active, ":agent_id"),
				(call_script, ":effect_script_id", ":agent_id", ":instance_id", ":hit_damage", ":resource_count"),
			(try_end),
		(else_try),
			(set_trigger_result, 0),
		(try_end),
		]),

	("hit_iron_mine_effect",
	 [(store_script_param, ":agent_id", 1),
		(store_script_param, ":instance_id", 2),
		(store_script_param, ":hit_damage", 3),
		(store_script_param, ":resource_count", 4),

		(try_begin),
			(eq, ":resource_count", -1),
			(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_body_fall_big"),
			(particle_system_burst, "psys_dummy_smoke", pos1, 15),
		(else_try),
			(gt, ":resource_count", 0),
			(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_body_fall_small"),
			(particle_system_burst, "psys_dummy_smoke", pos1, 5),
		(else_try),
			(ge, ":hit_damage", 5),
			(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_mining_hit"),
		(else_try),
			(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_mining_scratch"),
		(try_end),
		]),

	("hit_bush_effect",
	 [(store_script_param, ":agent_id", 1),
		(store_script_param, ":instance_id", 2),
		(store_script_param, ":unused", 3),
		(store_script_param, ":resource_count", 4),

		(try_begin),
			(gt, ":resource_count", 0),
			(particle_system_burst, "psys_dummy_straw", pos1, 3),
		(try_end),
		(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_cut_wood_scratch"),
		]),

	("cf_hit_damage_resource", # server: handle damage to a resource that is not supposed to be hit
	 [(multiplayer_is_server),
		(store_script_param, ":instance_id", 1),
		(store_script_param, ":hit_damage", 2),
		(store_script_param, ":regrow_interval", 3),

		(scene_prop_slot_eq, ":instance_id", slot_scene_prop_state, scene_prop_state_active),
		(call_script, "script_scene_prop_damage_no_destroy", ":instance_id", ":hit_damage"),
		(try_begin),
			(le, reg2, min_scene_prop_hit_points),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_hidden),
			(prop_instance_get_starting_position, pos2, ":instance_id"),
			(position_move_z, pos2, -1000, 1),
			(prop_instance_animate_to_position, ":instance_id", pos2, 500),
			(call_script, "script_add_resource_to_regrow_list", ":instance_id", ":regrow_interval"),
		(try_end),
		]),

	("cf_use_resource", # server: handle resource scene props that are gathered by using
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid
		(store_script_param, ":resource_item_id", 3),
		(store_script_param, ":resource_hit_points", 4),
		(store_script_param, ":regrow_interval", 5),
		(store_script_param, ":sound_id", 6), # sound to play when a resource item is spawned

		(agent_get_troop_id, ":troop_id", ":agent_id"),
		(store_skill_level, ":labouring", "skl_labouring", ":troop_id"),
		(gt, ":labouring", 0),
		(agent_get_wielded_item, ":weapon", ":agent_id", 0),
		(eq, ":weapon", -1),
		(agent_get_wielded_item, ":shield", ":agent_id", 1),
		(eq, ":shield", -1),
		(store_mul, ":less_damage", ":resource_hit_points", ":labouring"),
		(val_div, ":less_damage", 19),
		(val_sub, ":resource_hit_points", ":less_damage"),
		(scene_prop_get_hit_points, ":hit_points", ":instance_id"),
		(store_sub, ":resulting_hit_points", ":hit_points", ":resource_hit_points"),
		(try_begin),
			(ge, ":resulting_hit_points", min_scene_prop_hit_points),
			(agent_get_position, pos1, ":agent_id"),
			(call_script, "script_set_random_spawn_position", 50),
			(spawn_item, ":resource_item_id", 0, "$g_spawn_item_prune_time"),
			(particle_system_burst, "psys_dummy_smoke", pos10, 5),
			(try_begin),
				(is_between, ":sound_id", 0, "snd_sounds_end"),
				(agent_play_sound, ":agent_id", ":sound_id"),
			(try_end),
		(else_try),
			(assign, ":resulting_hit_points", min_scene_prop_hit_points),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_hidden),
			(set_fixed_point_multiplier, 100),
			(prop_instance_get_starting_position, pos1, ":instance_id"),
			(position_move_z, pos1, -1000, 1),
			(prop_instance_animate_to_position, ":instance_id", pos1, 300),
			(call_script, "script_add_resource_to_regrow_list", ":instance_id", ":regrow_interval"),
		(try_end),
		(scene_prop_set_hit_points, ":instance_id", ":resulting_hit_points"),
		]),

	("cf_setup_field", # server: set up linked plants scene prop for a field grown resource
	 [(multiplayer_is_server),
		(neq, "$g_edit_scene", 1),
		(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":plant_scene_prop_id", 2),

		(set_fixed_point_multiplier, 100),
		(prop_instance_get_starting_position, pos1, ":instance_id"),
		(scene_prop_get_slot, ":height", ":instance_id", slot_scene_prop_height),
		(val_mul, ":height", -2),
		(position_move_z, pos1, ":height"),
		(set_spawn_position, pos1),
		(spawn_scene_prop, ":plant_scene_prop_id"),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_linked_scene_prop, reg0),
		(scene_prop_set_slot, reg0, slot_scene_prop_linked_scene_prop, ":instance_id"),
		(prop_instance_set_position, reg0, pos1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_hidden),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_next_resource_hp, min_scene_prop_hit_points),
		(scene_prop_set_hit_points, ":instance_id", min_scene_prop_hit_points),
		]),

	("cf_hit_field", # server: handle planting,  watering, harvesting, and spoiling a field resource; should be called from ti_on_scene_prop_hit
	 [(multiplayer_is_server),
		(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":hit_damage", 2),
		(store_script_param, ":hit_points_for_resource", 3),
		(store_script_param, ":resource_item_id", 4),
		(store_script_param, ":plant_item_id", 5),
		(store_script_param, ":tool_class", 6), # constants starting with item_class_
		(store_script_param, ":regrow_interval", 7),
		(set_fixed_point_multiplier, 1),
		(position_get_x, ":agent_id", pos2), # expects agent id in pos2.x from ti_on_scene_prop_hit
		(set_fixed_point_multiplier, 100),

		(scene_prop_get_slot, ":state", ":instance_id", slot_scene_prop_state),
		(agent_get_troop_id, ":troop_id", ":agent_id"),
		(store_skill_level, ":skill", "skl_labouring", ":troop_id"),
		(agent_get_wielded_item, ":wielded_item_id", ":agent_id", 0),
		(try_begin), # planting seeds
			(eq, ":wielded_item_id", ":plant_item_id"),
			(set_trigger_result, 0),
			(gt, ":skill", 0),
			(store_mission_timer_a, ":time"),
			(try_begin),
				(eq, ":state", scene_prop_state_hidden),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_regenerating),
				(store_div, ":hidden_time", ":regrow_interval", 2),
				(val_add, ":hidden_time", ":time"),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_state_time, ":hidden_time"),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_seeds, 1),
				(scene_prop_get_slot, ":full_hp", ":instance_id", slot_scene_prop_full_hit_points),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_next_resource_hp, ":full_hp"),
				(scene_prop_get_slot, ":plant_instance_id", ":instance_id", slot_scene_prop_linked_scene_prop),
				(prop_instance_get_starting_position, pos2, ":instance_id"),
				(store_mul, ":animate_time", ":regrow_interval", 100),
				(prop_instance_animate_to_position, ":plant_instance_id", pos2, ":animate_time"),
			(else_try),
				(eq, ":state", scene_prop_state_regenerating),
				(scene_prop_slot_ge, ":instance_id", slot_scene_prop_state_time, ":time"),
				(scene_prop_get_slot, ":seeds", ":instance_id", slot_scene_prop_seeds),
				(val_add, ":seeds", 1),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_seeds, ":seeds"),
			(try_end),
		(else_try), # watering
			(eq, ":wielded_item_id", "itm_water_bucket"),
			(set_trigger_result, 0),
			(call_script, "script_cf_agent_consume_item", ":agent_id", "itm_water_bucket", 1),
			(agent_equip_item, ":agent_id", "itm_bucket"),
			(agent_set_wielded_item, ":agent_id", "itm_bucket"),
			(scene_prop_get_slot, ":water", ":instance_id", slot_scene_prop_water),
			(val_add, ":water", 1),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_water, ":water"),
		(else_try), # prevent damaging an inactive field
			(neq, ":state", scene_prop_state_active),
			(neq, ":state", scene_prop_state_regenerating),
			(set_trigger_result, 0),
		(else_try), # harvest or spoil, depending on tool and skill
			(assign, ":original_damage", ":hit_damage"),
			(call_script, "script_scene_prop_damage_no_destroy", ":instance_id", ":hit_damage"),
			(assign, ":hit_damage", reg1),
			(assign, ":hit_points", reg2),
			(assign, ":destroyed", 0),
			(try_begin),
				(eq, ":state", scene_prop_state_active),
				(try_begin),
					(le, ":hit_points", min_scene_prop_hit_points),
					(assign, ":destroyed", 1),
				(try_end),
				(gt, ":skill", 0),
				(gt, ":wielded_item_id", -1),
				(item_slot_eq, ":wielded_item_id", slot_item_class, ":tool_class"),
				(try_begin),
					(call_script, "script_cf_check_drop_resource", ":instance_id", ":hit_points", ":hit_points_for_resource", 10),
					(assign, ":resource_count", reg0),
					(try_for_range, ":unused", 0, ":resource_count"),
						(call_script, "script_set_random_spawn_position", 50),
						(spawn_item, ":resource_item_id", 0, "$g_spawn_item_prune_time"),
						(position_rotate_x, pos10, 90),
						(position_move_z, pos10, 30, 1),
						(prop_instance_set_position, reg0, pos10),
						(particle_system_burst, "psys_dummy_smoke", pos10, 5),
					(try_end),
				(try_end),
			(else_try),
				(scene_prop_get_slot, ":resource_hp", ":instance_id", slot_scene_prop_next_resource_hp),
				(val_sub, ":resource_hp", ":original_damage"),
				(try_begin),
					(le, ":resource_hp", min_scene_prop_hit_points),
					(assign, ":resource_hp", min_scene_prop_hit_points),
					(assign, ":destroyed", 1),
				(try_end),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_next_resource_hp, ":resource_hp"),
			(try_end),
			(try_begin), # if destroyed, make the plants disappear
				(eq, ":destroyed", 1),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_seeds, 0),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_water, 0),
				(prop_instance_get_starting_position, pos2, ":instance_id"),
				(scene_prop_get_slot, ":height", ":instance_id", slot_scene_prop_height),
				(store_mul, ":animate_time", ":height", 2),
				(val_mul, ":height", -2),
				(position_move_z, pos2, ":height"),
				(scene_prop_get_slot, ":plant_instance_id", ":instance_id", slot_scene_prop_linked_scene_prop),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_active),
				(prop_instance_stop_animating, ":plant_instance_id"),
				(prop_instance_animate_to_position, ":plant_instance_id", pos2, ":animate_time"),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_hidden),
			(try_end),
		(try_end),
		]),

	("cf_field_animation_finished", # server: set up the field for harvesting after the growing animation is finished
	 [(store_script_param, ":plant_instance_id", 1), # must be valid
		(store_script_param, ":optimum_seeds", 2),
		(store_script_param, ":optimum_water", 3),

		(scene_prop_get_slot, ":instance_id", ":plant_instance_id", slot_scene_prop_linked_scene_prop),
		(gt, ":instance_id", 0),
		(scene_prop_get_slot, ":state", ":instance_id", slot_scene_prop_state),
		(try_begin),
			(eq, ":state", scene_prop_state_regenerating),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_active),
			(scene_prop_get_slot, ":full_hit_points", ":instance_id", slot_scene_prop_full_hit_points),
			(scene_prop_get_slot, ":resource_hit_points", ":instance_id", slot_scene_prop_next_resource_hp),
			(store_sub, ":damage", ":full_hit_points", ":resource_hit_points"),
			(scene_prop_get_slot, ":seeds", ":instance_id", slot_scene_prop_seeds),
			(store_sub, ":seed_damage", ":optimum_seeds", ":seeds"),
			(try_begin),
				(gt, ":seed_damage", 0),
				(val_mul, ":seed_damage", ":full_hit_points"),
				(val_div, ":seed_damage", ":optimum_seeds"),
				(val_add, ":damage", ":seed_damage"),
			(try_end),
			(scene_prop_get_slot, ":water", ":instance_id", slot_scene_prop_water),
			(store_sub, ":water_damage", ":optimum_water", ":water"),
			(try_begin),
				(gt, ":water_damage", 0),
				(val_mul, ":water_damage", ":full_hit_points"),
				(val_div, ":water_damage", ":optimum_water"),
				(val_div, ":water_damage", 4),
				(val_add, ":damage", ":water_damage"),
			(try_end),
			(store_sub, ":hit_points", ":full_hit_points", ":damage"),
			(val_max, ":hit_points", min_scene_prop_hit_points),
			(scene_prop_set_hit_points, ":instance_id", ":hit_points"),
			(val_sub, ":hit_points", 50),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_next_resource_hp, ":hit_points"),
		(else_try),
			(eq, ":state", scene_prop_state_destroyed),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_hidden),
		(try_end),
		]),

	("cf_hit_vine", # server: handle hitting a vine grown resource; should be called from ti_on_scene_prop_hit
	 [(multiplayer_is_server),
		(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":hit_damage", 2),
		(store_script_param, ":tool_class", 3), # constants starting with item_class_
		(store_script_param, ":regrow_interval", 4),

		(scene_prop_get_slot, ":state", ":instance_id", slot_scene_prop_state),
		(try_begin),
			(eq, ":state", scene_prop_state_active),
			(call_script, "script_scene_prop_adjust_hit", ":instance_id", ":hit_damage", 1, ":tool_class", "skl_labouring", 21),
			(assign, ":agent_id", reg0),
			(assign, ":hit_damage", reg1),
			(assign, ":hit_points", reg2),
			(agent_get_wielded_item, ":wielded_item", ":agent_id", 0),
			(try_begin),
				(gt, ":wielded_item", -1),
				(neg|item_slot_eq, ":wielded_item", slot_item_class, ":tool_class"),
				(scene_prop_get_slot, ":damaged_hit_points", ":instance_id", slot_scene_prop_next_resource_hp),
				(val_sub, ":damaged_hit_points", ":hit_damage"),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_next_resource_hp, ":damaged_hit_points"),
			(try_end),
			(try_begin),
				(le, ":hit_points", min_scene_prop_hit_points),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_hidden),
				(call_script, "script_add_resource_to_regrow_list", ":instance_id", ":regrow_interval"),
			(try_end),
		(else_try),
			(set_fixed_point_multiplier, 1),
			(position_get_x, ":agent_id", pos2), # expects agent id in pos2.x from ti_on_scene_prop_hit
			(set_fixed_point_multiplier, 100),
			(set_trigger_result, 0),
			(assign, ":hit_damage", 0),
		(try_end),
		(try_begin),
			(ge, ":hit_damage", 5),
			(particle_system_burst, "psys_dummy_straw", pos1, 3),
			(particle_system_burst, "psys_grape_leaf", pos1, 1),
		(else_try),
			(particle_system_burst, "psys_dummy_straw", pos1, 1),
		(try_end),
		(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_cut_wood_scratch"),
		]),

	("regrow_vine", # server: resource regrowing script to spawn vine fruit items
	 [(store_script_param, ":instance_id", 1), # must be valid

		(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_active),
		(scene_prop_get_slot, ":full_hit_points", ":instance_id", slot_scene_prop_full_hit_points),
		(scene_prop_set_hit_points, ":instance_id", ":full_hit_points"),
		(scene_prop_get_slot, ":damaged_hit_points", ":instance_id", slot_scene_prop_next_resource_hp),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_next_resource_hp, ":full_hit_points"),
		(scene_prop_get_slot, ":resource_item_id", ":instance_id", slot_scene_prop_resource_item_id),
		(scene_prop_get_slot, ":max_resources", ":instance_id", slot_scene_prop_seeds),
		(scene_prop_get_slot, ":length", ":instance_id", slot_scene_prop_length),
		(scene_prop_get_slot, ":height", ":instance_id", slot_scene_prop_height),
		(store_add, ":max_height", ":height", 50),
		(prop_instance_get_position, pos1, ":instance_id"),
		(val_max, ":damaged_hit_points", 0),
		(store_mul, ":resources", ":damaged_hit_points", ":max_resources"),
		(val_div, ":resources", ":full_hit_points"),
		(store_div, ":resource_count", ":resources", 2),
		(store_random_in_range, ":resource_count", ":resource_count", ":resources"),
		(set_fixed_point_multiplier, 100),
		(try_for_range, ":unused", 0, ":resource_count"),
			(copy_position, pos2, pos1),
			(store_random_in_range, ":x_offset", 50, ":length"),
			(position_move_x, pos2, ":x_offset"),
			(store_random_in_range, ":y_offset", -50, 51),
			(position_move_y, pos2, ":y_offset"),
			(store_random_in_range, ":z_offset", ":height", ":max_height"),
			(position_move_z, pos2, ":z_offset"),
			(position_rotate_x, pos2, 90),
			(set_spawn_position, pos2),
			(spawn_item, ":resource_item_id", 0, "$g_spawn_item_prune_time"),
			(prop_instance_set_position, reg0, pos2),
		(try_end),
		]),

	("setup_linked_scene_props", # server, edit mode: called at mission start to find necessary links for certain scene prop kinds
	 [(store_script_param, ":scene_prop_id", 1),

		(scene_prop_get_num_instances, ":num_instances", ":scene_prop_id"),
		(try_for_range, ":begin_scene_prop_no", 0, ":num_instances"), # iterate over all scene props of the specified kind
			(scene_prop_get_instance, ":begin_instance_id", ":scene_prop_id", ":begin_scene_prop_no"),
			(scene_prop_slot_eq, ":begin_instance_id", slot_scene_prop_linked_scene_prop, 0),
			(prop_instance_get_variation_id_2, ":begin_var_2", ":begin_instance_id"),
			(prop_instance_get_position, pos1, ":begin_instance_id"),
			(try_for_range, ":linked_scene_prop_no", 0, linked_scene_prop_slot_count), # iterate over all scene prop kinds required to link
				(store_add, ":linked_scene_prop_param_no", ":linked_scene_prop_no", 2),
				(store_script_param, ":linked_scene_prop_id", ":linked_scene_prop_param_no"),
				(gt, ":linked_scene_prop_id", -1),
				(store_add, ":linked_scene_prop_slot", slot_scene_prop_linked_scene_prop, ":linked_scene_prop_no"),
				(assign, ":nearest_instance_id", -1),
				(assign, ":nearest_distance", -1),
				(scene_prop_get_num_instances, ":num_check_instances", ":linked_scene_prop_id"),
				(try_for_range, ":check_scene_prop_no", 0, ":num_check_instances"), # iterate over all of the required scene prop kind, finding the nearest not already linked
					(scene_prop_get_instance, ":check_instance_id", ":linked_scene_prop_id", ":check_scene_prop_no"),
					(neq, ":check_instance_id", ":begin_instance_id"),
					(prop_instance_get_variation_id_2, ":check_var_2", ":check_instance_id"),
					(eq, ":check_var_2", ":begin_var_2"), # match scene editor value 2 to narrow down the search
					(scene_prop_slot_eq, ":check_instance_id", slot_scene_prop_linked_scene_prop, 0),
					(prop_instance_get_position, pos2, ":check_instance_id"),
					(get_sq_distance_between_positions, ":check_distance", pos1, pos2),
					(this_or_next|eq, ":nearest_distance", -1),
					(lt, ":check_distance", ":nearest_distance"),
					(assign, ":nearest_distance", ":check_distance"),
					(assign, ":nearest_instance_id", ":check_instance_id"),
				(try_end),
				(scene_prop_set_slot, ":begin_instance_id", ":linked_scene_prop_slot", ":nearest_instance_id"),
				(try_begin), # success
					(gt, ":nearest_instance_id", -1),
					(scene_prop_set_slot, ":nearest_instance_id", slot_scene_prop_linked_scene_prop, ":begin_instance_id"),
				(else_try), # failure to find a necessary linked prop
					(multiplayer_is_server),
					(assign, reg10, ":begin_instance_id"),
					(prop_instance_get_scene_prop_kind, reg11, ":begin_instance_id"),
					(assign, reg12, ":linked_scene_prop_id"),
					(assign, reg13, ":begin_var_2"),
					(display_message, "str_error_unable_to_find_link_scene_prop"),
					(try_begin),
						(eq, "$g_edit_scene", 1),
						(troop_get_slot, ":count", "trp_removed_scene_props", slot_array_count),
						(val_add, ":count", 1),
						(troop_set_slot, "trp_removed_scene_props", slot_array_count, ":count"),
						(troop_set_slot, "trp_removed_scene_props", ":count", ":begin_instance_id"),
					(try_end),
				(try_end),
			(try_end),
		(try_end),
		]),

	("setup_all_linked_scene_props", []), # generated to run the above script for each scene prop type that needs linking to other types
	("setup_scene_props_after_mission_start", []), # generated to call setup scripts for scene props after the mission has finished loading (after ti_on_scene_prop_init)

	("cf_agent_pick_lock", # server: calculate whether an agent picks a lock successfully, based on skill, tool, and random chance
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":probablity_multiplier", 2), # 100 means a 1% chance at looting level 1, up to 10000 for 100% success rate

		(assign, reg0, 0),
		(agent_get_wielded_item, ":wielded_item_id", ":agent_id", 0),
		(gt, ":wielded_item_id", -1),
		(item_slot_eq, ":wielded_item_id", slot_item_class, item_class_lock_pick),
		(agent_get_troop_id, ":troop_id", ":agent_id"),
		(store_skill_level, ":looting", "skl_looting", ":troop_id"),
		(gt, ":looting", 0),
		(assign, reg0, ":looting"),
		(try_begin),
			(eq, ":wielded_item_id", "itm_admin_lock_pick"),
			(agent_get_troop_id, ":troop_id", ":agent_id"),
			(eq, ":troop_id", "trp_godlike_hero"),
			(assign, ":random", 0),
		(else_try),
			(val_max, ":probablity_multiplier", 1),
			(val_mul, ":looting", ":probablity_multiplier"),
			(store_random_in_range, ":random", 0, 10000),
		(try_end),
		(try_begin),
			(ge, ":random", ":looting"),
			(agent_play_sound, ":agent_id", "snd_pick_lock_fail"),
		(try_end),
		(lt, ":random", ":looting"),
		]),

	("cf_use_teleport_door", # server: handle agents using a door which teleports to another linked door
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid
		(store_script_param, ":x_offset", 3),
		(store_script_param, ":y_offset", 4), # position offset relative to the linked door that the agent is moved to
		(store_script_param, ":z_offset", 5),
		(store_script_param, ":is_pickable", 6),

		(scene_prop_get_slot, ":linked_door_instance_id", ":instance_id", slot_scene_prop_linked_scene_prop),
		(gt, ":linked_door_instance_id", 0),
		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(player_get_slot, ":player_faction_id", ":player_id", slot_player_faction_id),
		(call_script, "script_scene_prop_get_owning_faction", ":instance_id"),
		(assign, ":faction_id", reg0),
		(assign, ":fail", 0),
		(try_begin),
			(eq, ":faction_id", "fac_commoners"),
		#GGG:fix outlaw
		(else_try),
			(eq, ":faction_id", ":player_faction_id"),
			(eq, ":player_faction_id", "fac_outlaws"),
			(player_set_slot, ":player_id", slot_player_has_faction_door_key, 1),
			(try_begin),
				(scene_prop_slot_eq, ":instance_id", slot_scene_prop_unlocked, 1),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_unlocked, 0),
				(scene_prop_set_slot, ":linked_door_instance_id", slot_scene_prop_unlocked, 0),
				(agent_play_sound, ":agent_id", "snd_lock"),
			(try_end),
		#
		(else_try),
			(eq, ":faction_id", ":player_faction_id"),
			(player_slot_eq, ":player_id", slot_player_has_faction_door_key, 1),
			(try_begin),
				(scene_prop_slot_eq, ":instance_id", slot_scene_prop_unlocked, 1),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_unlocked, 0),
				(scene_prop_set_slot, ":linked_door_instance_id", slot_scene_prop_unlocked, 0),
				(agent_play_sound, ":agent_id", "snd_lock"),
			(try_end),
		(else_try),
			(scene_prop_slot_eq, ":instance_id", slot_scene_prop_unlocked, 1),
		(else_try),
			(assign, reg0, 0),
			(eq, ":is_pickable", 1),
			(call_script, "script_cf_agent_pick_lock", ":agent_id", 100),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_unlocked, 1),
			(scene_prop_set_slot, ":linked_door_instance_id", slot_scene_prop_unlocked, 1),
		(agent_get_player_id, ":player_id", ":agent_id"),
		(str_store_player_username, s1, ":player_id"),
		(str_store_faction_name, s2, ":faction_id"),
		(server_add_message_to_log, "@{s1} pick locked a door owned by: {s2}"),
		(else_try),
			(assign, ":fail", 1),
			(gt, reg0, 0),
		(else_try),
			(multiplayer_send_3_int_to_player, ":player_id", server_event_preset_message, "str_door_locked_by_s1", preset_message_faction|preset_message_fail_sound, ":faction_id"),
		(try_end),
		(eq, ":fail", 0),
		(prop_instance_get_position, pos1, ":linked_door_instance_id"),
		(position_move_x, pos1, ":x_offset"),
		(position_move_y, pos1, ":y_offset"),
		(position_move_z, pos1, ":z_offset"),
		(try_begin),
			(eq, reg98, 1),
			(call_script, "script_cf_teleport_agent_to_pos", ":agent_id", pos1), #if reg98 == 1, tp horse as well..
		(else_try),
			(agent_set_position, ":agent_id", pos1),
		(try_end),
		]),

	("cf_lock_teleport_door", # server: lock a teleport door that has been picked if the player is in the owning faction and has the key permission
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid

		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(call_script, "script_scene_prop_get_owning_faction", ":instance_id"),
		(neq, reg0, "fac_commoners"),
		(assign, ":faction_id", reg0),
		(assign, ":fail", 1),
		(try_begin),
			(scene_prop_slot_eq, ":instance_id", slot_scene_prop_unlocked, 0),
			(agent_play_sound, ":agent_id", "snd_pick_lock_fail"),
		(else_try),
			(player_slot_eq, ":player_id", slot_player_faction_id, ":faction_id"),
			(player_slot_eq, ":player_id", slot_player_has_faction_door_key, 1),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_unlocked, 0),
			(scene_prop_get_slot, ":linked_door_instance_id", ":instance_id", slot_scene_prop_linked_scene_prop),
			(try_begin),
				(gt, ":linked_door_instance_id", 0),
				(scene_prop_set_slot, ":linked_door_instance_id", slot_scene_prop_unlocked, 0),
			(try_end),
			(agent_play_sound, ":agent_id", "snd_lock"),
			(assign, ":fail", 0),
		(try_end),
		(eq, ":fail", 0),
		]),

	("cf_agent_consume_items", # server: handle checking for and removing 4 items carried by the agent, only making changes if successful; reg1 - reg4 = the items removed, in slot order
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":item_1_id", 2),
		(store_script_param, ":item_2_id", 3), # pass -1 to any of these to check for less items
		(store_script_param, ":item_3_id", 4),
		(store_script_param, ":item_4_id", 5),

		(assign, ":item_1_slot", -1),
		(assign, ":item_2_slot", -1),
		(assign, ":item_3_slot", -1),
		(assign, ":item_4_slot", -1),
		(try_for_range, ":equip_slot", ek_item_0, ek_item_3 + 1),
			(agent_get_item_slot, ":item_id", ":agent_id", ":equip_slot"),
			(ge, ":item_id", all_items_begin),
			(store_add, ":offset_slot", ":equip_slot", 1),
			(try_begin),
				(eq, ":item_id", ":item_1_id"),
				(eq, ":item_1_slot", -1),
				(assign, ":item_1_slot", ":offset_slot"),
			(else_try),
				(eq, ":item_id", ":item_2_id"),
				(eq, ":item_2_slot", -1),
				(assign, ":item_2_slot", ":offset_slot"),
			(else_try),
				(eq, ":item_id", ":item_3_id"),
				(eq, ":item_3_slot", -1),
				(assign, ":item_3_slot", ":offset_slot"),
			(else_try),
				(eq, ":item_id", ":item_4_id"),
				(eq, ":item_4_slot", -1),
				(assign, ":item_4_slot", ":offset_slot"),
			(try_end),
		(try_end),
		(this_or_next|lt, ":item_1_id", all_items_begin),
		(gt, ":item_1_slot", -1),
		(this_or_next|lt, ":item_2_id", all_items_begin),
		(gt, ":item_2_slot", -1),
		(this_or_next|lt, ":item_3_id", all_items_begin),
		(gt, ":item_3_slot", -1),
		(this_or_next|lt, ":item_4_id", all_items_begin),
		(gt, ":item_4_slot", -1),
		(try_begin),
			(gt, ":item_1_slot", -1),
			(agent_unequip_item, ":agent_id", ":item_1_id", ":item_1_slot"),
		(try_end),
		(try_begin),
			(gt, ":item_2_slot", -1),
			(agent_unequip_item, ":agent_id", ":item_2_id", ":item_2_slot"),
		(try_end),
		(try_begin),
			(gt, ":item_3_slot", -1),
			(agent_unequip_item, ":agent_id", ":item_3_id", ":item_3_slot"),
		(try_end),
		(try_begin),
			(gt, ":item_4_slot", -1),
			(agent_unequip_item, ":agent_id", ":item_4_id", ":item_4_slot"),
		(try_end),
		(assign, reg1, ":item_1_slot"),
		(assign, reg2, ":item_2_slot"),
		(assign, reg3, ":item_3_slot"),
		(assign, reg4, ":item_4_slot"),
		]),

	("cf_agent_consume_resource", # server: handle consuming any items carried by the agent of a specified item class, up to a maximum resource amount required; reg0 = amount found
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":resource_class", 2), # constants starting with item_class_
		(store_script_param, ":maximum_required", 3), # don't consume more resource items if this amount is reached

		(assign, ":amount_found", 0),
		(assign, ":loop_end", ek_item_3 + 1),
		(try_for_range, ":equip_slot", ek_item_0, ":loop_end"),
			(agent_get_item_slot, ":item_id", ":agent_id", ":equip_slot"),
			(ge, ":item_id", all_items_begin),
			(item_slot_eq, ":item_id", slot_item_class, ":resource_class"),
			(item_get_slot, ":item_amount", ":item_id", slot_item_resource_amount),
			(gt, ":item_amount", 0),
			(val_add, ":amount_found", ":item_amount"),
			(store_add, ":offset_slot", ":equip_slot", 1),
			(agent_unequip_item, ":agent_id", ":item_id", ":offset_slot"),
			(ge, ":amount_found", ":maximum_required"),
			(assign, ":loop_end", -1),
		(try_end),
		(assign, reg0, ":amount_found"),
		(gt, ":amount_found", 0),
		]),

	("cf_agent_consume_item", # server: handle consuming any number of a specific item carried by the agent; reg0 = last equip slot consumed from, numbered 1 - 4 rather than 0 - 3
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":item_id", 2),
		(store_script_param, ":count", 3), # 1 - 4 items to try consume

		(agent_has_item_equipped, ":agent_id", ":item_id"),
		(agent_get_wielded_item, ":wielded_item_id", ":agent_id", 0),
		(item_get_type, ":item_type", ":item_id"),
		(try_begin),
			(neq, ":item_type", itp_type_arrows),
			(neq, ":item_type", itp_type_bolts),
			(neq, ":item_type", itp_type_thrown),
			(assign, ":check_max_ammo", 0),
		(else_try),
			(item_get_slot, ":check_max_ammo", ":item_id", slot_item_max_ammo),
		(try_end),
		(assign, ":found", 0),
		(assign, ":loop_end", ek_item_3 + 1),
		(try_for_range, ":equip_slot", ek_item_0, ":loop_end"),
			(agent_get_item_slot, ":equip_item_id", ":agent_id", ":equip_slot"),
			(eq, ":equip_item_id", ":item_id"),
			(try_begin), # for ammo items, require full stacks for consuming
				(gt, ":check_max_ammo", 0),
				(agent_get_ammo_for_slot, ":ammo", ":agent_id", ":equip_slot"),
				(lt, ":ammo", ":check_max_ammo"),
			(else_try),
				(store_add, ":offset_slot", ":equip_slot", 1), # agent_get_item_slot numbered 0 - 3 = agent_unequip_item numbered 1 - 4
				(troop_set_slot, "trp_temp_array", ":found", ":offset_slot"), # add items to a list for removing if enough found
				(val_add, ":found", 1),
				(ge, ":found", ":count"),
				(assign, ":loop_end", -1),
			(try_end),
		(try_end),
		(ge, ":found", ":count"),
		(try_for_range, ":index", 0, ":count"),
			(troop_get_slot, ":offset_slot", "trp_temp_array", ":index"),
			(agent_unequip_item, ":agent_id", ":item_id", ":offset_slot"),
		(try_end),
		(try_begin),
			(eq, ":wielded_item_id", ":item_id"),
			(agent_set_wielded_item, ":agent_id", -1),
			(call_script, "script_agent_calculate_stat_modifiers_for_item", ":agent_id", ":item_id", 0, 1),
		(try_end),
		(assign, reg0, ":offset_slot"),
		]),

	("spawn_processed_resources", # server: spawn a row of items on the ground in front of the agent; overwrites pos1
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":processed_item_id", 2),
		(store_script_param, ":processed_item_count", 3),

		(agent_get_position, pos1, ":agent_id"),
		(position_set_z_to_ground_level, pos1),
		(position_move_y, pos1, 10),
		(try_begin),
			(gt, ":processed_item_count", 2),
			(position_move_x, pos1, -20),
		(try_end),
		(assign, ":column", 0),
		(try_for_range, ":unused", 0, ":processed_item_count"),
			(set_spawn_position, pos1),
			(spawn_item, ":processed_item_id", 0, "$g_spawn_item_prune_time"),
			(try_begin),
				(lt, ":column", 3),
				(position_move_x, pos1, 10),
				(val_add, ":column", 1),
			(else_try),
				(assign, ":column", 0),
				(position_move_y, pos1, 10),
				(position_move_x, pos1, -30),
			(try_end),
		(try_end),
		]),

])

# Generate common parts of resource processing server scripts. 'resource_class' is constants starting with item_class_.
# 'start_effect' allows the script to proceed even if the 'finished' parameter is not 1, to allow playing effects at the start.
# 'get_relative_pos' calculates the relative position of the agent to the scene prop, to allow different actions.
def generate_process_init(skill=None, level=1, resource_class=None, start_effect=True, get_relative_pos=False):
	operations = [(store_script_param, ":agent_id", 1)]
	if start_effect or get_relative_pos:
		operations.append((store_script_param, ":instance_id", 2))
	operations.append((store_script_param, ":finished", 3))
	if not start_effect:
		operations.append((eq, ":finished", 1))
	if skill is not None and level > 0:
		operations.extend([(agent_get_troop_id, ":troop_id", ":agent_id"),
			(store_skill_level, ":skill_level", skill, ":troop_id"),
			(ge, ":skill_level", level)])
	operations.extend([(agent_get_wielded_item, ":resource_item_id", ":agent_id", 0),
		(ge, ":resource_item_id", all_items_begin)])
	if resource_class is not None:
		if isinstance(resource_class, list):
			operations.extend([(this_or_next|item_slot_eq, ":resource_item_id", slot_item_class, rc) for rc in resource_class[:-1]])
			resource_class = resource_class[-1]
		operations.append((item_slot_eq, ":resource_item_id", slot_item_class, resource_class))
	if get_relative_pos:
		operations.extend([(set_fixed_point_multiplier, 100),
			(prop_instance_get_position, pos1, ":instance_id"),
			(agent_get_position, pos2, ":agent_id"),
			(position_transform_position_to_local, pos3, pos1, pos2),
			(position_get_y, ":relative_y_position", pos3)])
	return lazy.block(operations)

scripts.extend([

	("cf_process_wood",
	 [generate_process_init(skill="skl_engineer", level=1, resource_class=item_class_wood),

		(assign, ":processed_item_id", -1),
		(assign, ":processed_item_count", 1),
		(try_begin),
			(eq, ":resource_item_id", "itm_branch"),
			(assign, ":processed_item_id", "itm_wood_pole"),
		(else_try),
			(eq, ":resource_item_id", "itm_wood_pole"),
			(assign, ":processed_item_id", "itm_wood_pole_short"),
			(assign, ":processed_item_count", 2),
		(else_try),
			(eq, ":resource_item_id", "itm_wood_pole_short"),
			(assign, ":processed_item_id", "itm_stick"),
			(assign, ":processed_item_count", 2),
		(else_try),
			(eq, ":resource_item_id", "itm_wood_block"),
			(assign, ":processed_item_id", "itm_board"),
			(assign, ":processed_item_count", 4),
		(try_end),
		(neq, ":processed_item_id", -1),
		(try_begin),
			(eq, ":finished", 1),
			(call_script, "script_cf_agent_consume_item", ":agent_id", ":resource_item_id", 1),
			(call_script, "script_spawn_processed_resources", ":agent_id", ":processed_item_id", ":processed_item_count"),
		(else_try),
			(eq, ":finished", 0),
			(agent_play_sound, ":agent_id", "snd_saw_wood"),
			(prop_instance_get_position, pos1, ":instance_id"),
			(position_move_z, pos1, 50),
			(particle_system_burst, "psys_cut_wood", pos1, 100),
		(try_end),
		]),

	("cf_process_iron",
	 [generate_process_init(skill="skl_engineer", level=2, resource_class=[item_class_iron, item_class_precious], get_relative_pos=True),

		(assign, ":processed_item_id", -1),
		(assign, ":processed_item_count", 1),
		(assign, ":resource_item_count", 1),
		(try_begin),
			(eq, ":resource_item_id", "itm_iron_ore"),
			(assign, ":processed_item_count", 2),
			(assign, ":processed_item_id", "itm_iron_bar"),
		(else_try),
			(eq, ":resource_item_id", "itm_iron_ore_small"),
			(assign, ":processed_item_count", 2),
			(assign, ":processed_item_id", "itm_iron_bar_short"),
		(else_try),
			(eq, ":resource_item_id", "itm_gold_nugget"),
			(assign, ":processed_item_count", 1),
			(assign, ":resource_item_count", 4),
			(assign, ":processed_item_id", "itm_gold_bar"),
		(else_try),
			(eq, ":resource_item_id", "itm_silver_nugget"),
			(assign, ":processed_item_count", 1),
			(assign, ":resource_item_count", 4),
			(assign, ":processed_item_id", "itm_silver_bar"),
		(else_try),
			(ge, ":relative_y_position", 0),
			(assign, ":processed_item_count", 2),
			(try_begin),
				(eq, ":resource_item_id", "itm_iron_bar_short"),
				(assign, ":processed_item_id", "itm_iron_piece"),
			(else_try),
				(eq, ":resource_item_id", "itm_iron_bar"),
				(assign, ":processed_item_id", "itm_iron_bar_short"),
			(else_try),
				(eq, ":resource_item_id", "itm_iron_bar_long"),
				(assign, ":processed_item_id", "itm_iron_bar"),
			(try_end),
		(else_try),
			(assign, ":resource_item_count", 2),
			(eq, ":resource_item_id", "itm_iron_piece"),
			(assign, ":processed_item_id", "itm_iron_bar_short"),
		(else_try),
			(eq, ":resource_item_id", "itm_iron_bar_short"),
			(assign, ":processed_item_id", "itm_iron_bar"),
		(else_try),
			(eq, ":resource_item_id", "itm_iron_bar"),
			(assign, ":processed_item_id", "itm_iron_bar_long"),
		(try_end),
		(ge, ":processed_item_id", all_items_begin),
		(try_begin),
			(eq, ":finished", 1),
			(call_script, "script_cf_agent_consume_item", ":agent_id", ":resource_item_id", ":resource_item_count"),
			(call_script, "script_spawn_processed_resources", ":agent_id", ":processed_item_id", ":processed_item_count"),
		(else_try),
			(eq, ":finished", 0),
			(agent_play_sound, ":agent_id", "snd_blacksmith"),
			(prop_instance_get_position, pos1, ":instance_id"),
			(position_move_z, pos1, 100),
			(particle_system_burst, "psys_fireplace_fire_big", pos1, 100),
		(try_end),
		]),

	("cf_process_iron_divide_only",
	 [generate_process_init(skill="skl_engineer", level=2, resource_class=item_class_iron),

		(assign, ":processed_item_id", -1),
		(try_begin),
			(eq, ":resource_item_id", "itm_iron_bar_short"),
			(assign, ":processed_item_id", "itm_iron_piece"),
		(else_try),
			(eq, ":resource_item_id", "itm_iron_bar"),
			(assign, ":processed_item_id", "itm_iron_bar_short"),
		(else_try),
			(eq, ":resource_item_id", "itm_iron_bar_long"),
			(assign, ":processed_item_id", "itm_iron_bar"),
		(try_end),
		(ge, ":processed_item_id", all_items_begin),
		(try_begin),
			(eq, ":finished", 1),
			(call_script, "script_cf_agent_consume_item", ":agent_id", ":resource_item_id", 1),
			(call_script, "script_spawn_processed_resources", ":agent_id", ":processed_item_id", 2),
		(else_try),
			(eq, ":finished", 0),
			(agent_play_sound, ":agent_id", "snd_blacksmith"),
			(neq, ":instance_id", 0),
		(try_end),
		]),

	("cf_process_grind",
	 [generate_process_init(skill="skl_labouring", level=1, resource_class=item_class_food),

		(assign, ":processed_item_id", -1),
		(assign, ":processed_item_count", 1),
		(assign, ":resource_item_count", 1),
		(try_begin),
			(eq, ":resource_item_id", "itm_wheat_sheaf"),
			(assign, ":processed_item_id", "itm_flour_sack"),
			(try_begin),
				(ge, ":skill_level", 5),
				(assign, ":resource_item_count", 3),
			(else_try),
				(assign, ":resource_item_count", 4),
			(try_end),
		(try_end),
		(neq, ":processed_item_id", -1),
		(try_begin),
			(eq, ":finished", 1),
			(call_script, "script_cf_agent_consume_item", ":agent_id", ":resource_item_id", ":resource_item_count"),
			(call_script, "script_spawn_processed_resources", ":agent_id", ":processed_item_id", ":processed_item_count"),
		(else_try),
			(eq, ":finished", 0),
			(prop_instance_get_position, pos1, ":instance_id"),
			(particle_system_burst, "psys_dummy_straw", pos1, 50),
			(particle_system_burst, "psys_dummy_smoke", pos1, 10),
		(try_end),
		]),

	("cf_process_cook",
	 [generate_process_init(skill="skl_labouring", level=1, resource_class=item_class_food),

		(assign, ":resource_2_item_id", -1),
		(assign, ":resource_3_item_id", -1),
		(assign, ":resource_4_item_id", -1),
		(assign, ":processed_item_id", -1),
		(assign, ":processed_item_count", 1),
		(try_begin),
			(eq, ":resource_item_id", "itm_flour_sack"),
			(try_begin),
				(agent_has_item_equipped, ":agent_id", "itm_water_bucket"),
				(assign, ":resource_2_item_id", "itm_water_bucket"),
				(assign, ":processed_item_id", "itm_bread"),
			(else_try),
				(agent_has_item_equipped, ":agent_id", "itm_raw_meat"),
				(assign, ":resource_2_item_id", "itm_raw_meat"),
				(assign, ":processed_item_id", "itm_meat_pie"),
			(else_try),
				(agent_has_item_equipped, ":agent_id", "itm_salted_meat"),
				(assign, ":resource_2_item_id", "itm_salted_meat"),
				(assign, ":processed_item_id", "itm_meat_pie"),
			(else_try),
				(agent_has_item_equipped, ":agent_id", "itm_red_apple"),
				(assign, ":resource_2_item_id", "itm_red_apple"),
				(assign, ":resource_3_item_id", "itm_red_apple"),
				(assign, ":resource_4_item_id", "itm_red_apple"),
				(assign, ":processed_item_id", "itm_apple_pie"),
			(try_end),
			(try_begin),
				(ge, ":skill_level", 5),
				(assign, ":processed_item_count", 5),
			(else_try),
				(assign, ":processed_item_count", 4),
			(try_end),
		(else_try),
			(this_or_next|eq, ":resource_item_id", "itm_fish"),
			(eq, ":resource_item_id", "itm_salted_fish"),
			(assign, ":processed_item_id", "itm_cooked_fish"),
		(else_try),
			(this_or_next|eq, ":resource_item_id", "itm_raw_meat"),
			(eq, ":resource_item_id", "itm_salted_meat"),
			(assign, ":processed_item_id", "itm_cooked_meat"),
		(try_end),
		(neq, ":processed_item_id", -1),
		(try_begin),
			(eq, ":finished", 1),
			(call_script, "script_cf_agent_consume_items", ":agent_id", ":resource_item_id", ":resource_2_item_id", ":resource_3_item_id", ":resource_4_item_id"),
			(call_script, "script_spawn_processed_resources", ":agent_id", ":processed_item_id", ":processed_item_count"),
			(try_begin),
				(eq, ":resource_2_item_id", "itm_water_bucket"),
				(agent_equip_item, ":agent_id", "itm_bucket", reg2),
			(try_end),
		(else_try),
			(eq, ":finished", 0),
			(call_script, "script_scene_prop_play_sound", ":instance_id", "snd_fire"),
			(prop_instance_get_position, pos1, ":instance_id"),
			(copy_position, pos2, pos1),
			(position_move_z, pos1, 100),
			(position_move_y, pos1, -50),
			(particle_system_burst, "psys_cooking_smoke", pos1, 100),
			(particle_system_burst, "psys_fireplace_fire_small", pos2, 100),
		(try_end),
		]),

	("cf_process_press",
	 [generate_process_init(skill="skl_labouring", level=1, resource_class=item_class_food),

		(assign, ":processed_item_id", -1),
		(assign, ":processed_item_count", 1),
		(assign, ":resource_item_count", 1),
		(try_begin),
			(eq, ":resource_item_id", "itm_grapes"),
			(assign, ":processed_item_id", "itm_must_barrel"),
			(assign, ":resource_item_count", 3),
		(else_try),
			(eq, ":resource_item_id", "itm_must_barrel"),
			(assign, ":processed_item_id", "itm_wine_barrel"),
			(try_begin),
				(ge, ":skill_level", 5),
				(assign, ":resource_item_count", 2),
			(else_try),
				(assign, ":resource_item_count", 3),
			(try_end),
		(try_end),
		(neq, ":processed_item_id", -1),
		(try_begin),
			(eq, ":finished", 1),
			(call_script, "script_cf_agent_consume_item", ":agent_id", ":resource_item_id", ":resource_item_count"),
			(call_script, "script_spawn_processed_resources", ":agent_id", ":processed_item_id", ":processed_item_count"),
		(else_try),
			(eq, ":finished", 0),
			(prop_instance_get_position, pos1, ":instance_id"),
			(particle_system_burst, "psys_wine_press_fill", pos1, 1),
		(try_end),
		]),

	("cf_process_brew",
	 [generate_process_init(skill="skl_labouring", level=1, resource_class=item_class_food),

		(assign, ":processed_item_id", -1),
		(assign, ":processed_item_count", 1),
		(try_begin),
			(eq, ":resource_item_id", "itm_wheat_sheaf"),
			(agent_has_item_equipped, ":agent_id", "itm_water_bucket"),
			(assign, ":processed_item_id", "itm_beer_cask"),
			(try_begin),
				(ge, ":skill_level", 5),
				(assign, ":resource_item_count", 2),
			(else_try),
				(assign, ":resource_item_count", 3),
			(try_end),
			(try_begin),
				(eq, ":finished", 1),
				(call_script, "script_cf_agent_consume_item", ":agent_id", "itm_water_bucket", 1),
				(agent_equip_item, ":agent_id", "itm_bucket", reg0),
			(try_end),
		(try_end),
		(neq, ":processed_item_id", -1),
		(try_begin),
			(eq, ":finished", 1),
			(call_script, "script_cf_agent_consume_item", ":agent_id", ":resource_item_id", ":resource_item_count"),
			(call_script, "script_spawn_processed_resources", ":agent_id", ":processed_item_id", ":processed_item_count"),
		(else_try),
			(eq, ":finished", 0),
			(prop_instance_get_position, pos1, ":instance_id"),
			(position_move_x, pos1, -75),
			(position_move_y, pos1, -25),
			(position_move_z, pos1, 320),
			(particle_system_burst, "psys_brewing_steam", pos1, 100),
		(try_end),
		]),

	("cf_process_tavern",
	 [generate_process_init(resource_class=item_class_food, start_effect=False),

		(assign, ":processed_item_id", -1),
		(assign, ":resource_item_count", 1),
		(assign, ":processed_item_count", 1),
		(store_script_param, ":instance_id", 2),
		(prop_instance_get_position, pos1, ":instance_id"),
		(try_begin),
			(eq, ":resource_item_id", "itm_wine_barrel"),
			(assign, ":processed_item_count", 4),
			(assign, ":processed_item_id", "itm_wine_jar"),
			(position_move_z, pos1, 105),
			(position_rotate_x, pos1, 90),
		(else_try),
			(eq, ":resource_item_id", "itm_wine_jar"),
			(assign, ":resource_item_count", 4),
			(assign, ":processed_item_id", "itm_wine_barrel"),
			(position_move_z, pos1, 114),
		(else_try),
			(eq, ":resource_item_id", "itm_beer_cask"),
			(assign, ":processed_item_count", 4),
			(assign, ":processed_item_id", "itm_beer_jug"),
			(position_move_z, pos1, 120),
			(position_rotate_x, pos1, 90),
		(else_try),
			(eq, ":resource_item_id", "itm_beer_jug"),
			(assign, ":resource_item_count", 4),
			(assign, ":processed_item_id", "itm_beer_cask"),
			(position_move_z, pos1, 116),
		(try_end),
		(neq, ":processed_item_id", -1),
		(call_script, "script_cf_agent_consume_item", ":agent_id", ":resource_item_id", ":resource_item_count"),
		(store_div, ":move_x", ":processed_item_count", 2),
		(val_mul, ":move_x", -50),
		(position_move_x, pos1, ":move_x"),
		(try_for_range, ":unused", 0, ":processed_item_count"),
			(set_spawn_position, pos1),
			(spawn_item, ":processed_item_id", 0, "$g_spawn_item_prune_time"),
			(prop_instance_set_position, reg0, pos1),
			(position_move_x, pos1, 50),
		(try_end),
		]),

	("cf_process_preserve",
	 [generate_process_init(skill="skl_labouring", level=1, resource_class=item_class_food, start_effect=False),

		(assign, ":processed_item_id", -1),
		(try_begin),
			(eq, ":resource_item_id", "itm_fish"),
			(assign, ":processed_item_id", "itm_salted_fish"),
		(else_try),
			(eq, ":resource_item_id", "itm_raw_meat"),
			(assign, ":processed_item_id", "itm_salted_meat"),
		(else_try),
			(eq, ":resource_item_id", "itm_salt_sack"),
			(call_script, "script_cf_agent_consume_item", ":agent_id", "itm_salt_sack", 1),
			(call_script, "script_spawn_processed_resources", ":agent_id", "itm_salt", 8),
		(try_end),
		(neq, ":processed_item_id", -1),
		(call_script, "script_cf_agent_consume_items", ":agent_id", "itm_salt", ":resource_item_id", ":resource_item_id", ":resource_item_id"),
		(call_script, "script_spawn_processed_resources", ":agent_id", ":processed_item_id", 3),
		]),

	("cf_process_spin",
	 [generate_process_init(skill="skl_labouring", level=1, resource_class=item_class_cloth, start_effect=False),

		(assign, ":processed_item_id", -1),
		(assign, ":processed_item_count", 2),
		(try_begin),
			(eq, ":resource_item_id", "itm_flax_bundle"),
			(assign, ":processed_item_id", "itm_linen_thread"),
		(try_end),
		(neq, ":processed_item_id", -1),
		(call_script, "script_cf_agent_consume_item", ":agent_id", ":resource_item_id", 1),
		(call_script, "script_spawn_processed_resources", ":agent_id", ":processed_item_id", ":processed_item_count"),
		]),

	("cf_process_weave",
	 [generate_process_init(skill="skl_tailoring", level=1, resource_class=item_class_cloth, start_effect=False),

		(assign, ":processed_item_id", -1),
		(assign, ":processed_item_count", 1),
		(assign, ":resource_item_count", 1),
		(try_begin),
			(eq, ":resource_item_id", "itm_linen_thread"),
			(assign, ":processed_item_count", 2),
			(assign, ":processed_item_id", "itm_linen_cloth"),
		(else_try),
			(eq, ":resource_item_id", "itm_linen_cloth_small"),
			(assign, ":resource_item_count", 4),
			(assign, ":processed_item_id", "itm_linen_cloth"),
		(try_end),
		(neq, ":processed_item_id", -1),
		(call_script, "script_cf_agent_consume_item", ":agent_id", ":resource_item_id", ":resource_item_count"),
		(call_script, "script_spawn_processed_resources", ":agent_id", ":processed_item_id", ":processed_item_count"),
		]),

	("cf_process_cut",
	 [generate_process_init(resource_class=[item_class_cloth, item_class_leather], start_effect=False),

		(agent_get_troop_id, ":troop_id", ":agent_id"),
		(store_skill_level, ":tailoring", "skl_tailoring", ":troop_id"),
		(store_skill_level, ":engineer", "skl_engineer", ":troop_id"),
		(this_or_next|ge, ":tailoring", 1),
		(ge, ":engineer", 1),
		(assign, ":processed_item_id", -1),
		(assign, ":processed_item_count", 4),
		(assign, ":resource_item_count", 1),
		(try_begin),
			(eq, ":resource_item_id", "itm_linen_cloth"),
			(assign, ":processed_item_id", "itm_linen_cloth_small"),
		(else_try),
			(eq, ":resource_item_id", "itm_leather_roll"),
			(assign, ":processed_item_id", "itm_leather_piece"),
		(try_end),
		(neq, ":processed_item_id", -1),
		(call_script, "script_cf_agent_consume_item", ":agent_id", ":resource_item_id", ":resource_item_count"),
		(call_script, "script_spawn_processed_resources", ":agent_id", ":processed_item_id", ":processed_item_count"),
		]),

	("cf_process_leather",
	 [generate_process_init(skill="skl_labouring", level=1, start_effect=False),

		(eq, ":resource_item_id", "itm_raw_hide"),
		(call_script, "script_cf_agent_consume_item", ":agent_id", "itm_raw_hide", 1),
		(call_script, "script_spawn_processed_resources", ":agent_id", "itm_leather_roll", 2),
		]),

	#GGG:skin system
	("cf_process_dyeing",
	 [generate_process_init(skill="skl_labouring", level=5),

		(assign, ":resource_2_item_id", -1),
		(assign, ":resource_3_item_id", -1),
		(assign, ":resource_4_item_id", -1),
		(assign, ":processed_item_id", -1),
		(assign, ":processed_item_count", 1),
		(try_begin),
			(try_begin),
				(eq, ":resource_item_id", "itm_voulge_duplicate"),
				(assign, ":processed_item_id", "itm_voulge_duplicate_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_long_bardiche"),
				(assign, ":processed_item_id", "itm_long_bardiche_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_great_long_bardiche"),
				(assign, ":processed_item_id", "itm_great_long_bardiche_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_shortened_military_scythe"),
				(assign, ":processed_item_id", "itm_shortened_military_scythe_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_great_bardiche"),
				(assign, ":processed_item_id", "itm_great_bardiche_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_two_handed_axe"),
				(assign, ":processed_item_id", "itm_two_handed_axe_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_two_handed_battle_axe"),
				(assign, ":processed_item_id", "itm_two_handed_battle_axe_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_shortened_voulge"),
				(assign, ":processed_item_id", "itm_shortened_voulge_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_bardiche"),
				(assign, ":processed_item_id", "itm_bardiche_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_throwing_axes"),
				(assign, ":processed_item_id", "itm_throwing_axes_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_heavy_throwing_axes"),
				(assign, ":processed_item_id", "itm_heavy_throwing_axes_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_sword_viking_a_long"),
				(store_random_in_range, ":random", 0, 2),
				(try_begin),
					(eq, ":random", 0),
					(assign, ":processed_item_id", "itm_sword_viking_a_long_skin"),
				(else_try),
					(eq, ":random", 1),
					(assign, ":processed_item_id", "itm_sword_viking_a_long_skin1"),
				(try_end),
			(else_try),
				(eq, ":resource_item_id", "itm_sword_viking_3_small"),
				(assign, ":processed_item_id", "itm_sword_viking_3_small_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_sword_medieval_c_small"),
				(assign, ":processed_item_id", "itm_sword_medieval_c_small_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_sword_viking_2"),
				(store_random_in_range, ":random", 0, 2),
				(try_begin),
					(eq, ":random", 0),
					(assign, ":processed_item_id", "itm_sword_viking_2_skin"),
				(else_try),
					(eq, ":random", 1),
					(assign, ":processed_item_id", "itm_sword_viking_2_skin1"),
				(try_end),
			(else_try),
				(eq, ":resource_item_id", "itm_nordic_sword"),
				(assign, ":processed_item_id", "itm_nordic_sword_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_sword"),
				(assign, ":processed_item_id", "itm_sword_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_arabian_sword_d"),
				(assign, ":processed_item_id", "itm_arabian_sword_d_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_curved_sword"),
				(assign, ":processed_item_id", "itm_curved_sword_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_sword_viking_b_small"),
				(assign, ":processed_item_id", "itm_sword_viking_b_small_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_sword_viking_c"),
				(assign, ":processed_item_id", "itm_sword_viking_c_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_sword_viking_c_long"),
				(assign, ":processed_item_id", "itm_sword_viking_c_long_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_sword_two_handed_b"),
				(assign, ":processed_item_id", "itm_sword_two_handed_b_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_sword_two_handed_a"),
				(store_random_in_range, ":random", 0, 2),
				(try_begin),
					(eq, ":random", 0),
					(assign, ":processed_item_id", "itm_sword_two_handed_a_skin"),
				(else_try),
					(eq, ":random", 1),
					(assign, ":processed_item_id", "itm_sword_two_handed_a_skin1"),
				(try_end),
			(else_try),
				(eq, ":resource_item_id", "itm_sword_medieval_a"),
				(assign, ":processed_item_id", "itm_sword_medieval_a_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_sword_medieval_a_long"),
				(assign, ":processed_item_id", "itm_sword_medieval_a_long_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_sword_medieval_b"),
				(store_random_in_range, ":random", 0, 2),
				(try_begin),
					(eq, ":random", 0),
					(assign, ":processed_item_id", "itm_sword_medieval_b_skin"),
				(else_try),
					(eq, ":random", 1),
					(assign, ":processed_item_id", "itm_sword_medieval_b_skin1"),
				(try_end),
			(else_try),
				(eq, ":resource_item_id", "itm_sword_medieval_b_small"),
				(assign, ":processed_item_id", "itm_sword_medieval_b_small_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_sword_medieval_d"),
				(assign, ":processed_item_id", "itm_sword_medieval_d_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_sword_medieval_d_long"),
				(assign, ":processed_item_id", "itm_sword_medieval_d_long_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_sword_medieval_e"),
				(store_random_in_range, ":random", 0, 2),
				(try_begin),
					(eq, ":random", 0),
					(assign, ":processed_item_id", "itm_sword_medieval_e_skin"),
				(else_try),
					(eq, ":random", 1),
					(assign, ":processed_item_id", "itm_sword_medieval_e_skin1"),
				(try_end),
			(else_try),
				(eq, ":resource_item_id", "itm_pike"),
				(assign, ":processed_item_id", "itm_pike_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_military_scythe"),
				(assign, ":processed_item_id", "itm_military_scythe_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_lance"),
				(assign, ":processed_item_id", "itm_lance_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_spear_e_3_25m"),
				(assign, ":processed_item_id", "itm_spear_e_3_25m_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_heavy_lance"),
				(assign, ":processed_item_id", "itm_heavy_lance_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_war_spear"),
				(assign, ":processed_item_id", "itm_war_spear_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_scimitar"),
				(assign, ":processed_item_id", "itm_scimitar_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_scimitar_b"),
				(assign, ":processed_item_id", "itm_scimitar_b_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_arabian_sword_a"),
				(assign, ":processed_item_id", "itm_arabian_sword_a_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_one_handed_battle_axe_a"),
				(assign, ":processed_item_id", "itm_one_handed_battle_axe_a_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_one_handed_war_axe_a"),
				(assign, ":processed_item_id", "itm_one_handed_war_axe_a_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_two_handed_cleaver"),
				(assign, ":processed_item_id", "itm_two_handed_cleaver_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_military_cleaver_b"),
				(assign, ":processed_item_id", "itm_military_cleaver_b_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_military_cleaver_c"),
				(assign, ":processed_item_id", "itm_military_cleaver_c_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_military_hammer"),
				(assign, ":processed_item_id", "itm_military_hammer_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_military_sickle"),
				(assign, ":processed_item_id", "itm_military_sickle_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_mace_2"),
				(assign, ":processed_item_id", "itm_mace_2_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_mace_3"),
				(assign, ":processed_item_id", "itm_mace_3_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_mace_4"),
				(assign, ":processed_item_id", "itm_mace_4_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_long_hafted_knobbed_mace"),
				(assign, ":processed_item_id", "itm_long_hafted_knobbed_mace_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_long_hafted_spiked_mace"),
				(assign, ":processed_item_id", "itm_long_hafted_spiked_mace_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_sarranid_two_handed_mace_1"),
				(assign, ":processed_item_id", "itm_sarranid_two_handed_mace_1_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_mace_small_d"),
				(assign, ":processed_item_id", "itm_mace_small_d_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_warhammer"),
				(assign, ":processed_item_id", "itm_warhammer_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_long_axe"),
				(assign, ":processed_item_id", "itm_long_axe_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_long_axe_b"),
				(assign, ":processed_item_id", "itm_long_axe_b_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_hafted_blade_a"),
				(assign, ":processed_item_id", "itm_hafted_blade_a_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_hafted_blade_b"),
				(assign, ":processed_item_id", "itm_hafted_blade_b_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_glaive"),
				(assign, ":processed_item_id", "itm_glaive_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_sword_khergit_1"),
				(store_random_in_range, ":random", 0, 2),
				(try_begin),
					(eq, ":random", 0),
					(assign, ":processed_item_id", "itm_sword_khergit_1_skin"),
				(else_try),
					(eq, ":random", 1),
					(assign, ":processed_item_id", "itm_sword_khergit_1_skin1"),
				(try_end),
			(else_try),
				(eq, ":resource_item_id", "itm_khergit_sword_c"),
				(assign, ":processed_item_id", "itm_khergit_sword_c_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_sword_khergit_3"),
				(store_random_in_range, ":random", 0, 2),
				(try_begin),
					(eq, ":random", 0),
					(assign, ":processed_item_id", "itm_sword_khergit_3_skin"),
				(else_try),
					(eq, ":random", 1),
					(assign, ":processed_item_id", "itm_sword_khergit_3_skin1"),
				(try_end),
			(else_try),
				(eq, ":resource_item_id", "itm_khergit_sword_d"),
				(store_random_in_range, ":random", 0, 2),
				(try_begin),
					(eq, ":random", 0),
					(assign, ":processed_item_id", "itm_khergit_sword_d_skin"),
				(else_try),
					(eq, ":random", 1),
					(assign, ":processed_item_id", "itm_khergit_sword_d_skin1"),
				(try_end),
			(else_try),
				(eq, ":resource_item_id", "itm_khergit_sword_two_handed_a"),
				(assign, ":processed_item_id", "itm_khergit_sword_two_handed_a_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_khergit_sword_two_handed_b"),
				(assign, ":processed_item_id", "itm_khergit_sword_two_handed_b_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_crossbow"),
				(store_random_in_range, ":random", 0, 2),
				(try_begin),
					(eq, ":random", 0),
					(assign, ":processed_item_id", "itm_crossbow_skin"),
				(else_try),
					(eq, ":random", 1),
					(assign, ":processed_item_id", "itm_crossbow_skin1"),
				(try_end),
			(else_try),
				(eq, ":resource_item_id", "itm_light_crossbow"),
				(assign, ":processed_item_id", "itm_light_crossbow_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_heavy_crossbow"),
				(assign, ":processed_item_id", "itm_heavy_crossbow_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_bec_de_corbin_a"),
				(assign, ":processed_item_id", "itm_bec_de_corbin_a_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_bastard_sword_a"),
				(store_random_in_range, ":random", 0, 3),
				(try_begin),
					(eq, ":random", 0),
					(assign, ":processed_item_id", "itm_bastard_sword_a_skin"),
				(else_try),
					(eq, ":random", 1),
					(assign, ":processed_item_id", "itm_bastard_sword_a_skin1"),
				(else_try),
					(eq, ":random", 2),
					(assign, ":processed_item_id", "itm_bastard_sword_a_skin2"),
				(try_end),
			(else_try),
				(eq, ":resource_item_id", "itm_bastard_sword_b"),
				(store_random_in_range, ":random", 0, 4),
				(try_begin),
					(eq, ":random", 0),
					(assign, ":processed_item_id", "itm_bastard_sword_b_skin"),
				(else_try),
					(eq, ":random", 1),
					(assign, ":processed_item_id", "itm_bastard_sword_b_skin1"),
				(else_try),
					(eq, ":random", 2),
					(assign, ":processed_item_id", "itm_bastard_sword_b_skin2"),
				(else_try),
					(eq, ":random", 3),
					(assign, ":processed_item_id", "itm_bastard_sword_b_skin3"),
				(try_end),
			(else_try),
				(eq, ":resource_item_id", "itm_awlpike_long"),
				(assign, ":processed_item_id", "itm_awlpike_long_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_bamboo_spear"),
				(assign, ":processed_item_id", "itm_bamboo_spear_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_double_axe"),
				(assign, ":processed_item_id", "itm_double_axe_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_short_bow"),
				(assign, ":processed_item_id", "itm_short_bow_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_hunting_bow"),
				(assign, ":processed_item_id", "itm_hunting_bow_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_war_bow"),
				(assign, ":processed_item_id", "itm_war_bow_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_long_bow"),
				(assign, ":processed_item_id", "itm_long_bow_skin"),
			(else_try),
				(eq, ":resource_item_id", "itm_strong_bow"),
				(store_random_in_range, ":random", 0, 2),
				(try_begin),
					(eq, ":random", 0),
					(assign, ":processed_item_id", "itm_strong_bow_skin"),
				(else_try),
					(eq, ":random", 1),
					(assign, ":processed_item_id", "itm_strong_bow_skin1"),
				(try_end),
			(else_try),
				(eq, ":resource_item_id", "itm_nomad_bow"),
				(store_random_in_range, ":random", 0, 2),
				(try_begin),
					(eq, ":random", 0),
					(assign, ":processed_item_id", "itm_nomad_bow_skin"),
				(else_try),
					(eq, ":random", 1),
					(assign, ":processed_item_id", "itm_nomad_bow_skin1"),
				(try_end),
			(else_try),
				(eq, ":resource_item_id", "itm_khergit_bow"),
				(store_random_in_range, ":random", 0, 2),
				(try_begin),
					(eq, ":random", 0),
					(assign, ":processed_item_id", "itm_khergit_bow_skin"),
				(else_try),
					(eq, ":random", 1),
					(assign, ":processed_item_id", "itm_khergit_bow_skin1"),
				(try_end),
			(try_end),

			(agent_has_item_equipped, ":agent_id", "itm_linen_cloth_small"),
			(assign, ":resource_2_item_id", "itm_linen_cloth_small"),
			(assign, ":resource_3_item_id", "itm_linen_cloth_small"),
			(assign, ":resource_4_item_id", "itm_linen_cloth_small"),
		(try_end),
		(neq, ":processed_item_id", -1),
		(try_begin),
			(eq, ":finished", 1),
			(call_script, "script_cf_agent_consume_items", ":agent_id", ":resource_item_id", ":resource_2_item_id", ":resource_3_item_id", ":resource_4_item_id"),
			(call_script, "script_spawn_processed_resources", ":agent_id", ":processed_item_id", ":processed_item_count"),
		(else_try),
			(eq, ":finished", 0),
			(call_script, "script_scene_prop_play_sound", ":instance_id", "snd_footstep_water"),
		(try_end),
		]),

	("cf_use_resource_stockpile", # server: handle players using a stockpile for buying and selling resources, not crafting
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # mist be valid

		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(scene_prop_get_slot, ":item_id", ":instance_id", slot_scene_prop_item_id),
		(is_between, ":item_id", all_items_begin, all_items_end),
		(scene_prop_get_slot, ":stock_count", ":instance_id", slot_scene_prop_stock_count),
		(agent_get_wielded_item, ":weapon_item_id", ":agent_id", 0),
		(agent_get_wielded_item, ":shield_item_id", ":agent_id", 1),
		(call_script, "script_scene_prop_get_gold_value", ":instance_id", ":item_id", 0),
		(assign, ":gold_value", reg0),
		(assign, ":fail", 0),
		(try_begin),
			(this_or_next|eq, ":weapon_item_id", ":item_id"),
			(eq, ":shield_item_id", ":item_id"),
			(prop_instance_get_variation_id_2, ":stock_limit", ":instance_id"),
			(val_div, ":stock_limit", 10),
			(val_mul, ":stock_limit", 100),
			(try_begin),
				(this_or_next|eq, "$g_game_type", "mt_quick_battle"),
				(this_or_next|eq, ":stock_limit", 0),
				(lt, ":stock_count", ":stock_limit"),
				(call_script, "script_cf_agent_consume_item", ":agent_id", ":item_id", 1),
				(assign, ":add_or_subtract", 1),
				(val_add, ":stock_count", 1),
			(else_try),
				(assign, ":fail", 1),
				(multiplayer_send_int_to_player, ":player_id", server_event_play_sound, "snd_failure"),
			(try_end),
		(else_try),
			(this_or_next|gt, ":stock_count", 0),
			(eq, "$g_game_type", "mt_quick_battle"),
			(call_script, "script_cf_check_enough_gold", ":player_id", ":gold_value"),
			(call_script, "script_spawn_processed_resources", ":agent_id", ":item_id", 1),
			(assign, ":add_or_subtract", -1),
			(val_sub, ":stock_count", 1),
		(else_try),
			(assign, ":fail", 1),
			(multiplayer_send_int_to_player, ":player_id", server_event_play_sound, "snd_failure"),
		(try_end),
		(eq, ":fail", 0),
		(try_begin),
			(neq, "$g_game_type", "mt_no_money"),
			(neq, "$g_game_type", "mt_feudalism"),
			(call_script, "script_calculate_stockpile_taxed_price", ":instance_id", ":gold_value"),
			(try_begin),
				(eq, ":add_or_subtract", 1),
				(assign, ":gold_value", reg0),
			(else_try),
				(eq, ":add_or_subtract", -1),
				(assign, ":tax_value", reg1),
				(call_script, "script_scene_prop_get_owning_faction", ":instance_id"),
				(call_script, "script_castle_receive_gold", reg1, ":tax_value", -1),
			(try_end),
			(call_script, "script_player_adjust_gold", ":player_id", ":gold_value", ":add_or_subtract"),
		(try_end),
		(try_begin),
			(neq, "$g_game_type", "mt_quick_battle"),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_stock_count, ":stock_count"),
			(multiplayer_send_3_int_to_player, ":player_id", server_event_scene_prop_set_slot, ":instance_id", slot_scene_prop_stock_count, ":stock_count"),
		(try_end),
		]),

	("calculate_stockpile_taxed_price", # for resource stockpiles, return the taxed price in reg0 and the tax amount in reg1, depending on stock targets and current count
	 [(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":gold_value", 2),

		(store_mul, ":tax_value", ":gold_value", castle_tax_gold_percentage),
		(try_begin),
			(scene_prop_slot_eq, ":instance_id", slot_scene_prop_is_resource_stockpile, 1),
			(scene_prop_get_slot, ":stock_count", ":instance_id", slot_scene_prop_stock_count),
			(prop_instance_get_variation_id_2, ":stock_target", ":instance_id"),
			(val_mod, ":stock_target", 10),
			(val_mul, ":stock_target", 10),
			(is_between, ":stock_count", 0, ":stock_target"),
			(val_mul, ":tax_value", ":stock_count"),
			(val_div, ":tax_value", ":stock_target"),
		(try_end),
		(val_div, ":tax_value", 100),
		(store_sub, reg0, ":gold_value", ":tax_value"),
		(assign, reg1, ":tax_value"),
		]),

	("cf_buy_sell_item_stockpile", # server: handle players using an item or horse stockpile for buying and selling
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid

		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(scene_prop_get_slot, ":item_id", ":instance_id", slot_scene_prop_item_id),
		(is_between, ":item_id", all_items_begin, all_items_end),
		(scene_prop_get_slot, ":stock_count", ":instance_id", slot_scene_prop_stock_count),
		(agent_get_wielded_item, ":weapon_item_id", ":agent_id", 0),
		(agent_get_wielded_item, ":shield_item_id", ":agent_id", 1),
		(item_get_type, ":item_type", ":item_id"),
		(assign, ":fail", 0),
		(try_begin), # if the item is wielded or worn, try selling it
			(this_or_next|eq, ":weapon_item_id", ":item_id"),
			(this_or_next|eq, ":shield_item_id", ":item_id"),
			(is_between, ":item_type", itp_type_head_armor, itp_type_hand_armor + 1),
			(call_script, "script_cf_sell_item", ":agent_id", ":instance_id"),
			(val_add, ":stock_count", 1),
		(else_try), # else try selling a horse
			(assign, reg0, 0),
			(eq, ":item_type", itp_type_horse),
			(call_script, "script_cf_sell_horse", ":agent_id", ":instance_id"),
			(val_add, ":stock_count", 1),
		(else_try), # if the horse selling didn't respond with a failure message and the weapon hand is empty, try buy
			(eq, reg0, 0),
			(this_or_next|gt, ":stock_count", 0),
			(eq, "$g_game_type", "mt_quick_battle"),
			(eq, ":weapon_item_id", -1),
			(call_script, "script_cf_buy_item", ":agent_id", ":instance_id"),
			(val_sub, ":stock_count", 1),
		(else_try),
			(eq, ":stock_count", 0),
			(assign, ":fail", 1),
			(multiplayer_send_int_to_player, ":player_id", server_event_play_sound, "snd_failure"),
		(try_end),
		(eq, ":fail", 0),
		(try_begin),
			(neq, "$g_game_type", "mt_quick_battle"),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_stock_count, ":stock_count"),
			(multiplayer_send_3_int_to_player, ":player_id", server_event_scene_prop_set_slot, ":instance_id", slot_scene_prop_stock_count, ":stock_count"),
		(try_end),
		]),

	("cf_craft_item_stockpile", # server: handle players crafting items at a stockpile
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid
		(store_script_param, ":skill_1_id", 3),
		(store_script_param, ":required_level_1", 4),
		(store_script_param, ":skill_2_id", 5), # an optional alternate skill and level to craft with
		(store_script_param, ":required_level_2", 6),
		(store_script_param, ":resource_1_item_id", 7),
		(store_script_param, ":resource_2_item_id", 8),
		(store_script_param, ":resource_3_item_id", 9),
		(store_script_param, ":resource_4_item_id", 10),

		(neq, "$g_game_type", "mt_quick_battle"),
		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(scene_prop_get_slot, ":item_id", ":instance_id", slot_scene_prop_item_id),
		(is_between, ":item_id", all_items_begin, all_items_end),
		(is_between, ":resource_1_item_id", all_items_begin, all_items_end),
		(scene_prop_get_slot, ":stock_count", ":instance_id", slot_scene_prop_stock_count),
		(assign, ":error_string_id", 0),
		(try_begin),
			(assign, ":average_level", ":required_level_1"),
			(try_begin),
				(le, ":skill_1_id", -1),
			(else_try),
				(agent_get_troop_id, ":troop_id", ":agent_id"),
				(store_skill_level, ":skill_1_level", ":skill_1_id", ":troop_id"),
				(ge, ":skill_1_level", ":required_level_1"),
			(else_try),
				(gt, ":skill_2_id", -1),
				(store_skill_level, ":skill_2_level", ":skill_2_id", ":troop_id"),
				(ge, ":skill_2_level", ":required_level_2"),
				(store_add, ":average_level", ":required_level_1", ":required_level_2"),
				(val_div, ":average_level", 2),
			(else_try),
				(assign, ":error_string_id", "str_craft_not_skilled"),
			(try_end),
			(eq, ":error_string_id", 0),
			(assign, ":error_string_id", "str_craft_wrong_resources"),
			(call_script, "script_cf_agent_consume_items", ":agent_id", ":resource_1_item_id", ":resource_2_item_id", ":resource_3_item_id", ":resource_4_item_id"),
			(call_script, "script_scene_prop_get_item_crafting_refund_reward", ":instance_id"),
			(call_script, "script_player_adjust_gold", ":player_id", reg0, 1),
			(val_add, ":stock_count", 1),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_stock_count, ":stock_count"),
			(multiplayer_send_3_int_to_player, ":player_id", server_event_scene_prop_set_slot, ":instance_id", slot_scene_prop_stock_count, ":stock_count"),
		(else_try),
			(gt, ":error_string_id", 0),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_preset_message, ":error_string_id", preset_message_yellow|preset_message_fail_sound),
		(try_end),
		(eq, ":error_string_id", 0),
		]),

	("scene_prop_get_item_crafting_refund_reward", # reg0 = the total money given, reg1 = the local cost of all resources, reg2 = the variable extra reward
	 [(store_script_param, ":instance_id", 1), # must be valid

		(prop_instance_get_variation_id_2, ":design_target_stock_count", ":instance_id"),
		(store_mod, ":is_odd", ":design_target_stock_count", 2),
		(scene_prop_get_slot, ":stock_count", ":instance_id", slot_scene_prop_stock_count),
		(store_sub, ":stock_count_factor", ":design_target_stock_count", ":stock_count"),
		(try_begin),
			(gt, ":stock_count_factor", 0),
			(eq, ":is_odd", 0),
			(scene_prop_get_slot, ":item_id", ":instance_id", slot_scene_prop_item_id),
			(call_script, "script_scene_prop_get_gold_value", ":instance_id", ":item_id", 0),
			(store_mul, ":gold_reward", reg0, craft_price_gold_reward_percentage),
			(val_div, ":gold_reward", 100),
			(scene_prop_get_slot, ":skill_reward", ":instance_id", slot_scene_prop_average_craft_skill),
			(val_mul, ":skill_reward", craft_skill_gold_reward_multiplier),
			(val_add, ":gold_reward", ":skill_reward"),
			(val_mul, ":gold_reward", ":stock_count_factor"),
			(val_div, ":gold_reward", ":design_target_stock_count"),
		(else_try),
			(assign, ":gold_reward", 0),
		(try_end),
		(try_begin),
			(neq,  "$g_game_type", "mt_feudalism"),
			(scene_prop_get_slot, reg1, ":instance_id", slot_scene_prop_resource_refund_cost),
			(try_begin),
				(lt, reg1, 0),
				(call_script, "script_scene_prop_calculate_resource_refund_cost", ":instance_id"),
			(try_end),
		(else_try),
			(assign, reg1, 0),
		(try_end),
		(assign, reg2, ":gold_reward"),
		(store_add, reg0, reg1, ":gold_reward"),
		]),

	("cf_repair_scene_prop", # server: check if an attack on a destructible scene prop should repair it; reg0 = resulting hit points, reg1 = whether more resources are required
	 [(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":agent_id", 2), # must be valid
		(store_script_param, ":hit_damage", 3),
		(store_script_param, ":full_hit_points", 4),
		(store_script_param, ":resource_class", 5), # constants starting with item_class_

		(agent_is_alive, ":agent_id"),
		#may admin update
		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(agent_get_wielded_item, ":wielded_item_id", ":agent_id", 0),
		(gt, ":wielded_item_id", -1),
		(item_get_slot, ":wielded_item_class", ":wielded_item_id", slot_item_class),
		(eq, ":wielded_item_class", item_class_repair),
		(agent_get_troop_id, ":troop_id", ":agent_id"),
		(store_skill_level, ":engineer", "skl_engineer", ":troop_id"),
		(gt, ":engineer", 0),
		(set_trigger_result, 0),
		(scene_prop_get_hit_points, ":hit_points", ":instance_id"),
		(lt, ":hit_points", ":full_hit_points"),
		(scene_prop_get_slot, ":next_resource_hp", ":instance_id", slot_scene_prop_next_resource_hp),
		(try_begin),
			(gt, ":hit_points", ":next_resource_hp"),
			(store_sub, ":maximum_required", ":full_hit_points", ":hit_points"),
			(call_script, "script_cf_agent_consume_resource", ":agent_id", ":resource_class", ":maximum_required"),
			(val_add, ":next_resource_hp", reg0),
			(val_min, ":next_resource_hp", ":full_hit_points"),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_next_resource_hp, ":next_resource_hp"),
		(try_end),
		(try_begin),
			(this_or_next|le, ":hit_points", ":next_resource_hp"),
			(player_is_admin, ":player_id"),
			(val_add, ":hit_points", ":hit_damage"),
			(val_mul, ":engineer", 20),
			(val_add, ":hit_points", ":engineer"),
			(val_min, ":hit_points", ":full_hit_points"),
			(scene_prop_set_hit_points, ":instance_id", ":hit_points"),
			(assign, reg1, 0),
		(else_try),
			(assign, reg1, 1),
		(try_end),
		(assign, reg0, ":hit_points"),
		]),

	("cf_hit_repairable_scene_prop", # server: handle attacking a destructible and repairable scene prop; reg0 = constant starting with repairable_, reg1 = resulting hit points
	 [(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":hit_damage", 2),
		(store_script_param, ":full_hit_points", 3),
		(store_script_param, ":resource_class", 4), # constants starting with item_class
		(store_script_param, ":agent_id", 5), # must be valid
		(store_script_param, ":repair_active", 6), # whether to allow repairing active, not fully destroyed scene props
		(store_script_param, ":script_damage", 7), # 0 = damage applied by an agent from ti_on_scene_prop_hit, 1 = damage applied by a script

		(scene_prop_get_slot, ":state", ":instance_id", slot_scene_prop_state),
		(try_begin),
			(agent_is_active, ":agent_id"),
			(this_or_next|neq, ":state", scene_prop_state_active),
			(eq, ":repair_active", 1),
			(call_script, "script_cf_repair_scene_prop", ":instance_id", ":agent_id", ":hit_damage", ":full_hit_points", ":resource_class"),
			(assign, ":hit_points", reg0),
			(assign, ":resource_required", reg1),
			(try_begin),
				(ge, ":hit_points", ":full_hit_points"),
				(neq, ":state", scene_prop_state_active),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_active),
				(get_max_players, ":max_players"),
				(try_for_range, ":player_id", 1, ":max_players"),
					(player_is_active, ":player_id"),
					(multiplayer_send_2_int_to_player, ":player_id", server_event_update_scene_prop_hit_points, ":instance_id", -1),
				(try_end),
				(assign, ":result", repairable_repaired),
			(else_try),
				(eq, ":resource_required", 1),
				(assign, ":result", repairable_resource_required),
				(agent_get_player_id, ":player_id", ":agent_id"),
				(multiplayer_send_2_int_to_player, ":player_id", server_event_preset_message, "str_resource_required", preset_message_yellow|preset_message_fail_sound),
			(else_try),
				(assign, ":result", repairable_repairing),
			(try_end),
		(else_try),
			(try_begin),
				(eq, ":resource_class", item_class_wood),
				(agent_is_active, ":agent_id"),
				(agent_get_wielded_item, ":wielded_item_id", ":agent_id", 0),
				(gt, ":wielded_item_id", -1),
				(item_slot_eq, ":wielded_item_id", slot_item_bonus_against_wood, 1),
				(val_mul, ":hit_damage", 2),
			(try_end),
			(scene_prop_get_slot, ":next_resource_hp", ":instance_id", slot_scene_prop_next_resource_hp),
			(val_sub, ":next_resource_hp", ":hit_damage"),
			(val_max, ":next_resource_hp", min_scene_prop_hit_points),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_next_resource_hp, ":next_resource_hp"),
			(call_script, "script_scene_prop_damage_no_destroy", ":instance_id", ":hit_damage"),
			(assign, ":hit_damage", reg1),
			(assign, ":hit_points", reg2),
			(try_begin), # for damage by a script rather than an agent, reduce the hit points manually
				(eq, ":script_damage", 1),
				(gt, ":hit_damage", 0),
				(scene_prop_set_hit_points, ":instance_id", ":hit_points"),
			(try_end),
			(try_begin),
				(eq, ":state", scene_prop_state_active),
				(try_begin),
					(le, ":hit_points", min_scene_prop_hit_points),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_destroyed),
					(assign, ":result", repairable_destroyed),
				(else_try),
					(assign, ":result", repairable_hit),
				(try_end),
			(else_try),
				(assign, ":result", repairable_hit_destroyed),
			(try_end),
		(try_end),
		(assign, reg0, ":result"),
		(assign, reg1, ":hit_points"),
		]),

	("cf_hit_door", # server: handle hitting a rotating destructible door; should be called from ti_on_scene_prop_hit
	 [(multiplayer_is_server),
		(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":hit_damage", 2),
		(store_script_param, ":resource_class", 3),
		(set_fixed_point_multiplier, 1),
		(position_get_x, ":agent_id", pos2), # expects agent id in pos2.x from ti_on_scene_prop_hit
		(set_fixed_point_multiplier, 100),

		(try_begin), # only allow repairing standing doors if they are open
			(scene_prop_slot_eq, ":instance_id", slot_scene_prop_rotation, 1),
			(assign, ":repair_active", 1),
		(else_try),
			(assign, ":repair_active", 0),
		(try_end),
		(scene_prop_get_slot, ":full_hit_points", ":instance_id", slot_scene_prop_full_hit_points),
		(call_script, "script_cf_hit_repairable_scene_prop", ":instance_id", ":hit_damage", ":full_hit_points", ":resource_class", ":agent_id", ":repair_active", 0),
		(assign, ":result", reg0),
		(try_begin),
			(eq, ":result", repairable_hit),
			(particle_system_burst, "psys_dummy_straw", pos1, 10),
			(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_shield_hit_wood_metal"),
		(else_try),
			(eq, ":result", repairable_destroyed),
			(call_script, "script_destroy_door", ":agent_id", ":instance_id"),
			(particle_system_burst, "psys_dummy_smoke", pos1, 20),
			(particle_system_burst, "psys_dummy_straw", pos1, 50),
			(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_cut_wood_break"),
		(else_try),
			(eq, ":result", repairable_hit_destroyed),
			(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_cut_wood_scratch"),
		(else_try),
			(eq, ":result", repairable_repairing),
			(agent_play_sound, ":agent_id", "snd_repair_wood"),
		(else_try),
			(eq, ":result", repairable_repaired),
			(prop_instance_get_starting_position, pos2, ":instance_id"),
			(prop_instance_animate_to_position, ":instance_id", pos2, 400),
			(agent_play_sound, ":agent_id", "snd_man_grunt"),
		(try_end),
		]),

	("destroy_door", # server: rotate destructible doors flat on the ground after destroyed
	 [(store_script_param, ":agent_id", 1), # if invalid, manually sets the hit points and state to destroyed
		(store_script_param, ":instance_id", 2), # must be valid

		(prop_instance_get_starting_position, pos2, ":instance_id"),
		(init_position, pos3),
		(try_begin),
			(agent_is_active, ":agent_id"),
			(agent_get_position, pos5, ":agent_id"),
		(else_try),
			(scene_prop_set_hit_points, ":instance_id", min_scene_prop_hit_points),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_next_resource_hp, min_scene_prop_hit_points),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_destroyed),
		(try_end),
		(try_begin), # align the door along the ground away from the agent
			(agent_is_active, ":agent_id"),
			(prop_instance_get_position, pos6, ":instance_id"),
			(position_is_behind_position, pos5, pos6),
			(assign, ":direction", -1),
			(position_move_y, pos3, 150),
			(assign, ":ground_offset", 20),
		(else_try),
			(assign, ":direction", 1),
			(position_move_y, pos3, -150),
			(assign, ":ground_offset", 0),
		(try_end),
		(position_move_x, pos3, -50),
		(position_transform_position_to_parent, pos4, pos2, pos3),
		(position_move_z, pos4, 150, 1),
		(position_get_distance_to_ground_level, ":ground_distance", pos4),
		(val_sub, ":ground_distance", 150),
		(store_atan2, ":ground_angle", ":ground_distance", 150),
		(convert_from_fixed_point, ":ground_angle"),
		(store_add, ":rotate_angle", 90, ":ground_angle"),
		(val_mul, ":rotate_angle", ":direction"),
		(position_rotate_x, pos2, ":rotate_angle"),
		(position_move_z, pos2, ":ground_offset", 1),
		(prop_instance_animate_to_position, ":instance_id", pos2, 100),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_target_position, 0),
		]),

	("cf_use_rotate_door", # server: handle opening and closing a rotating door
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid
		(store_script_param, ":left", 3), # 1 makes the door rotate the other way, for matching left and right doors

	(try_begin),
			(prop_instance_get_scene_prop_kind, ":scene_prop_kind", ":instance_id"),
			(eq, "spr_pw_door_rotate_dungeon_b", ":scene_prop_kind"), #GGG:spr_pw_door_rotate_dungeon_cell_b
			(prop_instance_get_variation_id_2, ":var_2", ":instance_id"),
			(agent_get_player_id, ":player_id", ":agent_id"),
			(player_get_unique_id, reg1, ":player_id"),
			(assign, reg2, ":var_2"),
			(assign, reg3, ":player_id"),
			(send_message_to_url, "@http://localhost/backendDsDvC/checkhouse.php?guid={reg1}&house={reg2}&playerid={reg3}"),
	(else_try),

	
		(scene_prop_slot_eq, ":instance_id", slot_scene_prop_state, scene_prop_state_active),
		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(player_get_slot, ":player_faction_id", ":player_id", slot_player_faction_id),
		(call_script, "script_scene_prop_get_owning_faction", ":instance_id"),
		(assign, ":faction_id", reg0),
		(prop_instance_get_variation_id_2, ":is_bolted", ":instance_id"),
		(val_and, ":is_bolted", 0x2),
		(assign, ":fail_string_id", 0),
		(try_begin),
			(eq, ":is_bolted", 0x2),
			(try_begin),
				(scene_prop_slot_eq, ":instance_id", slot_scene_prop_rotation, 1),
			#GGG:fix outlaws
			(else_try),
				(eq, ":faction_id", ":player_faction_id"),
				(eq, ":player_faction_id", "fac_outlaws"),
				(player_set_slot, ":player_id", slot_player_has_faction_door_key, 1),
			#
			(else_try),
				(neq, ":faction_id", "fac_commoners"),
				(eq, ":faction_id", ":player_faction_id"),
				(player_slot_eq, ":player_id", slot_player_has_faction_door_key, 1),
			(else_try),
				(prop_instance_get_position, pos1, ":instance_id"),
				(agent_get_position, pos2, ":agent_id"),
				(neg|position_is_behind_position, pos2, pos1),
			(else_try),
				(assign, ":fail_string_id", "str_door_bolted"),
			(try_end),
		(else_try),
			(eq, ":faction_id", "fac_commoners"),
		#GGG:fix outlaws
		(else_try),
			(eq, ":faction_id", ":player_faction_id"),
			(eq, ":player_faction_id", "fac_outlaws"),
			(player_set_slot, ":player_id", slot_player_has_faction_door_key, 1),
		#
		(else_try),
			(eq, ":faction_id", ":player_faction_id"),
			(player_slot_eq, ":player_id", slot_player_has_faction_door_key, 1),
		(else_try),
			(assign, ":fail_string_id", "str_door_locked_by_s1"),
		(try_end),
		(try_begin),
			(gt, ":fail_string_id", 0),
			(prop_instance_get_variation_id_2, ":not_pickable", ":instance_id"),
			(val_and, ":not_pickable", 0x4),
			(neq, ":not_pickable", 0x4),
			(try_begin),
				(call_script, "script_cf_agent_pick_lock", ":agent_id", 100),
				(assign, ":fail_string_id", 0),
			(try_end),
			(gt, reg0, 0),
		(else_try),
			(eq, ":fail_string_id", "str_door_bolted"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_preset_message, ":fail_string_id", preset_message_error),
		(else_try),
			(eq, ":fail_string_id", "str_door_locked_by_s1"),
			(multiplayer_send_3_int_to_player, ":player_id", server_event_preset_message, ":fail_string_id", preset_message_faction|preset_message_fail_sound, ":faction_id"),
		(try_end),
		(eq, ":fail_string_id", 0),
		(call_script, "script_cf_rotate_door", ":instance_id", ":left"),
	
	(try_end),
		]),

	("cf_rotate_door", # server: helper script to rotate doors
	 [(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":left", 2),

		(prop_instance_get_starting_position, pos1, ":instance_id"),
		(try_begin),
			(scene_prop_slot_eq, ":instance_id", slot_scene_prop_rotation, 0),
			(try_begin),
				(eq, ":left", 1),
				(position_rotate_z, pos1, -95),
			(else_try),
				(position_rotate_z, pos1, 95),
			(try_end),
			(assign, ":door_open", 1),
		(else_try),
			(assign, ":door_open", 0),
		(try_end),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_rotation, ":door_open"),
		(scene_prop_enable_after_time, ":instance_id", 100),
		(prop_instance_animate_to_position, ":instance_id", pos1, 100),
		]),

	("cf_init_rotate_door", # server: set the inital position of a rotating door
	 [(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":left", 2),

	(prop_instance_get_scene_prop_kind, ":scene_prop_kind", ":instance_id"),
	(neg|eq, "spr_pw_door_rotate_dungeon_b", ":scene_prop_kind"),#GGG:spr_pw_door_rotate_dungeon_cell_b
	
		(prop_instance_get_variation_id_2, ":bit_field", ":instance_id"),
		(store_and, ":start_destroyed", ":bit_field", 0x10),
		(try_begin),
			(eq, ":start_destroyed", 0x10),
			(call_script, "script_destroy_door", -1, ":instance_id"),
		(else_try),
			(store_and, ":initial_position", ":bit_field", 0x1),
			(eq, ":initial_position", 0x1),
			(call_script, "script_cf_rotate_door", ":instance_id", ":left"),
		(try_end),
		]),

	("cf_hit_chest", # server: handle damaging and repairing a storage chest; should be called from ti_on_scene_prop_hit
	 [(multiplayer_is_server),
		(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":hit_damage", 2),
		(store_script_param, ":full_hit_points", 3),
		(set_fixed_point_multiplier, 1),
		(position_get_x, ":agent_id", pos2), # expects agent id in pos2.x from ti_on_scene_prop_hit
		(set_fixed_point_multiplier, 100),

		(call_script, "script_cf_hit_repairable_scene_prop", ":instance_id", ":hit_damage", ":full_hit_points", item_class_wood, ":agent_id", 1, 0),
		(assign, ":result", reg0),
		(try_begin),
			(eq, ":result", repairable_hit),
			(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_shield_hit_wood_metal"),
		(else_try),
			(eq, ":result", repairable_destroyed),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_unlocked, 1),
			(particle_system_burst, "psys_dummy_smoke", pos1, 10),
			(particle_system_burst, "psys_dummy_straw", pos1, 30),
			(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_shield_broken"),
		(else_try),
			(eq, ":result", repairable_hit_destroyed),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_unlocked, 1),
			(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_cut_wood_scratch"),
		(else_try),
			(eq, ":result", repairable_repairing),
			(agent_play_sound, ":agent_id", "snd_repair_wood"),
		(else_try),
			(eq, ":result", repairable_repaired),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_unlocked, 0),
			(agent_play_sound, ":agent_id", "snd_repair_wood"),
		(try_end),
		]),

	("cf_pick_chest_lock", # server: handle players trying to pick the lock of a storage chest
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid
		(store_script_param, ":probability_multiplier", 3), # see script_cf_agent_pick_lock

		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(assign, ":fail", 0),
		(call_script, "script_scene_prop_get_owning_faction", ":instance_id"),
		(assign, ":faction_id", reg0),
		(try_begin),
			(eq, reg1, -1),
		(else_try),
			(scene_prop_slot_eq, ":instance_id", slot_scene_prop_unlocked, 1),
			(try_begin),
				(player_slot_eq, ":player_id", slot_player_faction_id, ":faction_id"),
				(player_slot_eq, ":player_id", slot_player_has_faction_door_key, 1),
				(scene_prop_slot_eq, ":instance_id", slot_scene_prop_state, scene_prop_state_active),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_unlocked, 0),
				(agent_play_sound, ":agent_id", "snd_lock"),
			(try_end),
		(else_try),
			(assign, ":fail", 1),
			(le, ":probability_multiplier", 0),
			(agent_play_sound, ":agent_id", "snd_pick_lock_fail"),
		(else_try),
			(call_script, "script_cf_agent_pick_lock", ":agent_id", ":probability_multiplier"),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_unlocked, 1),
		(str_store_player_username, s1, ":player_id"),
		(str_store_faction_name, s2, ":faction_id"),
		(server_add_message_to_log, "@{s1} pick locked a chest owned by: {s2}"),
			(assign, ":fail", 0),
		(else_try),
			(le, reg0, 0),
			(multiplayer_send_3_int_to_player, ":player_id", server_event_preset_message, "str_chest_locked_by_s1", preset_message_faction|preset_message_fail_sound, ":faction_id"),
		(try_end),
		(eq, ":fail", 0),
		]),

	("cf_hit_bridge", # server: handle damaging and repairing bridges; should be called from ti_on_scene_prop_hit
	 [(multiplayer_is_server),
		(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":hit_damage", 2),
		(store_script_param, ":script_damage", 3), # set to 1 when the agent hit a linked scene prop, to apply damage manually
		(set_fixed_point_multiplier, 1),
		(position_get_x, ":agent_id", pos2), # expects agent id in pos2.x from ti_on_scene_prop_hit
		(set_fixed_point_multiplier, 100),

		(scene_prop_get_slot, ":full_hit_points", ":instance_id", slot_scene_prop_full_hit_points),
		(call_script, "script_cf_hit_repairable_scene_prop", ":instance_id", ":hit_damage", ":full_hit_points", item_class_wood, ":agent_id", 1, ":script_damage"),
		(assign, ":result", reg0),
		(try_begin),
			(eq, ":result", repairable_hit),
			(particle_system_burst, "psys_dummy_straw", pos1, 30),
			(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_cut_wood"),
		(else_try),
			(eq, ":result", repairable_destroyed),
			(prop_instance_get_starting_position, pos2, ":instance_id"),
			(position_get_distance_to_terrain, ":distance", pos2),
			(try_begin), # drop to terrain if above
				(gt, ":distance", 0),
				(val_mul, ":distance", -1),
				(position_move_z, pos2, ":distance"),
			(else_try), # otherwise if starting below terrain, drop to the lowest position
				(position_get_z, ":distance", pos2),
				(store_sub, ":distance", z_position_to_hide_object, ":distance"),
				(position_set_z, pos2, z_position_to_hide_object),
			(try_end),
			(store_div, ":animation_time", ":distance", 2),
			(val_abs, ":animation_time"),
			(agent_get_position, pos3, ":agent_id"), # rotate bridge to fall faster on the side of the last attacker
			(position_transform_position_to_local, pos4, pos2, pos3),
			(position_get_x, ":distance_from_center", pos4),
			(store_div, ":rotate_angle", ":distance_from_center", 30),
			(assign, ":absolute_distance", ":distance"),
			(val_abs, ":absolute_distance"),
			(try_begin),
				(le, ":absolute_distance", 1000),
				(val_mul, ":rotate_angle", ":absolute_distance"),
				(val_div, ":rotate_angle", 1000),
			(try_end),
			(val_clamp, ":rotate_angle", -40, 41),
			(position_rotate_y, pos2, ":rotate_angle"),
			(prop_instance_animate_to_position, ":instance_id", pos2, ":animation_time"),
			(particle_system_burst, "psys_dummy_smoke", pos1, 20),
			(particle_system_burst, "psys_dummy_straw", pos1, 50),
			(particle_system_burst, "psys_game_water_splash_2", pos1, 100),
			(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_cut_wood_break"),
		(else_try),
			(eq, ":result", repairable_hit_destroyed),
			(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_cut_wood_scratch"),
		(else_try),
			(eq, ":result", repairable_repairing),
			(agent_play_sound, ":agent_id", "snd_repair_wood"),
		(else_try),
			(eq, ":result", repairable_repaired),
			(prop_instance_get_starting_position, pos2, ":instance_id"),
			(prop_instance_stop_animating, ":instance_id"),
			(prop_instance_set_position, ":instance_id", pos2),
			(particle_system_burst, "psys_dummy_smoke", pos1, 50),
			(agent_play_sound, ":agent_id", "snd_man_grunt"),
		(try_end),
		(assign, reg2, ":agent_id"),
		]),

	("cf_hit_bridge_footing", # server: handle damaging and repairing bridges indirectly through linked props; should be called from ti_on_scene_prop_hit
	 [(multiplayer_is_server),
		(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":hit_damage", 2),

		(scene_prop_get_slot, ":bridge_instance_id", ":instance_id", slot_scene_prop_linked_scene_prop),
		(gt, ":bridge_instance_id", 0),
		(call_script, "script_cf_hit_bridge", ":bridge_instance_id", ":hit_damage", 1),
		(agent_get_player_id, ":player_id", reg2),
		(try_begin),
			(player_is_active, ":player_id"),
			(scene_prop_get_hit_points, ":hit_points", ":bridge_instance_id"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_update_scene_prop_hit_points, ":bridge_instance_id", ":hit_points"),
		(try_end),
		(set_trigger_result, 0),
		]),

	("cf_init_wall", # server: set up destructible wall positions and slots at mission start
	 [(store_script_param, ":instance_id", 1), # must be valid

		(set_fixed_point_multiplier, 100),
		(prop_instance_get_starting_position, pos1, ":instance_id"),
		(scene_prop_get_slot, ":height", ":instance_id", slot_scene_prop_height),
		(prop_instance_get_scale, pos3, ":instance_id"),
		(position_get_scale_z, ":scale", pos3),
		(val_mul, ":height", ":scale"),
		(convert_from_fixed_point, ":height"),
		(val_add, ":height", 100),
		(val_mul, ":height", -1),
		(position_move_z, pos1, ":height"),
		(prop_instance_set_position, ":instance_id", pos1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_destroyed),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_next_resource_hp, min_scene_prop_hit_points),
		(scene_prop_set_hit_points, ":instance_id", min_scene_prop_hit_points),
		]),

	("cf_hit_wall", # server: handle damaging and repairing walls and ladders; should be called from ti_on_scene_prop_hit
	 [(multiplayer_is_server),
		(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":hit_damage", 2),
		(store_script_param, ":script_damage", 3), # set to 1 when the agent hit a linked scene prop, to apply damage manually
		(set_fixed_point_multiplier, 1),
		(position_get_x, ":agent_id", pos2), # expects agent id in pos2.x from ti_on_scene_prop_hit
		(set_fixed_point_multiplier, 100),

		(scene_prop_get_slot, ":full_hit_points", ":instance_id", slot_scene_prop_full_hit_points),
		(call_script, "script_cf_hit_repairable_scene_prop", ":instance_id", ":hit_damage", ":full_hit_points", item_class_wood, ":agent_id", 1, ":script_damage"),
		(assign, ":result", reg0),
		(try_begin),
			(eq, ":result", repairable_hit),
			(particle_system_burst, "psys_dummy_straw", pos1, 50),
			(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_cut_wood"),
		(else_try),
			(eq, ":result", repairable_destroyed),
			(try_begin),
				(scene_prop_slot_eq, ":instance_id", slot_scene_prop_no_move_physics, 1),
				(prop_instance_enable_physics, ":instance_id", 0),
			(try_end),
			(prop_instance_get_starting_position, pos2, ":instance_id"),
			(scene_prop_get_slot, ":height", ":instance_id", slot_scene_prop_height),
			(prop_instance_get_scale, pos3, ":instance_id"),
			(position_get_scale_z, ":scale", pos3),
			(val_mul, ":height", ":scale"),
			(convert_from_fixed_point, ":height"),
			(val_add, ":height", 100),
			(val_mul, ":height", -1),
			(position_move_z, pos2, ":height"),
			(prop_instance_animate_to_position, ":instance_id", pos2, 1000),
			(particle_system_burst, "psys_dummy_smoke", pos1, 100),
			(particle_system_burst, "psys_dummy_straw", pos1, 100),
			(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_cut_wood_break"),
		(else_try),
			(eq, ":result", repairable_hit_destroyed),
			(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_cut_wood_scratch"),
		(else_try),
			(eq, ":result", repairable_repairing),
			(agent_play_sound, ":agent_id", "snd_repair_wood"),
		(else_try),
			(eq, ":result", repairable_repaired),
			(try_begin),
				(scene_prop_slot_eq, ":instance_id", slot_scene_prop_no_move_physics, 1),
				(prop_instance_enable_physics, ":instance_id", 0),
			(try_end),
			(prop_instance_get_starting_position, pos2, ":instance_id"),
			(prop_instance_animate_to_position, ":instance_id", pos2, 1000),
			(agent_play_sound, ":agent_id", "snd_man_grunt"),
		(try_end),
		(assign, reg2, ":agent_id"),
		]),

	("cf_hit_build_wall", # server: handle hitting the building station for walls and ladders; should be called from ti_on_scene_prop_hit
	 [(multiplayer_is_server),
		(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":hit_damage", 2),

		(scene_prop_get_slot, ":wall_instance_id", ":instance_id", slot_scene_prop_linked_scene_prop),
		(gt, ":wall_instance_id", 0),
		(call_script, "script_cf_hit_wall", ":wall_instance_id", ":hit_damage", 1),
		(agent_get_player_id, ":player_id", reg2),
		(try_begin),
			(player_is_active, ":player_id"),
			(scene_prop_get_hit_points, ":hit_points", ":wall_instance_id"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_update_scene_prop_hit_points, ":wall_instance_id", ":hit_points"),
		(try_end),
		(set_trigger_result, 0),
		]),

	("cf_hit_construction_box", # server: handle building and damaging construction boxes; should be called from ti_on_scene_prop_hit
	 [(multiplayer_is_server),
		(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":hit_damage", 2),
		(store_script_param, ":resource_class", 3), # constants starting with item_class_
		(set_fixed_point_multiplier, 1),
		(position_get_x, ":agent_id", pos2), # expects agent id in pos2.x from ti_on_scene_prop_hit
		(set_fixed_point_multiplier, 100),

		(scene_prop_get_slot, ":full_hit_points", ":instance_id", slot_scene_prop_full_hit_points),
		(call_script, "script_cf_hit_repairable_scene_prop", ":instance_id", ":hit_damage", ":full_hit_points", ":resource_class", ":agent_id", 1, 0),
		(assign, ":result", reg0),
		(try_begin),
			(this_or_next|eq, ":result", repairable_hit),
			(eq, ":result", repairable_destroyed),
			(particle_system_burst, "psys_dummy_straw", pos1, 50),
			(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_cut_wood"),
		(else_try),
			(eq, ":result", repairable_hit_destroyed),
			(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_cut_wood_scratch"),
		(else_try),
			(eq, ":result", repairable_repairing),
			(agent_play_sound, ":agent_id", "snd_repair_wood"),
		(else_try),
			(eq, ":result", repairable_repaired),
			(agent_play_sound, ":agent_id", "snd_repair_wood"),
			(prop_instance_get_starting_position, pos1, ":instance_id"),
			(particle_system_burst, "psys_dummy_smoke_big", pos1, 20),
			(init_position, pos1),
			(position_set_z, pos1, z_position_to_hide_object),
			(prop_instance_set_position, ":instance_id", pos1),
			(prop_instance_enable_physics, ":instance_id", 0),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_hidden),
		(try_end),
		]),

	("cf_init_fire_place", # server: set up the linked visible flames for a fire place prop at mission start
	 [(multiplayer_is_server),
		(store_script_param, ":instance_id", 1), # must be valid

		(set_fixed_point_multiplier, 100),
		(init_position, pos1),
		(position_set_z, pos1, z_position_to_hide_object),
		(set_spawn_position, pos1),
		(spawn_scene_prop, "spr_wood_heap_fire"),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_linked_scene_prop, reg0),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_destroyed),
		(prop_instance_get_variation_id_2, ":initial_wood_amount", ":instance_id"),
		(val_mul, ":initial_wood_amount", 1000),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_stock_count, ":initial_wood_amount"),
		]),

	("cf_hit_fire_place", # server: handle adding wood to, lighting, and extinguishing a fire place; should be called from ti_on_scene_prop_hit
	 [(multiplayer_is_server),
		(store_script_param, ":instance_id", 1), # must be valid
		(set_fixed_point_multiplier, 1),
		(position_get_x, ":agent_id", pos2), # expects agent id in pos2.x from ti_on_scene_prop_hit
		(set_fixed_point_multiplier, 100),

		(set_trigger_result, 0),
		(agent_get_wielded_item, ":wielded_item_id", ":agent_id", 0),
		(gt, ":wielded_item_id", -1),
		(scene_prop_get_slot, ":state", ":instance_id", slot_scene_prop_state),
		(try_begin),
			(eq, ":wielded_item_id", "itm_torch"),
			(eq, ":state", scene_prop_state_destroyed),
			(scene_prop_slot_ge, ":instance_id", slot_scene_prop_stock_count, 1),
			(scene_prop_get_slot, ":fire_instance_id", ":instance_id", slot_scene_prop_linked_scene_prop),
			(prop_instance_is_valid, ":fire_instance_id"),
			(prop_instance_get_position, pos1, ":instance_id"),
			(prop_instance_set_position, ":fire_instance_id", pos1),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_active),
		(else_try),
			(eq, ":wielded_item_id", "itm_water_bucket"),
			(eq, ":state", scene_prop_state_active),
			(call_script, "script_cf_agent_consume_item", ":agent_id", "itm_water_bucket", 1),
			(agent_equip_item, ":agent_id", "itm_bucket", reg0),
			(agent_set_wielded_item, ":agent_id", "itm_bucket"),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_destroyed),
			(scene_prop_get_slot, ":fire_instance_id", ":instance_id", slot_scene_prop_linked_scene_prop),
			(prop_instance_is_valid, ":fire_instance_id"),
			(init_position, pos1),
			(position_set_z, pos1, z_position_to_hide_object),
			(prop_instance_set_position, ":fire_instance_id", pos1),
		(else_try),
			(item_slot_eq, ":wielded_item_id", slot_item_class, item_class_wood),
			(item_get_slot, ":resource_amount", ":wielded_item_id", slot_item_resource_amount),
			(gt, ":resource_amount", 0),
			(call_script, "script_cf_agent_consume_item", ":agent_id", ":wielded_item_id", 1),
			(scene_prop_get_slot, ":stock_count", ":instance_id", slot_scene_prop_stock_count),
			(val_add, ":stock_count", ":resource_amount"),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_stock_count, ":stock_count"),
		(try_end),
		]),

	("fire_place_burn", # server: consume wood while a fire is burning, remove the flames if no fuel left
	 [(store_script_param, ":instance_id", 1), # must be valid

		(scene_prop_get_slot, ":state", ":instance_id", slot_scene_prop_state),
		(try_begin),
			(eq, ":state", scene_prop_state_active),
			(scene_prop_get_slot, ":stock_count", ":instance_id", slot_scene_prop_stock_count),
			(val_sub, ":stock_count", 200),
			(val_max, ":stock_count", 0),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_stock_count, ":stock_count"),
			(le, ":stock_count", 0),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_destroyed),
			(scene_prop_get_slot, ":fire_instance_id", ":instance_id", slot_scene_prop_linked_scene_prop),
			(prop_instance_is_valid, ":fire_instance_id"),
			(set_fixed_point_multiplier, 100),
			(init_position, pos1),
			(position_set_z, pos1, z_position_to_hide_object),
			(prop_instance_set_position, ":fire_instance_id", pos1),
		(try_end),
		]),

	("winch_get_direction", # return the direction an agent will rotate a winch in reg0, based on relative position
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid

		(prop_instance_get_starting_position, pos1, ":instance_id"),
		(agent_get_position, pos2, ":agent_id"),
		(position_transform_position_to_local, pos3, pos1, pos2),
		(position_get_y, ":relative_y_position", pos3),
		(try_begin),
			(ge, ":relative_y_position", 0),
			(assign, reg0, 1),
		(else_try),
			(assign, reg0, -1),
		(try_end),
		]),

	("cf_use_winch", # server: handle players using a winch to move another linked object
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":winch_instance_id", 2), # must be valid
		(store_script_param, ":move_steps_plus_one", 3),
		(store_script_param, ":step_size", 4),
		(store_script_param, ":animation_time", 5),
		(store_script_param, ":winch_type", 6), # constants starting with winch_type_

		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(agent_is_alive, ":agent_id"),
		(call_script, "script_winch_get_direction", ":agent_id", ":winch_instance_id"),
		(assign, ":direction", reg0),
		(scene_prop_get_slot, ":moveable_instance_id", ":winch_instance_id", slot_scene_prop_linked_scene_prop),
		(gt, ":moveable_instance_id", 0),
		(scene_prop_get_slot, ":current_target", ":moveable_instance_id", slot_scene_prop_target_position),
		(try_begin),
			(eq, ":winch_type", winch_type_platform),
			(scene_prop_get_slot, ":maximum_height", ":moveable_instance_id", slot_scene_prop_height),
			(scene_prop_get_slot, ":maximum_depth", ":moveable_instance_id", slot_scene_prop_width),
			(store_sub, ":move_steps_plus_one", ":maximum_height", ":maximum_depth"),
			(val_div, ":move_steps_plus_one", ":step_size"),
			(val_add, ":move_steps_plus_one", 1),
		(try_end),
		(try_begin),
			(le, ":direction", -1),
			(val_mul, ":direction", 2), # drop down twice as fast as raising up
			(eq, ":winch_type", winch_type_portcullis),
			(assign, ":new_target", 0), # portcullis drops all the way in one step
			(neq, ":new_target", ":current_target"),
			(assign, ":animation_time", 20),
			(call_script, "script_scene_prop_play_sound", ":moveable_instance_id", "snd_body_fall_big"),
		(else_try),
			(store_add, ":new_target", ":current_target", ":direction"),
			(val_clamp, ":new_target", 0, ":move_steps_plus_one"),
		(try_end),
		(neq, ":new_target", ":current_target"),
		(scene_prop_set_slot, ":moveable_instance_id", slot_scene_prop_target_position, ":new_target"),
		(prop_instance_get_starting_position, pos1, ":moveable_instance_id"),
		(store_mul, ":target_movement", ":new_target", ":step_size"),
		(try_begin),
			(eq, ":winch_type", winch_type_platform),
			(store_add, ":target_height", ":maximum_depth", ":target_movement"),
			(val_clamp, ":target_height", ":maximum_depth", ":maximum_height"),
			(position_set_z, pos1, ":target_height"),
		(else_try),
			(eq, ":winch_type", winch_type_portcullis),
			(position_move_z, pos1, ":target_movement"),
		(else_try),
			(eq, ":winch_type", winch_type_sliding_door),
			(position_move_x, pos1, ":target_movement"),
		(else_try),
			(position_rotate_x, pos1, ":target_movement"),
		(try_end),
		(prop_instance_animate_to_position, ":moveable_instance_id", pos1, ":animation_time"),
		(try_begin),
			(gt, ":direction", 0),
			(assign, ":winch_rotation", -36000),
		(else_try),
			(eq, ":winch_type", winch_type_sliding_door),
			(assign, ":winch_rotation", 36000),
		(else_try),
			(assign, ":winch_rotation", 72000),
		(try_end),
		(prop_instance_get_position, pos1, ":winch_instance_id"),
		(prop_instance_rotate_to_position, ":winch_instance_id", pos1, ":animation_time", ":winch_rotation"),
		]),

	("cf_init_winch", # server: set initial positions for objects linked to winches
	 [(multiplayer_is_server),
		(store_script_param, ":winch_instance_id", 1), # must be valid
		(store_script_param, ":start_step", 2),
		(store_script_param, ":step_size", 3),
		(store_script_param, ":winch_type", 4), # constants starting with winch_type_

		(scene_prop_get_slot, ":moveable_instance_id", ":winch_instance_id", slot_scene_prop_linked_scene_prop),
		(ge, ":moveable_instance_id", 0),
		(prop_instance_get_variation_id, ":initial_position", ":winch_instance_id"),
		(val_and, ":initial_position", 0x1),
		(try_begin),
			(eq, ":winch_type", winch_type_drawbridge),
			(eq, ":initial_position", 0x1),
		(else_try),
			(this_or_next|eq, ":winch_type", winch_type_portcullis),
			(eq, ":winch_type", winch_type_sliding_door),
			(neq, ":initial_position", 0x1),
		(else_try),
			(assign, ":initial_position", -1),
		(try_end),
		(try_begin),
			(neq, ":initial_position", -1),
			(scene_prop_set_slot, ":moveable_instance_id", slot_scene_prop_target_position, ":start_step"),
			(prop_instance_get_starting_position, pos1, ":moveable_instance_id"),
			(store_mul, ":target_movement", ":start_step", ":step_size"),
			(try_begin),
				(eq, ":winch_type", winch_type_portcullis),
				(position_move_z, pos1, ":target_movement"),
			(else_try),
				(eq, ":winch_type", winch_type_sliding_door),
				(position_move_x, pos1, ":target_movement"),
			(else_try),
				(position_rotate_x, pos1, ":target_movement"),
			(try_end),
			(prop_instance_set_position, ":moveable_instance_id", pos1),
		(try_end),
		]),

	("cf_init_lift_platform", # server: calculate range of motion for a lift platform at mission start
	 [(multiplayer_is_server),
		(store_script_param, ":platform_instance_id", 1), # must be valid

		(scene_prop_get_slot, ":winch_1_instance_id", ":platform_instance_id", slot_scene_prop_linked_scene_prop_1),
		(gt, ":winch_1_instance_id", 0),
		(scene_prop_get_slot, ":winch_2_instance_id", ":platform_instance_id", slot_scene_prop_linked_scene_prop_2),
		(gt, ":winch_2_instance_id", 0),
		(set_fixed_point_multiplier, 100),
		(prop_instance_get_starting_position, pos1, ":winch_1_instance_id"),
		(prop_instance_get_starting_position, pos2, ":winch_2_instance_id"),
		(position_get_z, ":height", pos1),
		(position_get_z, ":depth", pos2),
		(val_sub, ":height", 100),
		(val_sub, ":depth", 100),
		(try_begin), # swap the top and bottom values if needed
			(gt, ":depth", ":height"),
			(assign, ":temp", ":depth"),
			(assign, ":depth", ":height"),
			(assign, ":height", ":temp"),
		(try_end),
		(scene_prop_set_slot, ":platform_instance_id", slot_scene_prop_height, ":height"),
		(scene_prop_set_slot, ":platform_instance_id", slot_scene_prop_width, ":depth"),
		(prop_instance_get_starting_position, pos1, ":platform_instance_id"),
		(position_set_z, pos1, ":depth"),
		(prop_instance_set_position, ":platform_instance_id", pos1),
		]),

	("cf_use_inventory", # server: reply with inventory contents of a scene prop when requested by a player
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid
		(store_script_param, ":probability_multiplier", 3), # used for lock picking if the scene prop is destructible and locked

		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(agent_is_alive, ":agent_id"),
		(call_script, "script_agent_remove_empty_ammo_stacks", ":agent_id"),

	#(try_begin),
	#    (prop_instance_get_variation_id_2, ":var_2", ":instance_id"),
	#    (agent_get_player_id, ":player_id", ":agent_id"),
	#    (player_get_unique_id, reg1, ":player_id"),
	#    (assign, reg2, ":var_2"),
	#    (assign, reg3, ":player_id"),
	#    (send_message_to_url, "@http://localhost/backendDsDvC/checkchest.php?guid={reg1}&chest={reg2}&playerid={reg3}"),
	#(else_try),

		(assign, ":fail", 0),
		(try_begin),
			(scene_prop_slot_eq, ":instance_id", slot_scene_prop_full_hit_points, 0),
		(else_try),
			(scene_prop_slot_eq, ":instance_id", slot_scene_prop_unlocked, 1),
		(else_try),
			(call_script, "script_scene_prop_get_owning_faction", ":instance_id"),
			(eq, reg1, -1),
		(else_try),
			(player_slot_eq, ":player_id", slot_player_faction_id, reg0),
			(player_slot_eq, ":player_id", slot_player_has_faction_item_key, 1),
		(else_try),
			(call_script, "script_cf_pick_chest_lock", ":agent_id", ":instance_id", ":probability_multiplier"),
		(else_try),
			(assign, ":fail", 1),
		(try_end),
		(eq, ":fail", 0),
		#GGG:house chest
		(try_begin),
			(prop_instance_get_scene_prop_kind, ":scene_prop_kind", ":instance_id"),
			(eq, ":scene_prop_kind", "spr_pw_item_chest_a"), 
			(prop_instance_get_variation_id_2, ":chest_id", ":instance_id"),
			(gt, ":chest_id", 0),
			(assign, reg99, ":chest_id"),

			(str_store_string, s0, "@You have accessed a house item bank."),
			(multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),
			(str_store_player_username, s98, ":player_id"),
			(server_add_message_to_log, "@{s98} accessed house chest {reg99}"),
		(try_end),
		#
		(agent_set_animation, ":agent_id", "anim_access_inventory"),
		(scene_prop_get_slot, ":inventory_slot_end", ":instance_id", slot_scene_prop_inventory_count),
		(gt, ":inventory_slot_end", 0),
		(val_add, ":inventory_slot_end", slot_scene_prop_inventory_begin),
		(assign, ":slot_range_begin", -1),
		(scene_prop_get_slot, ":item_id", ":instance_id", slot_scene_prop_inventory_begin),
		(try_for_range, ":inventory_slot", slot_scene_prop_inventory_begin, ":inventory_slot_end"),
			(store_add, ":next_inventory_slot", ":inventory_slot", 1),
			(try_begin),
				(lt, ":next_inventory_slot", ":inventory_slot_end"),
				(scene_prop_get_slot, ":next_item_id", ":instance_id", ":next_inventory_slot"),
			(else_try),
				(assign, ":next_item_id", -9999),
			(try_end),
			(try_begin), # if the next items are identical, wait to send one message for the full slot range
				(eq, ":item_id", ":next_item_id"),
				(try_begin),
					(le, ":slot_range_begin", -1),
					(assign, ":slot_range_begin", ":inventory_slot"),
				(try_end),
			(else_try),
				(try_begin), # sending a group of identical items
					(gt, ":slot_range_begin", -1),
					(multiplayer_send_4_int_to_player, ":player_id", server_event_scene_prop_set_slot, ":instance_id", ":slot_range_begin", ":item_id", ":next_inventory_slot"),
					(assign, ":slot_range_begin", -1),
				(else_try), # else just send the single slot
					(multiplayer_send_3_int_to_player, ":player_id", server_event_scene_prop_set_slot, ":instance_id", ":inventory_slot", ":item_id"),
				(try_end),
			(try_end),
			(assign, ":item_id", ":next_item_id"),
		(try_end),
		(multiplayer_send_int_to_player, ":player_id", server_event_show_inventory, ":instance_id"),
		(player_set_slot, ":player_id", slot_player_accessing_instance_id, ":instance_id"),
		(scene_prop_get_slot, ":inventory_unique_id", ":instance_id", slot_scene_prop_inventory_unique_id),
		(player_set_slot, ":player_id", slot_player_accessing_unique_id, ":inventory_unique_id"),

	#(try_end),
		]),

#GGG:checkchest
	#("cf_open_chest", # server: helper script to rotate doors
	# [(store_script_param, ":instance_id", 1), # must be valid
	#  (store_script_param, ":left", 2),

	#  (prop_instance_get_starting_position, pos1, ":instance_id"),
	#  (try_begin),
	#    (scene_prop_slot_eq, ":instance_id", slot_scene_prop_rotation, 0),
	#    (try_begin),
	#      (eq, ":left", 1),
	#      (position_rotate_z, pos1, -95),
	#    (else_try),
	#      (position_rotate_z, pos1, 95),
	#    (try_end),
	#    (assign, ":door_open", 1),
	#  (else_try),
	#    (assign, ":door_open", 0),
	#  (try_end),
	#  (scene_prop_set_slot, ":instance_id", slot_scene_prop_rotation, ":door_open"),
	#  (scene_prop_enable_after_time, ":instance_id", 100),
	#  (prop_instance_animate_to_position, ":instance_id", pos1, 100),
	#  ]),
#

	("transfer_inventory", # server: handle inventory transfers within and between scene props and their agent
	 [(store_script_param, ":player_id", 1), # must be valid
		(store_script_param, ":instance_id", 2),
		(store_script_param, ":from_slot", 3),
		(store_script_param, ":to_slot", 4),
		(store_script_param, ":item_id", 5),

		(try_begin), # failures in this section will force disconnection from the scene prop, to stop receiving updates
			(gt, ":instance_id", 0),
			(player_get_agent_id, ":agent_id", ":player_id"),
			(agent_is_active, ":agent_id"),
			(agent_is_alive, ":agent_id"),
			(prop_instance_is_valid, ":instance_id"),
			(scene_prop_get_slot, ":inventory_unique_id", ":instance_id", slot_scene_prop_inventory_unique_id),
			(player_slot_eq, ":player_id", slot_player_accessing_unique_id, ":inventory_unique_id"),
			(scene_prop_get_slot, ":inventory_count", ":instance_id", slot_scene_prop_inventory_count),
			(gt, ":inventory_count", 0),
			(try_begin),
				(scene_prop_slot_eq, ":instance_id", slot_scene_prop_full_hit_points, 0),
			(else_try),
				(scene_prop_slot_eq, ":instance_id", slot_scene_prop_unlocked, 1),
			(else_try),
				(call_script, "script_scene_prop_get_owning_faction", ":instance_id"),
				(eq, reg1, -1),
			(else_try),
				(player_slot_eq, ":player_id", slot_player_faction_id, reg0),
				(player_slot_eq, ":player_id", slot_player_has_faction_item_key, 1),
			(else_try),
				(assign, ":inventory_count", 0),
			(try_end),
			(gt, ":inventory_count", 0),
			(scene_prop_get_slot, ":linked_scene_prop", ":instance_id", slot_scene_prop_linked_scene_prop),
			(try_begin), # for horse carts, use the specialized distance check
				(eq, ":linked_scene_prop", 0),
				(neg|scene_prop_slot_eq, ":instance_id", slot_scene_prop_required_horse, 0),
				(call_script, "script_cart_choose_action", ":agent_id", ":instance_id"),
				(neq, reg0, 0),
			(else_try), # for normal storage props
				(agent_get_position, pos1, ":agent_id"),
				(prop_instance_get_position, pos2, ":instance_id"),
				(eq, ":linked_scene_prop", 0),
				(get_sq_distance_between_positions, ":sq_distance", pos1, pos2),
				(le, ":sq_distance", sq(max_distance_to_use)),
			(else_try), # for ships, check agent is on board
				(gt, ":linked_scene_prop", 0),
				(prop_instance_is_valid, ":linked_scene_prop"),
				(neg|scene_prop_slot_eq, ":linked_scene_prop", slot_scene_prop_collision_kind, 0),
				(set_fixed_point_multiplier, 100),
				(position_transform_position_to_local, pos3, pos2, pos1),
				(position_get_y, ":relative_y", pos3),
				(is_between, ":relative_y", -500, 500),
				(position_get_z, ":relative_z", pos3),
				(is_between, ":relative_z", 0, 500),
				(position_get_x, ":relative_x", pos3),
				(scene_prop_get_slot, ":max_x", ":linked_scene_prop", slot_scene_prop_length),
				(store_mul, ":min_x", ":max_x", -1),
				(is_between, ":relative_x", ":min_x", ":max_x"),
			(else_try),
				(assign, ":inventory_count", 0),
			(try_end),
			(gt, ":inventory_count", 0),
			(player_set_slot, ":player_id", slot_player_accessing_instance_id, ":instance_id"),
			(try_begin), # for failures after this point, stay connected with the scene prop, to receive updates
				(store_add, ":inventory_end", slot_scene_prop_inventory_begin, ":inventory_count"),
				(this_or_next|is_between, ":from_slot", slot_scene_prop_inventory_begin, ":inventory_end"),
				(is_between, ":from_slot", slot_scene_prop_inventory_item_0, slot_scene_prop_inventory_item_0 + ek_gloves + 1),
				(this_or_next|is_between, ":to_slot", slot_scene_prop_inventory_begin, ":inventory_end"),
				(is_between, ":to_slot", slot_scene_prop_inventory_item_0, slot_scene_prop_inventory_item_0 + ek_gloves + 1),
				(scene_prop_slot_eq, ":instance_id", ":to_slot", 0),
				(ge, ":item_id", all_items_begin),
				(item_get_type, ":item_type", ":item_id"),
				(try_begin), # checks for equipping items on the agent
					(is_between, ":to_slot", slot_scene_prop_inventory_item_0, slot_scene_prop_inventory_end),
					(try_begin),
						(is_between, ":item_type", itp_type_head_armor, itp_type_hand_armor + 1),
						(store_add, ":correct_armor_slot", ":item_type", slot_scene_prop_inventory_item_0 + ek_head - itp_type_head_armor),
						(eq, ":to_slot", ":correct_armor_slot"),
					(else_try),
						(neg|is_between, ":item_type", itp_type_head_armor, itp_type_hand_armor + 1),
						(lt, ":to_slot", slot_scene_prop_inventory_item_0 + ek_item_3 + 1),
						#GGG:item chest
						#(try_begin),
						#  (prop_instance_get_variation_id_2, ":chest_id", ":instance_id"),
						#  (gt, ":chest_id", 0),
						#  (call_script, "script_cf_update_item_bank", ":player_id", ":instance_id", 0),
						#(try_end),
						#
					(else_try),
						(assign, ":item_id", -1),
					(try_end),
					(try_begin),
						(ge, ":item_id", all_items_begin),
						(agent_get_troop_id, ":troop_id", ":agent_id"),
						(call_script, "script_cf_check_troop_can_equip_item", ":troop_id", ":item_id", ":player_id"),
					(else_try),
						(assign, ":item_id", -1),
					(try_end),
				(else_try), # check that the item fits inside when storing in the inventory
					(item_get_slot, ":length", ":item_id", slot_item_length),
					(neg|scene_prop_slot_ge, ":instance_id", slot_scene_prop_inventory_max_length, ":length"),
					(assign, ":item_id", -1),
				(try_end),
				(ge, ":item_id", all_items_begin),
				(try_begin),
				#GGG:smithing system
					(prop_instance_get_scene_prop_kind, ":scene_prop_kind", ":instance_id"),
					(neq, ":scene_prop_kind", "spr_pw_process_smithing"),
				#
					(this_or_next|eq, ":item_type", itp_type_arrows),
					(this_or_next|eq, ":item_type", itp_type_bolts),
					(this_or_next|eq, ":item_type", itp_type_thrown),
					(eq, ":item_type", itp_type_crossbow),
					(assign, ":item_ammo", 0),
				(else_try),
					(assign, ":item_ammo", -1),
				(try_end),
				(assign, ":neg_from_mod_slot", 0),
				(try_begin), # remove items taken from the agent's equipment
					(ge, ":from_slot", slot_scene_prop_inventory_item_0),
					(store_add, ":from_equip_slot", ":from_slot", ek_item_0 - slot_scene_prop_inventory_item_0),
					(agent_get_item_slot, ":equip_item_id", ":agent_id", ":from_equip_slot"),
					(eq, ":equip_item_id", ":item_id"),
					(try_begin),
						(is_between, ":item_type", itp_type_head_armor, itp_type_hand_armor + 1),
						(store_sub, ":no_item_id", ":item_type", itp_type_head_armor),
						(val_add, ":no_item_id", "itm_no_head"),
						(call_script, "script_change_armor", ":agent_id", ":no_item_id"),
						(store_add, ":player_slot", ":from_slot", slot_player_equip_item_0 - slot_scene_prop_inventory_item_0),
						(player_set_slot, ":player_id", ":player_slot", 0),
					(else_try),
						(try_begin),
							(gt, ":item_ammo", -1),
							(agent_get_ammo_for_slot, ":item_ammo", ":agent_id", ":from_equip_slot"),
						(try_end),
						(val_add, ":from_equip_slot", 1),
						(agent_unequip_item, ":agent_id", ":item_id", ":from_equip_slot"),
					(try_end),
				(else_try), # removing items from the scene prop
					(lt, ":from_slot", slot_scene_prop_inventory_item_0),
					(scene_prop_slot_eq, ":instance_id", ":from_slot", ":item_id"),
					(scene_prop_set_slot, ":instance_id", ":from_slot", 0),
					(store_add, ":neg_from_mod_slot", ":from_slot", slot_scene_prop_inventory_mod_begin - slot_scene_prop_inventory_begin),
					(val_mul, ":neg_from_mod_slot", -1), # negative numbers in the _mod slots means the item was removed
					(try_begin),
						(gt, ":item_ammo", -1),
						(store_add, ":from_ammo_slot", ":from_slot", slot_scene_prop_inventory_ammo_begin - slot_scene_prop_inventory_begin),
						(scene_prop_get_slot, ":item_ammo", ":instance_id", ":from_ammo_slot"),
						(scene_prop_set_slot, ":instance_id", ":from_ammo_slot", 0),
					(try_end),
				(else_try),
					(assign, ":item_id", -1),
				(try_end),
				(ge, ":item_id", all_items_begin),
				(try_begin), # ignore empty ammo items (but not unloaded crossbows)
					(eq, ":item_ammo", 0),
					(neq, ":item_type", itp_type_crossbow),
				(else_try),
					(ge, ":to_slot", slot_scene_prop_inventory_item_0),
					(try_begin),
						(gt, ":item_ammo", -1), # add up current ammo before equipping the item
						(try_for_range, ":check_equip_slot", ek_item_0, ek_item_3 + 1),
							(agent_get_item_slot, ":check_item_id", ":agent_id", ":check_equip_slot"),
							(eq, ":check_item_id", ":item_id"),
							(agent_get_ammo_for_slot, ":check_ammo", ":agent_id", ":check_equip_slot"),
							(val_add, ":item_ammo", ":check_ammo"),
						(try_end),
					(try_end),
					(try_begin),
						(is_between, ":item_type", itp_type_head_armor, itp_type_hand_armor + 1),
						(call_script, "script_change_armor", ":agent_id", ":item_id", 0),
						(store_add, ":player_slot", ":to_slot", slot_player_equip_item_0 - slot_scene_prop_inventory_item_0),
						(player_set_slot, ":player_id", ":player_slot", ":item_id"),
					(else_try),
						(store_add, ":to_equip_slot", ":to_slot", ek_item_0 - slot_scene_prop_inventory_item_0 + 1),
						(agent_equip_item, ":agent_id", ":item_id", ":to_equip_slot"),
						(gt, ":item_ammo", -1),
						(agent_set_ammo, ":agent_id", ":item_id", ":item_ammo"),
					(try_end),
					(str_store_item_name, s98, ":item_id"),
					(str_store_player_username, s99, ":player_id"),
					(server_add_message_to_log, "@{s99} took {s98} from a chest"),
				(else_try),
					(scene_prop_set_slot, ":instance_id", ":to_slot", ":item_id"),
					(try_begin),
						(gt, ":item_ammo", -1),
						(store_add, ":to_ammo_slot", ":to_slot", slot_scene_prop_inventory_ammo_begin - slot_scene_prop_inventory_begin),
						(scene_prop_set_slot, ":instance_id", ":to_ammo_slot", ":item_ammo",),
					(try_end),
					(str_store_item_name, s98, ":item_id"),
					(str_store_player_username, s99, ":player_id"),
					(server_add_message_to_log, "@{s99} deposited {s98} to a chest"),
				(try_end),
				(try_begin), # ignore empty ammo items
					(eq, ":item_ammo", 0),
					(neq, ":item_type", itp_type_crossbow),
					(assign, ":to_mod_slot", -1),
				(else_try),
					(store_add, ":to_mod_slot", ":to_slot", slot_scene_prop_inventory_mod_begin - slot_scene_prop_inventory_begin),
				(try_end),
				(try_begin),
					(ge, ":neg_from_mod_slot", 0), # items from the agent equipment
					(multiplayer_send_3_int_to_player, ":player_id", server_event_scene_prop_set_slot, ":instance_id", ":to_mod_slot", ":item_id"),
					#GGG:item chest
					#(try_begin),
					#  (prop_instance_get_variation_id_2, ":chest_id", ":instance_id"),
					#  (gt, ":chest_id", 0),
					#  (call_script, "script_cf_update_item_bank", ":player_id", ":instance_id", 0),
					#(try_end),
					#
				(else_try), # items moved within the inventory
					(multiplayer_send_4_int_to_player, ":player_id", server_event_scene_prop_set_slot, ":instance_id", ":to_mod_slot", ":item_id", ":neg_from_mod_slot"),
					#GGG:item chest
					#(try_begin),
					#  (prop_instance_get_variation_id_2, ":chest_id", ":instance_id"),
					#  (gt, ":chest_id", 0),
					#  (call_script, "script_cf_update_item_bank", ":player_id", ":instance_id", 0),
					#(try_end),
					#
				(try_end),
				(this_or_next|lt, ":from_slot", slot_scene_prop_inventory_item_0), # don't send updates to other players when just shuffling agent equipment
				(lt, ":to_slot", slot_scene_prop_inventory_item_0),
				(try_begin), # when equipped on this agent, remove from inventory view of other players
					(ge, ":to_slot", slot_scene_prop_inventory_item_0),
					(assign, ":to_mod_slot", -1),
				(try_end),
				(get_max_players, ":max_players"),
				(try_for_range, ":other_player_id", 1, ":max_players"), # loop over all players currently looking at the same inventory
					(player_is_active, ":other_player_id"),
					(neq, ":other_player_id", ":player_id"),
					(player_slot_eq, ":other_player_id", slot_player_accessing_instance_id, ":instance_id"),
					#GGG:item chest
					(prop_instance_get_scene_prop_kind, ":scene_prop_kind", ":instance_id"),
					(neq, ":scene_prop_kind", "spr_pw_item_chest_b"), 
					#
					(try_begin),
						(ge, ":neg_from_mod_slot", 0),
						(multiplayer_send_3_int_to_player, ":other_player_id", server_event_scene_prop_set_slot, ":instance_id", ":to_mod_slot", ":item_id"),
					(else_try),
						(multiplayer_send_4_int_to_player, ":other_player_id", server_event_scene_prop_set_slot, ":instance_id", ":to_mod_slot", ":item_id", ":neg_from_mod_slot"),
					(try_end),
				(try_end),
				(scene_prop_get_slot, ":prune_time", ":instance_id", slot_scene_prop_prune_time),
				(try_begin), # if the inventory is stored in a spawned item, remove it if all items are taken out
					(gt, ":prune_time", 0),
					(is_between, ":from_slot", slot_scene_prop_inventory_begin, ":inventory_end"),
					(is_between, ":to_slot", slot_scene_prop_inventory_item_0, slot_scene_prop_inventory_item_0 + ek_gloves + 1),
					(try_for_range, ":inventory_slot", slot_scene_prop_inventory_begin, ":inventory_end"),
						(scene_prop_get_slot, ":item_id", ":instance_id", ":inventory_slot"),
						(ge, ":item_id", all_items_begin),
						(assign, ":inventory_end", -1),
					(try_end),
					(neq, ":inventory_end", -1),
					(scene_prop_set_prune_time, ":instance_id", 1),
				(else_try), # otherwise extend the time it will be removed if that is soon
					(store_mission_timer_a, ":time"),
					(val_add, ":time", 60),
					(gt, ":time", ":prune_time"),
					(scene_prop_set_prune_time, ":instance_id", 60),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_prune_time, ":time"),
				(try_end),
			(try_end),
		(else_try),
			(player_set_slot, ":player_id", slot_player_accessing_instance_id, 0),
		(try_end),
		]),
	
	#GGG:item chest
	("cf_update_item_bank", #handles item transferring from player to item bank or of while being ingame
	[(store_script_param, ":player_id", 1),
	(store_script_param, ":instance_id", 2),
	(store_script_param, ":status_get", 3),

	(prop_instance_is_valid, ":instance_id"),
	(player_get_unique_id, ":guid", ":player_id"),
	(assign, reg54, ":guid"),
	(try_begin),
		(prop_instance_get_scene_prop_kind, ":scene_prop_kind", ":instance_id"),
		(eq, ":scene_prop_kind", "spr_pw_item_chest_b"), 

		(try_begin),
			(eq, ":status_get", 1),
			(call_script, "script_cf_remove_bank_instance", ":instance_id"), #removes items out of item bank
		(else_try),
			(scene_prop_get_slot, reg1, ":instance_id", slot_scene_prop_inventory_begin + 0),
			(scene_prop_get_slot, reg2, ":instance_id", slot_scene_prop_inventory_begin + 1),
			(scene_prop_get_slot, reg3, ":instance_id", slot_scene_prop_inventory_begin + 2),
			(scene_prop_get_slot, reg4, ":instance_id", slot_scene_prop_inventory_begin + 3),
			(scene_prop_get_slot, reg5, ":instance_id", slot_scene_prop_inventory_begin + 4),
			(scene_prop_get_slot, reg6, ":instance_id", slot_scene_prop_inventory_begin + 5),
			(scene_prop_get_slot, reg7, ":instance_id", slot_scene_prop_inventory_begin + 6),
			(scene_prop_get_slot, reg8, ":instance_id", slot_scene_prop_inventory_begin + 7),
			(scene_prop_get_slot, reg9, ":instance_id", slot_scene_prop_inventory_begin + 8),
			(scene_prop_get_slot, reg10, ":instance_id", slot_scene_prop_inventory_begin + 9),
			(scene_prop_get_slot, reg11, ":instance_id", slot_scene_prop_inventory_begin + 10),
			(scene_prop_get_slot, reg12, ":instance_id", slot_scene_prop_inventory_begin + 11),
			(scene_prop_get_slot, reg13, ":instance_id", slot_scene_prop_inventory_begin + 12),
			(scene_prop_get_slot, reg14, ":instance_id", slot_scene_prop_inventory_begin + 13),
			(scene_prop_get_slot, reg15, ":instance_id", slot_scene_prop_inventory_begin + 14),
			(scene_prop_get_slot, reg16, ":instance_id", slot_scene_prop_inventory_begin + 15),
			(scene_prop_get_slot, reg17, ":instance_id", slot_scene_prop_inventory_begin + 16),
			(scene_prop_get_slot, reg18, ":instance_id", slot_scene_prop_inventory_begin + 17),
			(scene_prop_get_slot, reg19, ":instance_id", slot_scene_prop_inventory_begin + 18),
			(scene_prop_get_slot, reg20, ":instance_id", slot_scene_prop_inventory_begin + 19),
			(scene_prop_get_slot, reg21, ":instance_id", slot_scene_prop_inventory_begin + 20),
			(scene_prop_get_slot, reg22, ":instance_id", slot_scene_prop_inventory_begin + 21),
			(scene_prop_get_slot, reg23, ":instance_id", slot_scene_prop_inventory_begin + 22),
			(scene_prop_get_slot, reg24, ":instance_id", slot_scene_prop_inventory_begin + 23),
			(scene_prop_get_slot, reg25, ":instance_id", slot_scene_prop_inventory_begin + 24),
			(scene_prop_get_slot, reg26, ":instance_id", slot_scene_prop_inventory_begin + 25),
			(scene_prop_get_slot, reg27, ":instance_id", slot_scene_prop_inventory_begin + 26),
			(scene_prop_get_slot, reg28, ":instance_id", slot_scene_prop_inventory_begin + 27),
			(scene_prop_get_slot, reg29, ":instance_id", slot_scene_prop_inventory_begin + 28),
			(scene_prop_get_slot, reg30, ":instance_id", slot_scene_prop_inventory_begin + 29),
			(scene_prop_get_slot, reg31, ":instance_id", slot_scene_prop_inventory_begin + 30),
			(scene_prop_get_slot, reg32, ":instance_id", slot_scene_prop_inventory_begin + 31),
			(scene_prop_get_slot, reg33, ":instance_id", slot_scene_prop_inventory_begin + 32),

			(str_store_string, s21, "@item={reg1}|{reg2}|{reg3}|{reg4}|{reg5}|{reg6}|{reg7}|{reg8}|{reg9}|{reg10}|{reg11}|{reg12}|{reg13}|{reg14}|{reg15}|{reg16}|{reg17}|{reg18}|{reg19}|{reg20}|{reg21}|{reg22}|{reg23}|{reg24}|{reg25}|{reg26}|{reg27}|{reg28}|{reg29}|{reg30}|{reg31}|{reg32}|{reg33}"),

			(send_message_to_url, "@http://localhost/backendDsDvC/saveprivatechest.php?guid={reg54}&{s21}"),
			(server_add_message_to_log, "@Saved private chest: {reg54} items {s21} succesfully into the database."),
		(try_end),
	(try_end),
	]),

	("cf_remove_bank_instance",
	[(store_script_param, ":instance_id", 1), 
	(try_begin),
		(prop_instance_get_scene_prop_kind, ":scene_prop_kind", ":instance_id"),
		(eq, ":scene_prop_kind", "spr_pw_item_chest_b"), 
		(assign, reg1, 0),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 1, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 2, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 3, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 4, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 5, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 6, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 7, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 8, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 9, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 10, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 11, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 12, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 13, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 14, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 15, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 16, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 17, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 18, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 19, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 20, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 21, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 22, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 23, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 24, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 25, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 26, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 27, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 28, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 29, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 30, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 31, reg1),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 32, reg1),
	(try_end),
	]),
	###

	("cart_choose_action", # get the relative position of the agent to the cart to decide the action; returns reg0 as 0 = out of range, -1 = attach, 1 = access
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid

		(assign, reg0, 0),
		(set_fixed_point_multiplier, 100),
		(prop_instance_get_position, pos1, ":instance_id"),
		(agent_get_position, pos2, ":agent_id"),
		(position_get_z, ":height", pos2),
		(position_set_z, pos1, ":height"),
		(scene_prop_get_slot, ":access_offset", ":instance_id", slot_scene_prop_width),
		(assign, ":access_distance", ":access_offset"),
		(val_abs, ":access_distance"), # use the positive value for a radius
		(val_mul, ":access_distance", ":access_distance"), # squared
		(val_div, ":access_distance", 50), # distance * 2 / 100
		(get_sq_distance_between_positions, ":sq_distance", pos1, pos2),
		(try_begin), # if within range of the attach position (mesh origin)
			(le, ":sq_distance", ":access_distance"),
			(assign, reg0, 1),
			(agent_get_wielded_item, ":weapon", ":agent_id", 0),
			(eq, ":weapon", -1),
			(agent_get_wielded_item, ":shield", ":agent_id", 1),
			(eq, ":shield", -1),
			(assign, reg0, -1),
		(else_try), # if within range of the access position (the offset from the mesh origin)
			(lt, reg0, 1),
			(position_move_y, pos1, ":access_offset"),
			(get_sq_distance_between_positions, ":sq_distance", pos1, pos2),
			(le, ":sq_distance", ":access_distance"),
			(assign, reg0, 1),
		(try_end),
		]),

	#GGG:smithing system
	("cf_use_workbench", 
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid

		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(agent_is_alive, ":agent_id"),
		(agent_get_troop_id, ":troop_id", ":agent_id"),
		(store_skill_level, ":troop_skill_level", skl_engineer, ":troop_id"),
		(try_begin),
			(ge, ":troop_skill_level", 7),

			(assign, ":found_iron_piece", 0),
			(assign, ":found_iron_bar_long", 0),
			(assign, ":found_wood_pole_short", 0),
			(assign, ":found_wood_block", 0),
			(assign, ":found_leather_piece", 0),
			(assign, ":found_linen_cloth_small", 0),
            (assign, ":found_nanhguabis", 0),
            (assign, ":found_gold_nugget", 0),
            (assign, ":found_silver_bar", 0),

			(assign, ":loop_end", slot_scene_prop_inventory_begin + 11),
			(try_for_range, ":inventory_slot", slot_scene_prop_inventory_begin + 0, ":loop_end"),
				(scene_prop_get_slot, ":loop_item", ":instance_id", ":inventory_slot"), 
				(try_begin),
					(eq, ":loop_item", "itm_iron_piece"),
					(val_add, ":found_iron_piece", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_iron_bar_long"),
					(val_add, ":found_iron_bar_long", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_stick"),
					(val_add, ":found_wood_pole_short", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_board"),
					(val_add, ":found_wood_block", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_leather_piece"),
					(val_add, ":found_leather_piece", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_linen_cloth_small"),
					(val_add, ":found_linen_cloth_small", 1),
				(try_end),
                (try_begin),
					(eq, ":loop_item", "itm_cw_nanhguabis"),
					(val_add, ":found_nanhguabis", 1),
				(try_end),
                (try_begin),
					(eq, ":loop_item", "itm_gold_nugget"),
					(val_add, ":found_gold_nugget", 1),
				(try_end),
                (try_begin),
					(eq, ":loop_item", "itm_silver_bar"),
					(val_add, ":found_silver_bar", 1),
				(try_end),
			(try_end),

			(assign, ":sucess", 0),
			(try_begin),
			#bow
				(eq, ":found_wood_pole_short", 2),
				(eq, ":found_linen_cloth_small", 4),
				(assign, ":sucess", 1),
				(store_random_in_range, ":weapon", 0, 930),
				(try_begin),
					(is_between, ":weapon", 0,120),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hunting_bow"),
				(else_try),
					(is_between, ":weapon", 120,240),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_short_bow"),
				(else_try),
					(is_between, ":weapon", 240,360),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_nomad_bow"),
				(else_try),
					(is_between, ":weapon", 340,400),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_long_bow"),
				(else_try),
					(is_between, ":weapon", 400,500),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_bow"),
				(else_try),
					(is_between, ":weapon", 500,540),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_strong_bow"),
				(else_try),
					(is_between, ":weapon", 540,560),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_war_bow"),
				(else_try),
					(is_between, ":weapon", 560,575),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_imperial_war_bow"),
				(else_try),
					(is_between, ":weapon", 575,585),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_noldor_bow"),
				(else_try),
					(is_between, ":weapon", 585,600),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_imperial_long_bow"),
				(else_try),
					(is_between, ":weapon", 600,610),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_imperial_nomad_bow"),
				(else_try),
					(is_between, ":weapon", 610,640),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_imperial_short_bow"),
				(else_try),
					(is_between, ":weapon", 640,700),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_short_bow_skin"),
				(else_try),
					(is_between, ":weapon", 700,760),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hunting_bow_skin"),	
				(else_try),
					(is_between, ":weapon", 760,775),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_war_bow_skin"),		
				(else_try),
					(is_between, ":weapon", 775,800),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_long_bow_skin"),	
				(else_try),
					(is_between, ":weapon", 800,820),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_strong_bow_skin"),	
				(else_try),
					(is_between, ":weapon", 820,840),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_strong_bow_skin1"),	
				(else_try),
					(is_between, ":weapon", 840,900),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_nomad_bow_skin"),	
				(else_try), 
					(is_between, ":weapon", 900,930),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_nomad_bow_skin1"),	
				(try_end),
			(else_try),
			#betterbow
				(eq, ":found_wood_pole_short", 2),
				(eq, ":found_leather_piece", 4),
				(assign, ":sucess", 1),
				(store_random_in_range, ":weapon", 0, 78),
				(try_begin),	
					(is_between, ":weapon", 0,10),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_long_bow"),
				(else_try),
					(is_between, ":weapon", 10,30),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_bow"),
				(else_try),
					(is_between, ":weapon", 30,35),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_strong_bow"),
				(else_try),
					(is_between, ":weapon", 35,38),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_war_bow"),
				(else_try),
					(eq, ":weapon", 38),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_imperial_war_bow"),
				(else_try),
					(eq, ":weapon", 39),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_noldor_bow"),
				(else_try),
					(is_between, ":weapon", 40,45),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_imperial_long_bow"),
				(else_try),
					(is_between, ":weapon", 45,48),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_imperial_nomad_bow"),
				(else_try),
					(is_between, ":weapon", 48,51),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_imperial_short_bow"),
				(else_try),
					(is_between, ":weapon", 51,54),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_short_bow_skin"),
				(else_try),
					(is_between, ":weapon", 54,67),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hunting_bow_skin"),	
				(else_try),
					(eq, ":weapon", 67),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_war_bow_skin"),		
				(else_try),
					(is_between, ":weapon", 68,70),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_long_bow_skin"),	
				(else_try),
					(eq, ":weapon", 70),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_strong_bow_skin"),	
				(else_try),
					(is_between, ":weapon", 71,72),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_strong_bow_skin1"),	
				(else_try),
					(is_between, ":weapon", 72,74),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_bow_skin"),	
				(else_try),
					(is_between, ":weapon", 74,78),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_bow_skin1"),	
				(try_end),
				
			#crossbow
			(else_try),
				(eq, ":found_wood_block", 3),
				(eq, ":found_wood_pole_short", 2),
				(eq, ":found_iron_piece", 2),
				(assign, ":sucess", 1),
				(store_random_in_range, ":weapon", 0, 627),
				(try_begin),
					(is_between, ":weapon", 0,60),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hunting_crossbow"),
				(else_try),
					(is_between, ":weapon", 60,120),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_light_crossbow"),
				(else_try),
					(is_between, ":weapon", 120,180),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_crossbow"),
				(else_try),
					(is_between, ":weapon", 180,220),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_crossbow"),
				(else_try),
					(is_between, ":weapon", 220,240),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sniper_crossbow"),
				(else_try),
					(eq, ":weapon", 240),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_two_repeating_crossbow"),
				(else_try),
					(is_between, ":weapon", 241,427),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_automatic_crossbow"),
				(else_try),
					(is_between, ":weapon", 427,487),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_crossbow_skin"),
				(else_try),
					(is_between, ":weapon", 487,547),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_crossbow_skin1"),
				(else_try),
					(is_between, ":weapon", 547,607),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_light_crossbow_skin"),	
				(else_try),
					(is_between, ":weapon", 607,627),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_crossbow_skin"),			
				(try_end),
			#sword
			(else_try),
				(eq, ":found_iron_piece", 2),
				(eq, ":found_iron_bar_long", 1),
				(eq, ":found_linen_cloth_small", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":weapon", 0, 2735),
				(try_begin),
					(is_between, ":weapon", 0,50),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_falchion"),
				(else_try),
					(is_between, ":weapon", 50,100),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_curved_sword"),
				(else_try),
					(is_between, ":weapon", 100,150),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_medieval_a"),
				(else_try),
					(is_between, ":weapon", 150,200),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_medieval_b_small"),
				(else_try),
					(is_between, ":weapon", 200,250),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_medieval_c_long"),
				(else_try),
					(is_between, ":weapon", 250,300),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_medieval_d_long"),
				(else_try),
					(is_between, ":weapon", 300,350),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_viking_c"),
				(else_try),
					(is_between, ":weapon", 350,400),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_viking_b_small"),
				(else_try),
					(is_between, ":weapon", 400,450),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_viking_a_long"),
				(else_try),
					(is_between, ":weapon", 450,500),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_arabian_sword_a"),
				(else_try),
					(is_between, ":weapon", 500,550),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_arabian_sword_b"),
				(else_try),
					(is_between, ":weapon", 550,600),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_arabian_sword_c"),
				(else_try),
					(is_between, ":weapon", 600,650),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_arabian_sword_d"),
				(else_try),
					(is_between, ":weapon", 650,700),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_scimitar"),
				(else_try),
					(is_between, ":weapon",700,730),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_scimitar_b"),
				(else_try),
					(is_between, ":weapon", 730,780),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_sword_c"),
				(else_try),
					(is_between, ":weapon", 780,810),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_sword_d"),
				(else_try),
					(is_between, ":weapon", 810,835),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_sword_two_handed_a"),
				(else_try),
					(is_between, ":weapon", 835,860),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_two_handed_cleaver"),
				(else_try),
					(is_between, ":weapon", 860,910),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_military_cleaver_b"),
				(else_try),
					(is_between, ":weapon", 910,960),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_military_cleaver_c"),
				(else_try),
					(is_between, ":weapon", 960,1010),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bastard_sword_a"),
				(else_try),
					(is_between, ":weapon", 1010,1050),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bastard_sword_b"),
				(else_try),
					(is_between, ":weapon", 1050,1070),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_two_handed_b"),
				(else_try),
					(is_between, ":weapon", 1070,1080),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_two_handed_a"),
				(else_try),
					(is_between, ":weapon", 1080,1210),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_strange_sword"),
				(else_try),
					(is_between, ":weapon", 1210,1240),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_strange_great_sword"),
				(else_try),
					(is_between, ":weapon", 1240,1290),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_strange_short_sword"),
				(else_try),
					(is_between, ":weapon", 1290,1300),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_of_war"),
				(else_try),
					(is_between, ":weapon", 1300,1350),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_nomad_sabre"),
				(else_try),
					(is_between, ":weapon", 1350,1400),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_nordic_sword"),
				(else_try),
					(is_between, ":weapon", 1400,1450),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword"),
				(else_try),
					(is_between, ":weapon", 1450,1500),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_viking_3_small"),
				(else_try),
					(is_between, ":weapon", 1500,1550),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_viking_2"),
				(else_try),
					(is_between, ":weapon", 1550,1600),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_viking_c_long"),
				(else_try),
					(is_between, ":weapon", 1600,1650),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_medieval_a_long"),
				(else_try),
					(is_between, ":weapon", 1650,1700),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_medieval_b"),
				(else_try),
					(is_between, ":weapon", 1700,1750),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_medieval_c_small"),
				(else_try),
					(is_between, ":weapon", 1750,1800),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_medieval_d"),
				(else_try),
					(is_between, ":weapon", 1800,1850),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_medieval_e"),
				(else_try),
					(is_between, ":weapon", 1850,1900),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_khergit_1"),
				(else_try),
					(is_between, ":weapon", 1900,1950),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_khergit_3"),
                (else_try),
					(is_between, ":weapon", 1950,1965),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_sword_two_handed_a_skin"),
                (else_try),
					(is_between, ":weapon", 1965,1970),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_two_handed_a_skin"),    
                (else_try),
					(is_between, ":weapon", 1970,1975),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_two_handed_a_skin1"),
                 (else_try),
					(is_between, ":weapon", 1975,1985),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_nanhguabis"),   
				(else_try),
					(is_between, ":weapon", 1985,2035),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_medieval_a_skin"),
					(else_try),
					(is_between, ":weapon", 2035,2085),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_medieval_a_long_skin"),
					(else_try),
					(is_between, ":weapon", 2085,2110),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_medieval_b_skin"),
					(else_try),
					(is_between, ":weapon", 2110,2135),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_medieval_b_skin1"),
					(else_try),
					(is_between, ":weapon", 2135,2185),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_medieval_b_small_skin"),
					(else_try),
					(is_between, ":weapon", 2185,2235),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_medieval_d_skin"),
					(else_try),
					(is_between, ":weapon", 2235,2260),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_medieval_d_long_skin"),
					(else_try),
					(is_between, ":weapon", 2260,2310),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_medieval_e_skin"),
					(else_try),
					(is_between, ":weapon", 2310,2360),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_medieval_e_skin1"),
					(else_try),
					(is_between, ":weapon", 2360,2385),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_scimitar_skin"),
					(else_try),
					(is_between, ":weapon", 2385,2400),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_scimitar_b_skin"),
					(else_try),
					(is_between, ":weapon", 2400,2425),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_arabian_sword_a_skin"),
					(else_try),
					(is_between, ":weapon", 2425,2435),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_two_handed_cleaver_skin"),
					(else_try),
					(is_between, ":weapon", 2435,2455),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_military_cleaver_b_skin"),
					(else_try),
					(is_between, ":weapon", 2455,2475),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_military_cleaver_c_skin"),
					(else_try),
					(is_between, ":weapon", 2475,2495),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_khergit_1_skin"),
					(else_try),
					(is_between, ":weapon", 2495,2520),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_khergit_1_skin1"),
					(else_try),
					(is_between, ":weapon", 2520,2540),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_sword_c_skin"),
					(else_try),
					(is_between, ":weapon", 2540,2560),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_khergit_3_skin"),
					(else_try),
					(is_between, ":weapon", 2560,2575),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sword_khergit_3_skin1"),
					(else_try),
					(is_between, ":weapon", 2575,2590),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_sword_d_skin"),
					(else_try),
					(is_between, ":weapon", 2590,2615),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_sword_d_skin1"),
					(else_try),
					(is_between, ":weapon", 2615,2625),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bastard_sword_a_skin"),
					(else_try),
					(is_between, ":weapon", 2625,2655),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bastard_sword_a_skin2"),
					(else_try),
					(is_between, ":weapon", 2655,2680),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bastard_sword_b_skin"),
					(else_try),
					(is_between, ":weapon", 2680,2705),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bastard_sword_b_skin1"),
					(else_try),
					(is_between, ":weapon", 2705,2725),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bastard_sword_b_skin2"),
					(else_try),
					(is_between, ":weapon", 2725,2735),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bastard_sword_b_skin3"),
					
				(try_end),
			#axe&hammmer
			(else_try),
				(eq, ":found_iron_piece", 2),
				(eq, ":found_wood_pole_short", 1),
				(eq, ":found_linen_cloth_small", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":weapon", 0, 690),
				(try_begin),
					(is_between, ":weapon", 0,10),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_spiked_club"),
				(else_try),
					(is_between, ":weapon", 10,20),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_practice_sword"),
				(else_try),
					(is_between, ":weapon", 20,40),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_winged_mace"),
				(else_try),
					(is_between, ":weapon", 40,60),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_spiked_mace"),
				(else_try),
					(is_between, ":weapon", 60,80),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_mace_2"),
				(else_try),
					(is_between, ":weapon", 80,100),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_mace_4"),
				(else_try),
					(is_between, ":weapon", 100,120),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_club_with_spike_head"),
				(else_try),
					(is_between, ":weapon", 120,140),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_long_spiked_club"),
				(else_try),
					(is_between, ":weapon", 140,160),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_long_hafted_spiked_mace"),
				(else_try),
					(is_between, ":weapon",160,180),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_fighting_pick"),
				(else_try),
					(is_between, ":weapon", 180,200),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_military_pick"),
				(else_try),
					(is_between, ":weapon", 200,220),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_military_sickle"),
				(else_try),
					(is_between, ":weapon", 220240),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_military_hammer"),
				(else_try),
					(is_between, ":weapon", 240,260),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_morningstar"),
				(else_try),
					(is_between, ":weapon", 260,280),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_one_handed_war_axe_b"),
				(else_try),
					(is_between, ":weapon", 280,300),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_one_handed_battle_axe_a"),
				(else_try),
					(is_between, ":weapon", 300,320),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_one_handed_battle_axe_b"),
				(else_try),
					(is_between, ":weapon", 320,340),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_one_handed_battle_axe_c"),
				(else_try),
					(is_between, ":weapon", 340,360),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_war_axe"),
				(else_try),
					(is_between, ":weapon", 360,380),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_great_axe"),
				(else_try),
					(is_between, ":weapon", 380,400),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battle_axe"),
				(else_try),
					(is_between, ":weapon", 400,420),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_double_axe"),
				(else_try),
					(is_between, ":weapon", 420,440),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_axe"),
				(else_try),
					(is_between, ":weapon", 440,480),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_maul"),
				(else_try),
					(is_between, ":weapon", 480,500),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sledgehammer"),
				(else_try),
					(is_between, ":weapon", 500,520),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_warhammer"),
			(else_try),
					(is_between, ":weapon", 520,540),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_mace_pear"),
			(else_try),
					(is_between, ":weapon", 540,560),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_old_winged_mace"),
			(else_try),
					(is_between, ":weapon", 560,580),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_mace_morningstar"),
			(else_try),
					(is_between, ":weapon", 580,600),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_mace_small_d"),
			(else_try),
					(is_between, ":weapon", 600,620),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_flanged_mace"),
			(else_try),
					(is_between, ":weapon", 620,640),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_one_handed_war_axe_a"),
			(else_try),
					(is_between, ":weapon", 640,660),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_mace_1"),
			(else_try),
					(is_between, ":weapon", 660,680),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_mace_3"),
            (else_try),
					(is_between, ":weapon", 680,685),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_knight_mace"),       
            (else_try),
					(is_between, ":weapon", 685,690),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_ba_knight_long_axe"),      
				(try_end),
			#pole&two hand
			(else_try),
				(eq, ":found_wood_pole_short", 3),
				(eq, ":found_iron_piece", 2),
				(assign, ":sucess", 1),
				(store_random_in_range, ":weapon", 0, 45),
				(try_begin),
					(eq, ":weapon", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_two_handed_axe"),
				(else_try),
					(eq, ":weapon", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_two_handed_battle_axe"),
				(else_try),
					(eq, ":weapon", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_shortened_voulge"),
				(else_try),
					(eq, ":weapon", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bardiche"),
				(else_try),
					(eq, ":weapon", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_shortened_military_scythe"),
				(else_try),
					(eq, ":weapon", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_long_axe_a"),
				(else_try),
					(eq, ":weapon", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_glaive"),
				(else_try),
					(eq, ":weapon", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_staff"),
				(else_try),
					(eq, ":weapon", 8),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_quarter_staff"),
				(else_try),
					(eq, ":weapon", 9),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_shortened_spear"),
				(else_try),
					(eq, ":weapon", 10),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_spear"),
				(else_try),
					(eq, ":weapon", 11),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bamboo_spear"),
				(else_try),
					(eq, ":weapon", 12),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_war_spear"),
				(else_try),
					(eq, ":weapon", 13),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_light_lance"),
				(else_try),
					(eq, ":weapon", 14),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lance"),
				(else_try),
					(eq, ":weapon", 15),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_lance"),
				(else_try),
					(eq, ":weapon", 16),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_great_lance"),
				(else_try),
					(eq, ":weapon", 17),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_awlpike"),
				(else_try),
					(eq, ":weapon", 18),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_awlpike_long"),
				(else_try),
					(eq, ":weapon", 19),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_pike"),
				(else_try),
					(eq, ":weapon", 20),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bec_de_corbin_a"),
				(else_try),
					(eq, ":weapon", 21),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_awlpike_long"),
				(else_try),
					(eq, ":weapon", 22),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_poleaxe"),
				(else_try),
					(eq, ":weapon", 23),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_voulge"),
				(else_try),
					(eq, ":weapon", 24),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battle_pike"),
				(else_try),
					(eq, ":weapon", 25),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_double_sided_lance"),
				(else_try),
					(eq, ":weapon", 26),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_pitch_fork"),
				(else_try),
					(eq, ":weapon", 27),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battle_fork"),
				(else_try),
					(eq, ":weapon", 28),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_military_fork"),
				(else_try),
					(eq, ":weapon", 29),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battle_scythe"),
				(else_try),
					(eq, ":weapon", 30),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_iron_bardiche"),
				(else_try),
					(eq, ":weapon", 31),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hafted_blade_b"),
				(else_try),
					(eq, ":weapon", 32),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hafted_blade_a"),
				(else_try),
					(eq, ":weapon", 33),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_polehammer"),
				(else_try),
					(eq, ":weapon", 34),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_voulge_duplicate"),
				(else_try),
					(eq, ":weapon", 35),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_long_bardiche"),
				(else_try),
					(eq, ":weapon", 36),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_great_long_bardiche"),
				(else_try),
					(eq, ":weapon", 37),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_great_bardiche"),
				(else_try),
					(eq, ":weapon", 38),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_military_scythe"),
				(else_try),
					(eq, ":weapon", 39),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_spear_e_3_25m"),
				(else_try),
					(eq, ":weapon", 40),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_long_hafted_knobbed_mace"),
				(else_try),
					(eq, ":weapon", 41),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sarranid_two_handed_mace_1"),
				(else_try),
					(eq, ":weapon", 42),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_long_axe"),
				(else_try),
					(eq, ":weapon", 43),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_long_axe_b"),
				(else_try),
					(eq, ":weapon", 44),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_sword_two_handed_b"),
				(try_end),
			#shield
			(else_try),
				(eq, ":found_wood_block", 3),
				(eq, ":found_iron_piece", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":weapon", 0, 18),
				(try_begin),
					(eq, ":weapon", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_tab_shield_round_c"),
				(else_try),
					(eq, ":weapon", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_tab_shield_round_d"),
				(else_try),
					(eq, ":weapon", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_tab_shield_round_e"),
				(else_try),
					(eq, ":weapon", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_tab_shield_kite_c"),
				(else_try),
					(eq, ":weapon", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_tab_shield_kite_d"),
				(else_try),
					(eq, ":weapon", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_tab_shield_kite_cav_a"),
				(else_try),
					(eq, ":weapon", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_tab_shield_kite_cav_b"),
				(else_try),
					(eq, ":weapon", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_tab_shield_heater_c"),
				(else_try),
					(eq, ":weapon", 8),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_tab_shield_heater_d"),
				(else_try),
					(eq, ":weapon", 9),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_tab_shield_heater_cav_a"),
				(else_try),
					(eq, ":weapon", 10),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_tab_shield_heater_cav_b"),
				(else_try),
					(eq, ":weapon", 11),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_tab_shield_pavise_c"),
				(else_try),
					(eq, ":weapon", 12),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_tab_shield_pavise_d"),
				(else_try),
					(eq, ":weapon", 13),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_tab_shield_small_round_a"),
				(else_try),
					(eq, ":weapon", 14),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_tab_shield_small_round_b"),
				(else_try),
					(eq, ":weapon", 15),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_tab_shield_small_round_c"),
				(else_try),
					(eq, ":weapon", 16),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_leather_covered_round_shield"),
				(else_try),
					(eq, ":weapon", 17),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_shield_kite_i"),
				(try_end),
			#helmet
			(else_try),
				(eq, ":found_iron_piece", 4),
				(eq, ":found_leather_piece", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":weapon", 0, 3255),
				(try_begin),
					(is_between, ":weapon", 0,100),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_skullcap"),
				(else_try),
					(is_between, ":weapon", 100,200),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_vaegir_fur_helmet"),
				(else_try),
					(is_between, ":weapon", 200,250),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bishop_mitre"),
				(else_try),
					(is_between, ":weapon", 250,350),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_mail_coif"),
				(else_try),
					(is_between, ":weapon", 350,450),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_footman_helmet"),
				(else_try),
					(is_between, ":weapon", 450,550),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sarranid_horseman_helmet"),
				(else_try),
					(is_between, ":weapon", 550,650),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_nasal_helmet"),
				(else_try),
					(is_between, ":weapon", 650,750),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_norman_helmet"),
				(else_try),
					(is_between, ":weapon", 750,850),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_nordic_footman_helmet"),
				(else_try),
					(is_between, ":weapon", 850,950),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_war_helmet"),
				(else_try),
					(is_between, ":weapon", 950,1050),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_segmented_helmet"),
				(else_try),
					(is_between, ":weapon", 1050,1150),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_vaegir_spiked_helmet"),
				(else_try),
					(is_between, ":weapon", 1150,1250),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_helmet_with_neckguard"),
				(else_try),
					(is_between, ":weapon", 1250,1350),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_flat_topped_helmet"),
				(else_try),
					(is_between, ":weapon", 1350,1450),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_nordic_fighter_helmet"),
				(else_try),
					(is_between, ":weapon", 1450,1550),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_kettle_hat"),
				(else_try),
					(is_between, ":weapon", 1550,1650),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sarranid_helmet1"),
				(else_try),
					(is_between, ":weapon", 1650,1750),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_vaegir_lamellar_helmet"),
				(else_try),
					(is_between, ":weapon", 1750,1850),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_spiked_helmet"),
				(else_try),
					(is_between, ":weapon", 1850,1950),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sarranid_mail_coif"),
				(else_try),
					(is_between, ":weapon", 1950,2050),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_nordic_huscarl_helmet"),
				(else_try),
					(is_between, ":weapon", 2050,2150),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bascinet"),
				(else_try),
					(is_between, ":weapon", 2150,2250),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bascinet_2"),
				(else_try),
					(is_between, ":weapon", 2250,2350),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bascinet_3"),
				(else_try),
					(is_between, ":weapon", 2350,2400),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_vaegir_noble_helmet"),
				(else_try),
					(is_between, ":weapon", 2400,2445),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_guard_helmet"),
				(else_try),
					(is_between, ":weapon", 2445,2490),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sarranid_veiled_helmet"),
				(else_try),
					(is_between, ":weapon", 2940,2535),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_vaegir_war_helmet"),
				(else_try),
					(is_between, ":weapon", 2535,2575),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_nordic_warlord_helmet"),
				(else_try),
					(is_between, ":weapon", 2575,2600),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bishop_helm"),
				(else_try),
					(is_between, ":weapon", 2600,2630),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_full_helm"),
				(else_try),
					(is_between, ":weapon", 2630,2660),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_vaegir_mask"),
				(else_try),
					(is_between, ":weapon", 2660,2690),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_vaegir_mask_b"),
				(else_try),
					(is_between, ":weapon", 2690,2710),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_great_helmet"),
				(else_try),
					(is_between, ":weapon", 2710,2725),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_winged_great_helmet"),
				(else_try),
					(is_between, ":weapon", 2725,2800),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_strange_helmet"),
				(else_try),
					(is_between, ":weapon", 2800,2850),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sipahi_helmet_a"),
				(else_try),
					(is_between, ":weapon", 2850,2900),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_byzantion_helmet_a"),
				(else_try),
					(is_between, ":weapon", 2900,2950),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_rus_helmet_a"),
				(else_try),
					(is_between, ":weapon", 2950,3000),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_shahi"),
				(else_try),
					(is_between, ":weapon", 3000,3050),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_rabati"),
				(else_try),
					(is_between, ":weapon", 3050,3100),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_guard_helmet"),
				(else_try),
					(is_between, ":weapon", 3100,3150),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_cavalry_helmet"),
				(else_try),
					(is_between, ":weapon", 3150,3250),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_steel_shield"),
				(else_try),
					(is_between, ":weapon", 3250, 3255),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_nanhguabis"),
				(try_end),
			#armor
			(else_try),
				(eq, ":found_iron_bar_long", 4),
				(eq, ":found_linen_cloth_small", 4),
				(eq, ":found_leather_piece", 2),
				(assign, ":sucess", 1),
				(store_random_in_range, ":weapon", 0, 2480),
				(try_begin),
					(is_between, ":weapon", 0,100),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sarranid_cavalry_robe"),
				(else_try),
					(is_between, ":weapon", 100,200),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_studded_leather_coat"),
				(else_try),
					(is_between, ":weapon", 200,300),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_byrnie"),
				(else_try),
					(is_between, ":weapon", 300,400),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_haubergeon"),
				(else_try),
					(is_between, ":weapon", 400,500),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_arabian_armor_b"),
				(else_try),
					(is_between, ":weapon", 500,600),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lamellar_vest"),
				(else_try),
					(is_between, ":weapon", 600,700),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lamellar_vest_khergit"),
				(else_try),
					(is_between, ":weapon", 700,800),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_mail_shirt"),
				(else_try),
					(is_between, ":weapon", 800,900),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_mail_hauberk"),
				(else_try),
					(is_between, ":weapon", 900.1000),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sarranid_mail_shirt"),
				(else_try),
					(is_between, ":weapon", 1000,1050),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bishop_armor"),
				(else_try),
					(is_between, ":weapon", 1050,1120),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_mail_with_surcoat"),
				(else_try),
					(is_between, ":weapon", 1120,1265),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_surcoat_over_mail"),
				(else_try),
					(is_between, ":weapon", 1260,1295),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_brigandine_red"),
				(else_try),
					(is_between, ":weapon", 1295,1330),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_mamluke_mail"),
				(else_try),
					(is_between, ":weapon", 1330,1365),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lamellar_armor"),
				(else_try),
					(is_between, ":weapon", 1365,1400),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_scale_armor"),
				(else_try),
					(is_between, ":weapon", 1400,1435),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_banded_armor"),
				(else_try),
					(is_between, ":weapon", 1435,1475),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cuir_bouilli"),
				(else_try),
					(is_between, ":weapon", 1475,1500),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_coat_of_plates"),
				(else_try),
					(is_between, ":weapon", 1500,1525),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_coat_of_plates_red"),
				(else_try),
					(is_between, ":weapon", 1525,1545),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_elite_armor"),
				(else_try),
					(is_between, ":weapon", 1545,1565),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_vaegir_elite_armor"),
				(else_try),
					(is_between, ":weapon", 1565,1585),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sarranid_elite_armor"),
				(else_try),
					(is_between, ":weapon", 1585,1600),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_plate_armor"),
				(else_try),
					(is_between, ":weapon", 1600,1650),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_strange_armor"),
				(else_try),
					(is_between, ":weapon", 1650,1750),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_brigandine_a"),
				(else_try),
					(is_between, ":weapon", 1750,1850),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_haubergeon_a"),
				(else_try),
					(is_between, ":weapon", 1850,1950),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_haubergeon_b"),
				(else_try),
					(is_between, ":weapon", 1950,2050),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_std_lthr_coat"),
				(else_try),
					(is_between, ":weapon", 2050,2150),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_p_lamellar_vest"),
				(else_try),
					(is_between, ":weapon", 2150,2200),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_red_tourney_armor"),
				(else_try),
					(is_between, ":weapon", 2200,2300),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lamellar_cuirass"),
				(else_try),
					(is_between, ":weapon", 2300,2325),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_guard_armor"),
				(else_try),
					(is_between, ":weapon", 2325,2350),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_light_mail_and_plate"),
				(else_try),
					(is_between, ":weapon", 2350,2400),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_mail_and_plate"),
				(else_try),
					(is_between, ":weapon", 2400,2420),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_mail_plate_armor"),
				(else_try),
					(is_between, ":weapon", 2420,2425),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_2_plate_armor"),
				(else_try),
					(is_between, ":weapon", 2425,2440),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_brigandine_red_mail"),
				(else_try),
					(is_between, ":weapon", 2440,2470),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_surcoat_over_mail_skin"),
				(else_try),
					(is_between, ":weapon", 2470, 2480),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_nanhguabis"),
                (try_end),
			#shoes
			(else_try),
				(eq, ":found_iron_piece", 2),
				(eq, ":found_leather_piece", 3),
				(assign, ":sucess", 1),
				(store_random_in_range, ":weapon", 0, 11),
				(try_begin),
					(eq, ":weapon", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sarranid_boots_c"),
				(else_try),
					(eq, ":weapon", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_splinted_leather_greaves"),
				(else_try),
					(eq, ":weapon", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bishop_chausses"),
				(else_try),
					(eq, ":weapon", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_mail_chausses"),
				(else_try),
					(eq, ":weapon", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_splinted_greaves"),
				(else_try),
					(eq, ":weapon", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sarranid_boots_d"),
				(else_try),
					(eq, ":weapon", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_mail_boots"),
				(else_try),
					(eq, ":weapon", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_iron_greaves"),
				(else_try),
					(eq, ":weapon", 8),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_plate_boots"),
				(else_try),
					(eq, ":weapon", 9),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_strange_boots"),
				(else_try),
					(eq, ":weapon", 10),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_guard_boots"),
				(try_end),
			#gloves
			(else_try),
				(eq, ":found_iron_piece", 1),
				(eq, ":found_leather_piece", 2),
				(assign, ":sucess", 1),
				(store_random_in_range, ":weapon", 0, 56),
				(try_begin),
					(is_between, ":weapon", 0,20),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bishop_gloves"),
				(else_try),
					(is_between, ":weapon", 20,40,),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_mail_mittens"),
				(else_try),
					(is_between, ":weapon", 40,50),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lamellar_gauntlets"),
				(else_try),
					(is_between, ":weapon", 50,55),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_scale_gauntlets"),
				(else_try),
					(is_between, ":weapon", 55,56),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_gauntlets"),
				(try_end),
							#cw_armor
			(else_try),
				(eq, ":found_nanhguabis", 2),
				(eq, ":found_gold_nugget", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":weapon", 0, 19),
				(try_begin),
					(eq, ":weapon", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_plate_falcon_hood"),
				(else_try),
					(eq, ":weapon", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_armor8"),
				(else_try),
					(eq, ":weapon", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_boot7"),
				(else_try),
					(eq, ":weapon", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_dmsg_steel_armor"),
				(else_try),
					(eq, ":weapon", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_dmsg_steel_greaves"),
				(else_try),
					(eq, ":weapon", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_kof_cpt_helm"),
				(else_try),
					(eq, ":weapon", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_kof_cpt_armor"),
				(else_try),
					(eq, ":weapon", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_plate_falcon"),
				(else_try),
					(eq, ":weapon", 8),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_plate_boots_falcon"),
				(else_try),
					(eq, ":weapon", 9),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_falcon_heavy_lance"),
				(else_try),
					(eq, ":weapon", 10),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_falcon_kite_shield"),
				(else_try),
					(eq, ":weapon", 11),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_leader_helmet"),
				(else_try),
					(eq, ":weapon", 12),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_armor12"),
				(else_try),
					(eq, ":weapon", 13),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_kof_cpt_gauntlets"),
				(else_try),
					(eq, ":weapon", 14),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_boot3"),
				(else_try),
					(eq, ":weapon", 15),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_steppe_cap_heavy"),
				(else_try),
					(eq, ":weapon", 16),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_steppe_mask_heavy"),
				(else_try),
					(eq, ":weapon", 17),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_lamellar_armor_dc"),
				(else_try),
					(eq, ":weapon", 18),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_steppe_glove_hav"),
				(try_end),
			#cw_weapon
			(else_try),
				(eq, ":found_nanhguabis", 2),
				(eq, ":found_silver_bar", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":weapon", 0, 6),
				(try_begin),
					(eq, ":weapon", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_falcon_heavy_lance"),
				(else_try),
					(eq, ":weapon", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_gudar_fist_x"),
				(else_try),
					(eq, ":weapon", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_corprus_flamberg"),
				(else_try),
					(eq, ":weapon", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_ironcramp_staff"),
				(else_try),
					(eq, ":weapon", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_greataxe_adjudgment"),
				(else_try),
					(eq, ":weapon", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_shhuzhi_shield"),
				(try_end),
			#allcw
			(else_try),
				(eq, ":found_nanhguabis", 2),
				(eq, ":found_iron_bar_long", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":weapon", 0, 33),
				(try_begin),
					(eq, ":weapon", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_plate_falcon_hood"),
				(else_try),
					(eq, ":weapon", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_armor8"),
				(else_try),
					(eq, ":weapon", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_assassin_gloves"),
				(else_try),
					(eq, ":weapon", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_boot7"),
				(else_try),
					(eq, ":weapon", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_dmsg_steel_armor"),
				(else_try),
					(eq, ":weapon", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_dmsg_steel_greaves"),
				(else_try),
					(eq, ":weapon", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_dmsg_steel_gauntlets"),
				(else_try),
					(eq, ":weapon", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_kof_cpt_helm"),
				(else_try),
					(eq, ":weapon", 8),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_kof_cpt_armor"),
				(else_try),
					(eq, ":weapon", 9),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_kof_cpt_gauntlets"),
				(else_try),
					(eq, ":weapon", 10),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_kof_cpt_greaves"),
				(else_try),
					(eq, ":weapon", 11),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_plate_falcon"),
				(else_try),
					(eq, ":weapon", 12),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_plate_boots_falcon"),
				(else_try),
					(eq, ":weapon", 13),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_falcon_gauntlets"),
				(else_try),
					(eq, ":weapon", 14),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_falcon_heavy_lance"),
				(else_try),
					(eq, ":weapon", 15),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_falcon_kite_shield"),
				(else_try),
					(eq, ":weapon", 16),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_leader_helmet"),
				(else_try),
					(eq, ":weapon", 17),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_armor12"),
				(else_try),
					(eq, ":weapon", 18),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_kof_cpt_gauntlets"),
				(else_try),
					(eq, ":weapon", 19),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_boot3"),
				(else_try),
					(eq, ":weapon", 20),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_steppe_cap_heavy"),
				(else_try),
					(eq, ":weapon", 21),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_steppe_mask_heavy"),
				(else_try),
					(eq, ":weapon", 22),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_lamellar_armor_dc"),
				(else_try),
					(eq, ":weapon", 23),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_steppe_glove_hav"),
				(else_try),
					(eq, ":weapon", 24),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_yanyuedao"),
				(else_try),
					(eq, ":weapon", 25),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_knight_mace"),
				(else_try),
					(eq, ":weapon", 26),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_ba_knight_long_axe"),
				(else_try),
					(eq, ":weapon", 27),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_gudar_fist_x"),
				(else_try),
					(eq, ":weapon", 28),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_corprus_flamberg"),
				(else_try),
					(eq, ":weapon", 29),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_ironcramp_staff"),
				(else_try),
					(eq, ":weapon", 30),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_trtd"),
				(else_try),
					(eq, ":weapon", 31),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_helm_invisible"),
				(else_try),
					(eq, ":weapon", 32),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_nanguatou_had"),
				(try_end),
				#hand
			(else_try),
				(eq, ":found_nanhguabis", 1),
				(eq, ":found_iron_bar_long", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":weapon", 0, 5),
				(try_begin),
					(eq, ":weapon", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_assassin_gloves"),
				(else_try),
					(eq, ":weapon", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_dmsg_steel_gauntlets"),
				(else_try),
					(eq, ":weapon", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_falcon_gauntlets"),
				(else_try),
					(eq, ":weapon", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_kof_cpt_gauntlets"),
				(else_try),
					(eq, ":weapon", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cw_steppe_glove_hav"),
				(try_end),
			#ammo
			(else_try),
				(eq, ":found_iron_piece", 18),
				(eq, ":found_wood_pole_short", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":weapon", 0, 40),
				(try_begin),
					(eq, ":weapon", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_arrows"),
				(else_try),
					(eq, ":weapon", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_barbed_arrows"),
				(else_try),
					(eq, ":weapon", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_arrows"),
				(else_try),
					(eq, ":weapon", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bodkin_arrows"),
				(else_try),
					(eq, ":weapon", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bolts"),
				(else_try),
					(eq, ":weapon", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_steel_bolts"),
				(else_try),
					(eq, ":weapon", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_stones"),
				(else_try),
					(eq, ":weapon", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_throwing_knives"),
				(else_try),
					(eq, ":weapon", 8),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_throwing_daggers"),
				(else_try),
					(eq, ":weapon", 9),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_light_throwing_axes"),
				(else_try),
					(eq, ":weapon", 10),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_throwing_axes"),
				(else_try),
					(eq, ":weapon", 11),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_throwing_axes"),
				(else_try),
					(eq, ":weapon", 12),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_darts"),
				(else_try),
					(eq, ":weapon", 13),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_war_darts"),
				(else_try),
					(eq, ":weapon", 14),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_javelin"),
				(else_try),
					(eq, ":weapon", 15),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_jarid"),
				(else_try),
					(eq, ":weapon", 16),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_throwing_spears"),
				(else_try),
					(eq, ":weapon", 17),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_arrows_skin"),
				(else_try),
					(eq, ":weapon", 18),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_arrows_skin1"),
				(else_try),
					(eq, ":weapon", 19),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_barbed_arrows_skin"),
				(else_try),
					(eq, ":weapon", 20),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_barbed_arrows_skin1"),
				(else_try),
					(eq, ":weapon", 21),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_arrows_skin"),
				(else_try),
					(eq, ":weapon", 22),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bodkin_arrows_skin"),
				(else_try),
					(eq, ":weapon", 23),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bodkin_arrows_skin1"),
				(else_try),
					(eq, ":weapon", 24),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bodkin_arrows_skin2"),
				(else_try),
					(eq, ":weapon", 25),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bodkin_arrows_skin3"),
				(else_try),
					(eq, ":weapon", 26),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bodkin_arrows_skin4"),
				(else_try),
					(eq, ":weapon", 27),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bodkin_arrows_skin5"),
				(else_try),
					(eq, ":weapon", 28),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bodkin_arrows_skin6"),
				(else_try),
					(eq, ":weapon", 29),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_jarid_skin"),
				(else_try),
					(eq, ":weapon", 30),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_jarid_skin1"),
				(else_try),
					(eq, ":weapon", 31),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_throwing_spears_skin"),
				(else_try),
					(eq, ":weapon", 32),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_javelin_skin"),
				(else_try),
					(eq, ":weapon", 33),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_war_darts_skin"),
				(else_try),
					(eq, ":weapon", 34),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_darts_skin"),
				(else_try),
					(eq, ":weapon", 35),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bolts_skin"),
				(else_try),
					(eq, ":weapon", 36),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bolts_skin1"),
				(else_try),
					(eq, ":weapon", 37),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bolts_skin2"),
				(else_try),
					(eq, ":weapon", 38),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bolts_skin3"),
				(else_try),
					(eq, ":weapon", 39),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_steel_bolts_skin"),
				(try_end),
			(try_end),

			(try_begin),
				(eq, ":sucess", 1),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 1, 0),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 2, 0),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 3, 0),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 4, 0),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 5, 0),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 6, 0),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 7, 0),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 8, 0),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 9, 0),

				(call_script, "script_cf_use_inventory", ":agent_id", ":instance_id", 0),
				#(agent_play_sound, ":agent_id", "snd_blacksmith"),
				#(agent_play_sound, ":agent_id", "snd_saw_wood"),
				(call_script, "script_scene_prop_play_sound", ":instance_id", "snd_blacksmith"),
				(call_script, "script_scene_prop_play_sound", ":instance_id", "snd_saw_wood"),
			(else_try),
				#(str_store_string, s0, "@testing!"),  
				#(multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),

				(call_script, "script_cf_use_inventory", ":agent_id", ":instance_id", 0),
			(try_end),
		(try_end),
		]),

	#GGG:forging system
	("cf_use_forging", 
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid

		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(agent_is_alive, ":agent_id"),
		(agent_get_troop_id, ":troop_id", ":agent_id"),
		(store_skill_level, ":troop_skill_level", skl_engineer, ":troop_id"),
		(try_begin),
			(ge, ":troop_skill_level", 7),
			(assign, ":found_silver_bar", 0),
			#armors
			(assign, ":found_brigandine_red_mail", 0),
			(assign, ":found_mail_plate_armor", 0),
			(assign, ":found_2_plate_armor", 0),
			(assign, ":found_plate_armor", 0),
			(assign, ":found_sarranid_elite_armor", 0),
			(assign, ":found_vaegir_elite_armor", 0),
			(assign, ":found_khergit_elite_armor", 0),
			(assign, ":found_coat_of_plates_red", 0),
			(assign, ":found_coat_of_plates", 0),
			(assign, ":found_cuir_bouilli", 0),
			(assign, ":found_banded_armor", 0),
			(assign, ":found_scale_armor", 0),
			(assign, ":found_lamellar_armor", 0),
			(assign, ":found_mamluke_mail", 0),
			(assign, ":found_brigandine_red", 0),
			(assign, ":found_strange_armor", 0),
			(assign, ":found_khergit_guard_armor", 0),
			(assign, ":found_bishop_armor", 0),
			#legs
			(assign, ":found_khergit_guard_boots", 0),
			(assign, ":found_plate_boots", 0),
			(assign, ":found_iron_greaves", 0),
			(assign, ":found_bishop_chausses", 0),
			(assign, ":found_strange_boots", 0),
			#hand
			(assign, ":found_lamellar_gauntlets", 0),
			(assign, ":found_scale_gauntlets", 0),
			(assign, ":found_gauntlets", 0),
			#helmet
			(assign, ":found_khergit_cavalry_helmet", 0),
			(assign, ":found_khergit_guard_helmet", 0),
			(assign, ":found_strange_helmet", 0),
			(assign, ":found_bishop_helm", 0),
			(assign, ":found_full_helm", 0),
			(assign, ":found_vaegir_mask", 0),
			(assign, ":found_vaegir_mask_b", 0),
			(assign, ":found_great_helmet", 0),
			(assign, ":found_winged_great_helmet", 0),
			#

			(assign, ":loop_end", slot_scene_prop_inventory_begin + 2),
			(try_for_range, ":inventory_slot", slot_scene_prop_inventory_begin + 0, ":loop_end"),
				(scene_prop_get_slot, ":loop_item", ":instance_id", ":inventory_slot"), 
				(try_begin),
					(eq, ":loop_item", "itm_silver_bar"),
					(val_add, ":found_silver_bar", 1),
				(try_end),
				#armors 
				(try_begin),
					(eq, ":loop_item", "itm_brigandine_red_mail"),
					(val_add, ":found_brigandine_red_mail", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_mail_plate_armor"),
					(val_add, ":found_mail_plate_armor", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_2_plate_armor"),
					(val_add, ":found_2_plate_armor", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_plate_armor"),
					(val_add, ":found_plate_armor", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_sarranid_elite_armor"),
					(val_add, ":found_sarranid_elite_armor", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_vaegir_elite_armor"),
					(val_add, ":found_vaegir_elite_armor", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_khergit_elite_armor"),
					(val_add, ":found_khergit_elite_armor", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_coat_of_plates_red"),
					(val_add, ":found_coat_of_plates_red", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_coat_of_plates"),
					(val_add, ":found_coat_of_plates", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_cuir_bouilli"),
					(val_add, ":found_cuir_bouilli", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_banded_armor"),
					(val_add, ":found_banded_armor", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_scale_armor"),
					(val_add, ":found_scale_armor", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_lamellar_armor"),
					(val_add, ":found_lamellar_armor", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_mamluke_mail"),
					(val_add, ":found_mamluke_mail", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_brigandine_red"),
					(val_add, ":found_brigandine_red", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_strange_armor"),
					(val_add, ":found_strange_armor", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_khergit_guard_armor"),
					(val_add, ":found_khergit_guard_armor", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_bishop_armor"),
					(val_add, ":found_bishop_armor", 1),
				(try_end),
				#legs
				(try_begin),
					(eq, ":loop_item", "itm_khergit_guard_boots"),
					(val_add, ":found_khergit_guard_boots", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_plate_boots"),
					(val_add, ":found_plate_boots", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_iron_greaves"),
					(val_add, ":found_iron_greaves", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_bishop_chausses"),
					(val_add, ":found_bishop_chausses", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_strange_boots"),
					(val_add, ":found_strange_boots", 1),
				(try_end),
				#hand
				(try_begin),
					(eq, ":loop_item", "itm_lamellar_gauntlets"),
					(val_add, ":found_lamellar_gauntlets", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_scale_gauntlets"),
					(val_add, ":found_scale_gauntlets", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_gauntlets"),
					(val_add, ":found_gauntlets", 1),
				(try_end),
				#helmet
				(try_begin),
					(eq, ":loop_item", "itm_khergit_cavalry_helmet"),
					(val_add, ":found_khergit_cavalry_helmet", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_khergit_guard_helmet"),
					(val_add, ":found_khergit_guard_helmet", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_strange_helmet"),
					(val_add, ":found_strange_helmet", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_bishop_helm"),
					(val_add, ":found_bishop_helm", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_full_helm"),
					(val_add, ":found_full_helm", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_vaegir_mask"),
					(val_add, ":found_vaegir_mask", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_vaegir_mask_b"),
					(val_add, ":found_vaegir_mask_b", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_great_helmet"),
					(val_add, ":found_great_helmet", 1),
				(try_end),
				(try_begin),
					(eq, ":loop_item", "itm_winged_great_helmet"),
					(val_add, ":found_winged_great_helmet", 1),
				(try_end),
			(try_end),

			(assign, ":sucess", 0),
			#armors
			(try_begin),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_brigandine_red_mail", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_brigandine_red_mail"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_brigandine_red_mail"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_brigandine_red_mail"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_brigandine_red_mail"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_brigandine_red_mail"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_brigandine_red_mail"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_brigandine_red_mail"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_brigandine_red_mail"),
				(try_end),  
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_mail_plate_armor", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_mail_plate_armor"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_mail_plate_armor"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_mail_plate_armor"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_mail_plate_armor"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_mail_plate_armor"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_mail_plate_armor"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_mail_plate_armor"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_mail_plate_armor"),
				(try_end),  
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_2_plate_armor", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_2_plate_armor"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_2_plate_armor"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_2_plate_armor"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_2_plate_armor"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_2_plate_armor"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_2_plate_armor"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_2_plate_armor"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_2_plate_armor"),
				(try_end),  
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_plate_armor", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_plate_armor"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_plate_armor"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_plate_armor"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_plate_armor"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_plate_armor"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_plate_armor"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_plate_armor"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_plate_armor"),
				(try_end),  
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_sarranid_elite_armor", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_sarranid_elite_armor"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_sarranid_elite_armor"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_sarranid_elite_armor"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_sarranid_elite_armor"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_sarranid_elite_armor"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_sarranid_elite_armor"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sarranid_elite_armor"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_sarranid_elite_armor"),
				(try_end),  
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_vaegir_elite_armor", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_vaegir_elite_armor"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_vaegir_elite_armor"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_vaegir_elite_armor"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_vaegir_elite_armor"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_vaegir_elite_armor"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_vaegir_elite_armor"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_vaegir_elite_armor"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_vaegir_elite_armor"),
				(try_end),  
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_khergit_elite_armor", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_khergit_elite_armor"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_khergit_elite_armor"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_khergit_elite_armor"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_khergit_elite_armor"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_khergit_elite_armor"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_khergit_elite_armor"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_elite_armor"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_khergit_elite_armor"),
				(try_end),  
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_coat_of_plates_red", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_coat_of_plates_red"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_coat_of_plates_red"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_coat_of_plates_red"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_coat_of_plates_red"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_coat_of_plates_red"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_coat_of_plates_red"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_coat_of_plates_red"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_coat_of_plates_red"),
				(try_end),  
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_coat_of_plates", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_coat_of_plates"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_coat_of_plates"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_coat_of_plates"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_coat_of_plates"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_coat_of_plates"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_coat_of_plates"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_coat_of_plates"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_coat_of_plates"),
				(try_end),  
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_cuir_bouilli", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_cuir_bouilli"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_cuir_bouilli"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_cuir_bouilli"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_cuir_bouilli"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_cuir_bouilli"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_cuir_bouilli"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_cuir_bouilli"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_cuir_bouilli"),
				(try_end),  
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_banded_armor", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_banded_armor"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_banded_armor"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_banded_armor"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_banded_armor"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_banded_armor"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_banded_armor"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_banded_armor"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_banded_armor"),
				(try_end),  
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_scale_armor", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_scale_armor"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_scale_armor"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_scale_armor"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_scale_armor"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_scale_armor"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_scale_armor"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_scale_armor"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_scale_armor"),
				(try_end),  
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_lamellar_armor", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_lamellar_armor"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_lamellar_armor"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_lamellar_armor"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_lamellar_armor"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_lamellar_armor"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_lamellar_armor"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lamellar_armor"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_lamellar_armor"),
				(try_end),  
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_brigandine_red", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_brigandine_red"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_brigandine_red"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_brigandine_red"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_brigandine_red"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_brigandine_red"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_brigandine_red"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_brigandine_red"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_brigandine_red"),
				(try_end),  
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_mamluke_mail", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_mamluke_mail"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_mamluke_mail"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_mamluke_mail"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_mamluke_mail"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_mamluke_mail"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_mamluke_mail"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_mamluke_mail"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_mamluke_mail"),
				(try_end),
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_strange_armor", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_strange_armor"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_strange_armor"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_strange_armor"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_strange_armor"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_strange_armor"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_strange_armor"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_strange_armor"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_strange_armor"),
				(try_end),
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_khergit_guard_armor", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_khergit_guard_armor"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_khergit_guard_armor"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_khergit_guard_armor"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_khergit_guard_armor"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_khergit_guard_armor"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_khergit_guard_armor"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_guard_armor"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_khergit_guard_armor"),
				(try_end),
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_bishop_armor", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_bishop_armor"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_bishop_armor"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_bishop_armor"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_bishop_armor"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_bishop_armor"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_bishop_armor"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bishop_armor"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_bishop_armor"),
				(try_end),
			#legs
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_khergit_guard_boots", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_khergit_guard_boots"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_khergit_guard_boots"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_khergit_guard_boots"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_khergit_guard_boots"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_khergit_guard_boots"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_khergit_guard_boots"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_guard_boots"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_khergit_guard_boots"),
				(try_end),
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_plate_boots", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_plate_boots"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_plate_boots"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_plate_boots"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_plate_boots"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_plate_boots"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_plate_boots"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_plate_boots"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_plate_boots"),
				(try_end),
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_iron_greaves", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_iron_greaves"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_iron_greaves"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_iron_greaves"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_iron_greaves"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_iron_greaves"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_iron_greaves"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_iron_greaves"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_iron_greaves"),
				(try_end),
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_bishop_chausses", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_bishop_chausses"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_bishop_chausses"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_bishop_chausses"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_bishop_chausses"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_bishop_chausses"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_bishop_chausses"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bishop_chausses"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_bishop_chausses"),
				(try_end),
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_strange_boots", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_strange_boots"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_strange_boots"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_strange_boots"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_strange_boots"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_strange_boots"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_strange_boots"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_strange_boots"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_strange_boots"),
				(try_end),
			#hand
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_lamellar_gauntlets", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_lamellar_gauntlets"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_lamellar_gauntlets"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_lamellar_gauntlets"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_lamellar_gauntlets"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_lamellar_gauntlets"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_lamellar_gauntlets"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lamellar_gauntlets"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_lamellar_gauntlets"),
				(try_end),
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_scale_gauntlets", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_scale_gauntlets"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_scale_gauntlets"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_scale_gauntlets"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_scale_gauntlets"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_scale_gauntlets"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_scale_gauntlets"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_scale_gauntlets"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_scale_gauntlets"),
				(try_end),
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_gauntlets", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_gauntlets"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_gauntlets"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_gauntlets"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_gauntlets"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_gauntlets"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_gauntlets"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_gauntlets"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_gauntlets"),
				(try_end),
			#helmet
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_khergit_cavalry_helmet", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_khergit_cavalry_helmet"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_khergit_cavalry_helmet"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_khergit_cavalry_helmet"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_khergit_cavalry_helmet"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_khergit_cavalry_helmet"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_khergit_cavalry_helmet"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_cavalry_helmet"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_khergit_cavalry_helmet"),
				(try_end),
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_khergit_guard_helmet", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_khergit_guard_helmet"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_khergit_guard_helmet"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_khergit_guard_helmet"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_khergit_guard_helmet"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_khergit_guard_helmet"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_khergit_guard_helmet"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_khergit_guard_helmet"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_khergit_guard_helmet"),
				(try_end),
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_strange_helmet", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_strange_helmet"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_strange_helmet"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_strange_helmet"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_strange_helmet"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_strange_helmet"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_strange_helmet"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_strange_helmet"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_strange_helmet"),
				(try_end),
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_bishop_helm", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_bishop_helm"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_bishop_helm"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_bishop_helm"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_bishop_helm"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_bishop_helm"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_bishop_helm"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_bishop_helm"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_bishop_helm"),
				(try_end),
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_full_helm", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_full_helm"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_full_helm"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_full_helm"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_full_helm"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_full_helm"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_full_helm"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_full_helm"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_full_helm"),
				(try_end),
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_vaegir_mask", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_vaegir_mask"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_vaegir_mask"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_vaegir_mask"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_vaegir_mask"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_vaegir_mask"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_vaegir_mask"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_vaegir_mask"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_vaegir_mask"),
				(try_end),
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_vaegir_mask_b", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_vaegir_mask_b"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_vaegir_mask_b"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_vaegir_mask_b"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_vaegir_mask_b"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_vaegir_mask_b"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_vaegir_mask_b"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_vaegir_mask_b"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_vaegir_mask_b"),
				(try_end),
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_great_helmet", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_great_helmet"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_great_helmet"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_great_helmet"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_great_helmet"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_great_helmet"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_great_helmet"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_great_helmet"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_great_helmet"),
				(try_end),
			(else_try),
				(eq, ":found_silver_bar", 1),
				(eq, ":found_winged_great_helmet", 1),
				(assign, ":sucess", 1),
				(store_random_in_range, ":armors", 0, 8),
				(try_begin),
					(eq, ":armors", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_lordly_winged_great_helmet"),
				(else_try),
					(eq, ":armors", 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_reinforced_winged_great_helmet"),
				(else_try),
					(eq, ":armors", 2),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_hardened_winged_great_helmet"),
				(else_try),
					(eq, ":armors", 3),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_heavy_winged_great_helmet"),
				(else_try),
					(eq, ":armors", 4),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_thick_winged_great_helmet"),
				(else_try),
					(eq, ":armors", 5),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_sturdy_winged_great_helmet"),
				(else_try),
					(eq, ":armors", 6),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_winged_great_helmet"),
				(else_try),
					(eq, ":armors", 7),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 0, "itm_battered_winged_great_helmet"),
				(try_end),
			(try_end),

			(try_begin),
				(eq, ":sucess", 1),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + 1, 0),

				(call_script, "script_cf_use_inventory", ":agent_id", ":instance_id", 0),
				(call_script, "script_scene_prop_play_sound", ":instance_id", "snd_blacksmith"),
				(call_script, "script_scene_prop_play_sound", ":instance_id", "snd_fire"),
			(else_try),
				#(str_store_string, s0, "@testing!"),  
				#(multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s0),
				(call_script, "script_cf_use_inventory", ":agent_id", ":instance_id", 0),
			(try_end),
		(try_end),
		]),

	("cf_use_cart", # server: handle players trying to attach or access carts
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid
		(store_script_param, ":action", 3), # from cart_choose_action: -1 = attach, 1 = access
	
		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(agent_is_alive, ":agent_id"),
		(assign, ":fail", 0),
		(try_begin),
			(eq, ":action", 1),
			(call_script, "script_cf_use_inventory", ":agent_id", ":instance_id", 0),
		(else_try),
			(eq, ":action", -1),
			(scene_prop_get_slot, ":required_horse", ":instance_id", slot_scene_prop_required_horse),
			(agent_get_horse, ":horse_agent_id", ":agent_id"),
			(try_begin), # if a horse is required, check
				(ge, ":required_horse", 1),
				(assign, ":attach_agent_id", ":horse_agent_id"),
				(try_begin),
					(gt, ":horse_agent_id", -1),
					(agent_get_item_id, ":horse_item_id", ":horse_agent_id"),
					(this_or_next|eq, ":required_horse", 1),
					(eq, ":horse_item_id", ":required_horse"),
				(else_try),
					(assign, ":fail", 1),
					(multiplayer_send_2_int_to_player, ":player_id", server_event_preset_message, "str_not_riding_necessary_horse", preset_message_error),
				(try_end),
			(else_try), # if mounted but horse not required, disallow attaching hand carts
				(gt, ":horse_agent_id", -1),
				(assign, ":fail", 1),
			(else_try), # hand carts
				(assign, ":attach_agent_id", ":agent_id"),
				(agent_get_troop_id, ":troop_id", ":agent_id"),
				(store_skill_level, ":labouring", "skl_labouring", ":troop_id"),
				(try_begin),
					(lt, ":labouring", 1),
					(assign, ":fail", 1),
					(multiplayer_send_2_int_to_player, ":player_id", server_event_preset_message, "str_craft_not_skilled", preset_message_error),
				(try_end),
			(try_end),
			(eq, ":fail", 0),
			(try_begin),
				(call_script, "script_cf_attach_cart", ":attach_agent_id", ":instance_id", ":agent_id"),
			(else_try),
				(assign, ":fail", 1),
				(multiplayer_send_2_int_to_player, ":player_id", server_event_preset_message, "str_already_attached_cart", preset_message_error),
			(try_end),
		(else_try),
			(assign, ":fail", 1),
		(try_end),
		(eq, ":fail", 0),
		]),

	("cf_attach_cart", # server: try attach or detach agent and cart
	 [(store_script_param, ":attach_agent_id", 1), # the human or horse agent being attached to, must be valid
		(store_script_param, ":instance_id", 2), # must be valid
		(store_script_param, ":agent_id", 3), # the player agent, must be valid

		(agent_get_attached_scene_prop, ":attached_scene_prop", ":attach_agent_id"),
		(assign, ":fail", 0),
		(try_begin),
			(eq, ":attached_scene_prop", -1),
			(ge, ":instance_id", 0),
			(scene_prop_get_slot, ":attached_to_agent", ":instance_id", slot_scene_prop_attached_to_agent),
			(try_begin),
				(agent_is_active, ":attached_to_agent"),
				(agent_is_alive, ":attached_to_agent"),
				(agent_get_attached_scene_prop, ":other_instance_id", ":attached_to_agent"),
				(eq, ":other_instance_id", ":instance_id"),
				(assign, ":fail", 1),
			(else_try),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_attached_to_agent, ":attach_agent_id"),
				(assign, ":new_attached_scene_prop", ":instance_id"),
				(agent_set_attached_scene_prop, ":attach_agent_id", ":new_attached_scene_prop"),
				(prop_instance_enable_physics, ":new_attached_scene_prop", 0), #GGG:fix cart bug
			(try_end),
		(else_try),
			(gt, ":attached_scene_prop", -1),
			(try_begin),
				(eq, ":instance_id", -1),
				(assign, ":instance_id", ":attached_scene_prop"),
			(try_end),
			(eq, ":attached_scene_prop", ":instance_id"),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_attached_to_agent, -1),
			(assign, ":new_attached_scene_prop", -1),
			(agent_set_attached_scene_prop, ":attach_agent_id", ":new_attached_scene_prop"),
			(prop_instance_enable_physics, ":instance_id", 1), #GGG:fix cart bug
			(call_script, "script_cart_set_detached_position", ":instance_id"),
		(else_try),
			(assign, ":fail", 1),
		(try_end),
		(eq, ":fail", 0),
		(get_max_players, ":max_players"),
		(try_for_range, ":player_id", 1, ":max_players"),
			(player_is_active, ":player_id"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_set_attached_scene_prop, ":attach_agent_id", ":new_attached_scene_prop"),
		(try_end),
		(try_begin),
			(neq, ":attach_agent_id", ":agent_id"),
			(call_script, "script_check_agent_horse_speed_factor", ":agent_id", ":attach_agent_id", 0),
		(try_end),
		]),

	("cart_set_detached_position", # server: align cart to ground level when detached
	 [(store_script_param, ":instance_id", 1), # must be valid

		(set_fixed_point_multiplier, 100),
		(prop_instance_get_position, pos1, ":instance_id"),
		(position_get_z, ":height", pos1),
		(try_begin),
			(gt, ":height", z_position_water_level),
			(position_set_z_to_ground_level, pos1),
			(position_get_z, ":height", pos1),
			(gt, ":height", z_position_water_level),
			(scene_prop_get_slot, ":detach_rotation", ":instance_id", slot_scene_prop_rotation),
			(position_rotate_x, pos1, ":detach_rotation"),
		(else_try), # float on water
			(position_set_z, pos1, z_position_water_level),
		(try_end),
		(scene_prop_get_slot, ":detach_offset", ":instance_id", slot_scene_prop_position),
		(position_move_z, pos1, ":detach_offset", 1),
		(position_get_z, ":animation_time", pos1),
		(val_sub, ":animation_time", ":height"),
		(val_abs, ":animation_time"),
		(try_begin),
			(gt, ":animation_time", 100),
			(val_div, ":animation_time", 2),
		(try_end),
		(val_max, ":animation_time", 50),
		(prop_instance_animate_to_position, ":instance_id", pos1, ":animation_time"),
		]),

	("add_cart_to_list", # add each cart to a list when loading the scene for faster proximity checks
	 [(store_script_param, ":instance_id", 1),

		(troop_get_slot, ":cart_count", "trp_cart_array", slot_array_count),
		(val_add, ":cart_count", 1),
		(troop_set_slot, "trp_cart_array", ":cart_count", ":instance_id"),
		(troop_set_slot, "trp_cart_array", slot_array_count, ":cart_count"),
		]),

	("cf_rest", # server: handle players resting at beds
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":target_horse", 2), # 0 = heal humans, 1 = heal horses
		(store_script_param, ":heal_percent", 3), # percentage healed per use
		(store_script_param, ":min_health_percent", 4), # minimum health percentage to be able to use this bed

		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(assign, ":fail", 0),
		(try_begin),
			(try_begin), # only require food for resting humans
				(eq, ":target_horse", 0),
				(assign, ":target_agent_id", ":agent_id"),
				(agent_get_slot, ":food_amount", ":target_agent_id", slot_agent_food_amount),
			(else_try),
				(agent_get_horse, ":target_agent_id", ":agent_id"),
				(assign, ":food_amount", max_food_amount),
			(try_end),
			(assign, ":error_string_id", "str_no_horse"),
			(neq, ":target_agent_id", -1),
			(store_agent_hit_points, ":health_percent", ":target_agent_id", 0),
			(assign, ":error_string_id", "str_too_wounded_to_rest"),
			(gt, ":health_percent", ":min_health_percent"),
			(assign, ":error_string_id", "str_too_hungry_to_rest"),
			(gt, ":food_amount", 0),
			(try_begin),
				(neq, ":heal_percent", 0),
				(lt, ":health_percent", 100),
				(val_min, ":heal_percent", ":food_amount"),
				(val_add, ":health_percent", ":heal_percent"),
				(val_min, ":health_percent", 100),
				(agent_set_hit_points, ":target_agent_id" , ":health_percent", 0),
				(try_begin),
					(eq, ":target_horse", 0),
					(agent_play_sound, ":target_agent_id", "snd_man_yawn"),
					(val_sub, ":food_amount", ":heal_percent"),
					(agent_set_slot, ":target_agent_id", slot_agent_food_amount, ":food_amount"),
					(multiplayer_send_3_int_to_player, ":player_id", server_event_agent_set_slot, ":target_agent_id", slot_agent_food_amount, ":food_amount"),
				(else_try),
					(agent_play_sound, ":target_agent_id", "snd_horse_snort"),
				(try_end),
			(try_end),
		(else_try),
			(assign, ":fail", 1),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_preset_message, ":error_string_id", preset_message_error),
		(try_end),
		(eq, ":fail", 0),
		]),

	("cf_clean_blood", # server: allow players to remove blood from their agent if healthy
	 [(store_script_param, ":agent_id", 1), # must be valid

		(store_agent_hit_points, ":hit_points", ":agent_id", 0),
		(gt, ":hit_points", 70),
		(get_max_players, ":max_players"),
		(try_for_range, ":player_id", 1, ":max_players"),
			(player_is_active, ":player_id"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_agent_equip_armor, ":agent_id", -1), # magic value to redraw all armor
		(try_end),
		]),

	("agent_clean_blood", # clients: re-equip all visual armor meshes to remove blood
	 [(store_script_param, ":agent_id", 1), # must be valid

		(try_for_range, ":equip_slot", ek_head, ek_gloves + 1),
			(agent_get_item_slot, ":item_id", ":agent_id", ":equip_slot"),
			(store_sub, ":invisible_item_id", ":equip_slot", ek_head),
			(val_add, ":invisible_item_id", "itm_invisible_head"),
			(agent_equip_item, ":agent_id", ":invisible_item_id"),
			(try_begin),
				(gt, ":item_id", -1),
				(agent_equip_item, ":agent_id", ":item_id"),
			(else_try),
				(agent_unequip_item, ":agent_id", ":invisible_item_id"),
			(try_end),
		(try_end),
		]),

	("agent_hit_with_scripted_item", # server: check for scripted effects when the agent is hit by a special item; sets damage dealt when be called from ti_on_agent_hit
	 [(store_script_param, ":attacked_agent_id", 1), # must be valid
		(store_script_param, ":attacker_agent_id", 2), # must be valid
		(store_script_param, ":damage_dealt", 3),
		(store_script_param, ":weapon_item_id", 4),

		(assign, ":damage_result", ":damage_dealt"),
		(try_begin),
			(eq, ":weapon_item_id", "itm_surgeon_scalpel"),
			(try_begin),
				#GGG:treat limit
				#(agent_get_player_id, ":attacked_id", ":attacked_agent_id"),
				#(player_get_slot, ":treat_limit", ":attacked_id", slot_player_fight_state),
				#(lt, ":treat_limit", 1),
				#
				(agent_get_troop_id, ":attacker_troop_id", ":attacker_agent_id"),
				(store_skill_level, ":skill_level", "skl_wound_treatment", ":attacker_troop_id"),
				(gt, ":skill_level", 0),
				(store_mul, ":healing_limit", ":skill_level", 5),
				(val_add, ":healing_limit", 50),
				(store_agent_hit_points, ":health_percent", ":attacked_agent_id", 0),
				(try_begin),
					(lt, ":health_percent", ":healing_limit"),
					(store_mul, ":healing", ":skill_level", 2),
					(val_add, ":healing", 2),
					(val_add, ":health_percent", ":healing"),
					(val_min, ":health_percent", ":healing_limit"),
					(agent_set_hit_points, ":attacked_agent_id", ":health_percent", 0),
				(try_end),
				(assign, ":damage_result", 0),
			(try_end),
		(else_try),
			(eq, ":weapon_item_id", "itm_admin_scalpel"),
			(try_begin),
				(agent_get_troop_id, ":attacker_troop_id", ":attacker_agent_id"),
				(eq, ":attacker_troop_id", "trp_godlike_hero"),
				(agent_set_hit_points, ":attacked_agent_id", 100, 0),
				(assign, ":damage_result", 0),
				(call_script, "script_cf_clean_blood", ":attacked_agent_id"),
			(try_end),
		(else_try),
			(eq, ":weapon_item_id", "itm_healing_herb"),
			(try_begin),
				(agent_get_troop_id, ":attacker_troop_id", ":attacker_agent_id"),
				(store_skill_level, ":skill_level", "skl_wound_treatment", ":attacker_troop_id"),
				(gt, ":skill_level", 0),
				(assign, ":damage_result", 0),
				(call_script, "script_cf_agent_consume_item", ":attacker_agent_id", "itm_healing_herb", 1),
				(agent_get_slot, ":poison", ":attacked_agent_id", slot_agent_poison_amount),
				(val_sub, ":poison", 1),
				(agent_set_slot, ":attacked_agent_id", slot_agent_poison_amount, ":poison"),
			(try_end),
		(else_try),
			(eq, ":weapon_item_id", "itm_poisoned_dagger"),
			(try_begin),
				(gt, ":damage_dealt", 5),
				(call_script, "script_cf_agent_consume_item", ":attacker_agent_id", "itm_poisoned_dagger", 1),
				(agent_equip_item, ":attacker_agent_id", "itm_dagger"),
				(agent_set_wielded_item, ":attacker_agent_id", "itm_dagger"),
				(agent_get_slot, ":poison", ":attacked_agent_id", slot_agent_poison_amount),
				(val_add, ":poison", 1),
				(agent_set_slot, ":attacked_agent_id", slot_agent_poison_amount, ":poison"),
				(agent_set_slot, ":attacked_agent_id", slot_agent_poisoner_agent_id, ":attacker_agent_id"),
				(try_begin),
					(agent_get_player_id, ":attacker_player_id", ":attacker_agent_id"),
					(player_is_active, ":attacker_player_id"),
					(player_get_unique_id, ":attacker_player_uid", ":attacker_player_id"),
				(else_try),
					(assign, ":attacker_player_uid", -1),
				(try_end),
				(agent_set_slot, ":attacked_agent_id", slot_agent_poisoner_player_uid, ":attacker_player_uid"),
			(try_end),
		(else_try),
		###GGG:lance break system
			(eq, 1, 2),
			(this_or_next|eq, ":weapon_item_id", "itm_light_lance"),
			(this_or_next|eq, ":weapon_item_id", "itm_lance"),
			(this_or_next|eq, ":weapon_item_id", "itm_heavy_lance"),
			#(this_or_next|eq, ":weapon_item_id", "itm_great_lance"),
			(eq, ":weapon_item_id", "itm_thin_lance"),
		###
			(try_begin),
				(gt, ":damage_dealt", 10),
				(agent_get_horse, ":horse_agent_id", ":attacker_agent_id"),
				(agent_is_active, ":horse_agent_id"),
				(set_fixed_point_multiplier, 100),
				(agent_get_speed, pos1, ":attacker_agent_id"),
				#(position_get_y, ":forward_speed", pos1),
				#(this_or_next|gt, ":forward_speed", 500),
				(ge, ":damage_dealt", 100), #40
				#(call_script, "script_cf_agent_consume_item", ":attacker_agent_id", "itm_thin_lance", 1),
				(store_random_in_range, ":num", 1, 8),
				(eq, ":num", 2),
				(call_script, "script_cf_agent_consume_item", ":attacker_agent_id", ":weapon_item_id", 1), ###GGG
				(agent_get_position, pos1, ":attacker_agent_id"),
				(position_move_x, pos1, 50),
				(set_spawn_position, pos1),
				(spawn_item, "itm_broken_lance", 0, 60),
				(agent_play_sound, ":attacker_agent_id", "snd_lance_break"),
				(position_move_z, pos1, 50),
				(particle_system_burst, "psys_dummy_straw", pos1, 10),
			(try_end),
		###GGG:wand of law
		(else_try),
			(eq, ":weapon_item_id", "itm_wand_of_law"),
			(try_begin),
				(agent_is_human, ":attacked_agent_id"),
				(agent_get_horse, ":horse", ":attacked_agent_id"),
				(lt, ":horse", 0),
				(agent_get_player_id, ":attacker_player_id", ":attacker_agent_id"),
				(player_is_active, ":attacker_player_id"),
				(this_or_next|player_slot_eq, ":attacker_player_id", slot_player_faction_id, "fac_1"),
				(player_is_admin,  ":attacker_player_id"),
				(assign, ":damage_result", 0),
				(agent_get_player_id, ":attacked_player_id", ":attacked_agent_id"),

				(agent_play_sound, ":attacked_agent_id", "snd_enemy_scored_a_point"),
				(entry_point_get_position, pos2, 6),
				(agent_set_position, ":attacked_agent_id", pos2),
				(multiplayer_send_2_int_to_player, ":attacked_player_id", server_event_preset_message, "str_you_were_arrested", preset_message_error),
				(multiplayer_send_3_int_to_player, ":attacker_player_id", server_event_preset_message, "str_you_arrested_s1", preset_message_player|preset_message_error, ":attacked_player_id"),
				(multiplayer_is_server),
				(str_store_player_username, s50, ":attacked_player_id"), 
				(str_store_player_username, s51, ":attacker_player_id"),               
				(server_add_message_to_log, "@{s50} been arrested by {s51} for breaking law."),
			(try_end),
		(try_end),
		(set_trigger_result, ":damage_result"),
		]),

	("cf_use_bucket", # server: fill the bucket if below water level
	 [(store_script_param, ":agent_id", 1), # must be valid

		(position_move_z, pos1, -100),
		(position_get_z, ":z_pos", pos1),
		(lt, ":z_pos", 0),
		(call_script, "script_cf_agent_consume_item", ":agent_id", "itm_bucket", 1),
		(agent_equip_item, ":agent_id", "itm_water_bucket", reg0),
		(agent_set_wielded_item, ":agent_id", "itm_water_bucket"),
		]),

	("move_fish_school", # server: move the fish school to a new position inside the water depth limits
	 [(store_script_param, ":instance_id", 1), # must be valid

		(set_fixed_point_multiplier, 100),
		(prop_instance_get_position, pos1, ":instance_id"),
		(prop_instance_get_variation_id, ":maximum_depth", ":instance_id"),
		(try_begin),
			(le, ":maximum_depth", fish_school_minimum_depth / 100),
			(assign, ":maximum_depth", 1000),
		(else_try),
			(val_mul, ":maximum_depth", 100),
		(try_end),
		(position_set_z, pos1, z_position_water_level),
		(assign, ":closest_depth", 999999),
		(get_scene_boundaries, pos5, pos6),
		(store_random_in_range, ":distance", fish_school_min_move_distance, fish_school_max_move_distance),
		(store_mul, ":negative_distance", ":distance", -1),
		(store_random_in_range, ":initial_direction", 0, 4),
		(store_add, ":loop_end", ":initial_direction", 4),
		(try_for_range, ":direction", ":initial_direction", ":loop_end"),
			(copy_position, pos2, pos1),
			(val_mod, ":direction", 4),
			(try_begin),
				(eq, ":direction", 0),
				(position_move_x, pos2, ":distance", 1),
				(position_get_x, ":pos_x", pos2),
				(position_get_x, ":max_x", pos6),
				(lt, ":pos_x", ":max_x"),
			(else_try),
				(eq, ":direction", 1),
				(position_move_x, pos2, ":negative_distance", 1),
				(position_get_x, ":pos_x", pos2),
				(position_get_x, ":min_x", pos5),
				(gt, ":pos_x", ":min_x"),
			(else_try),
				(eq, ":direction", 2),
				(position_move_y, pos2, ":distance", 1),
				(position_get_y, ":pos_y", pos2),
				(position_get_y, ":max_y", pos6),
				(lt, ":pos_y", ":max_y"),
			(else_try),
				(eq, ":direction", 3),
				(position_move_y, pos2, ":negative_distance", 1),
				(position_get_y, ":pos_y", pos2),
				(position_get_y, ":min_y", pos5),
				(gt, ":pos_y", ":min_y"),
			(else_try),
				(assign, ":direction", -1),
			(try_end),
			(gt, ":direction", -1),
			(position_get_distance_to_terrain, ":water_depth", pos2),
			(try_begin),
				(is_between, ":water_depth", fish_school_minimum_depth, ":maximum_depth"),
				(assign, ":loop_end", -1),
				(copy_position, pos3, pos2),
			(else_try),
				(val_sub, ":water_depth", ":maximum_depth"),
				(val_abs, ":water_depth"),
				(lt, ":water_depth", ":closest_depth"),
				(assign, ":closest_depth", ":water_depth"),
				(copy_position, pos3, pos2),
			(try_end),
		(try_end),
		(try_begin),
			(this_or_next|eq, ":loop_end", -1),
			(lt, ":closest_depth", 999999),
			(prop_instance_set_position, ":instance_id", pos3, 1),
		(try_end),
		(prop_instance_get_variation_id_2, ":maximum_count", ":instance_id"),
		(try_begin),
			(eq, ":maximum_count", 0),
			(assign, ":maximum_count", 100),
		(try_end),
		(scene_prop_get_slot, ":fish_count", ":instance_id", slot_scene_prop_stock_count),
		(try_begin),
			(lt, ":fish_count", ":maximum_count"),
			(store_random_in_range, ":adjust_fish", -2, 4),
			(val_add, ":fish_count", ":adjust_fish"),
			(val_max, ":fish_count", 0),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_stock_count, ":fish_count"),
		(try_end),
		(try_begin),
			(gt, ":fish_count", 0),
			(store_random_in_range, ":random", 0, 20),
			(gt, ":fish_count", ":random"),
			(store_random_in_range, ":move_x", -500, 501),
			(position_move_x, pos3, ":move_x"),
			(store_random_in_range, ":move_y", -500, 501),
			(position_move_y, pos3, ":move_y"),
			(store_random_in_range, ":rotate_z", 0, 360),
			(position_rotate_z, pos3, ":rotate_z"),
			(position_set_z, pos3, -30, 1),
			(particle_system_burst, "psys_fish_rise", pos3, 1),
			(val_mul, ":random", 2),
			(try_begin),
				(gt, ":fish_count", ":random"),
				(particle_system_burst, "psys_game_water_splash_1", pos3, 5),
				(particle_system_burst, "psys_game_water_splash_2", pos3, 5),
				(copy_position, pos0, pos3),
				(call_script, "script_play_sound_at_position", "snd_jump_end_water"),
			(try_end),
		(try_end),
		]),

	("check_fishing_nets", # server: check all fishing nets to see if anything was caught
	 [
		(set_fixed_point_multiplier, 100),
		(scene_spawned_item_get_num_instances, ":net_num", "itm_fishing_net"),
		(try_for_range, ":net_no", 0, ":net_num"),
			(scene_spawned_item_get_instance, ":net_instance_id", "itm_fishing_net", ":net_no"),
			(scene_prop_get_slot, ":placement_skill", ":net_instance_id", slot_scene_prop_position),
			(gt, ":placement_skill", 0),
			(prop_instance_get_position, pos1, ":net_instance_id"),
			(position_get_z, ":height", pos1),
			(lt, ":height", -100),
			(copy_position, pos2, pos1),
			(position_set_z, pos2, z_position_water_level),
			(scene_prop_get_slot, ":linked_instance_id", ":net_instance_id", slot_scene_prop_linked_scene_prop),
			(assign, ":school_instance_id", ":linked_instance_id"),
			(scene_prop_get_num_instances, ":school_num", "spr_pw_fish_school"),
			(store_add, ":loop_end", ":school_num", 1),
			(try_for_range, ":school_no", 0, ":loop_end"), # find the closest school to the net
				(gt, ":school_instance_id", 0),
				(scene_prop_get_slot, ":fish_count", ":school_instance_id", slot_scene_prop_stock_count),
				(gt, ":fish_count", 0),
				(prop_instance_get_position, pos3, ":school_instance_id"),
				(get_sq_distance_between_positions, ":sq_distance", pos2, pos3),
				(lt, ":sq_distance", sq(max_distance_to_catch_fish)),
				(scene_prop_set_slot, ":net_instance_id", slot_scene_prop_linked_scene_prop, ":school_instance_id"),
				(assign, ":loop_end", -1),
			(else_try),
				(lt, ":school_no", ":school_num"),
				(scene_prop_get_instance, ":school_instance_id", "spr_pw_fish_school", ":school_no"),
				(eq, ":school_instance_id", ":linked_instance_id"),
				(assign, ":school_instance_id", -1),
			(try_end),
			(try_begin),
				(eq, ":loop_end", -1),
				(store_sqrt, ":distance", ":sq_distance"),
				(store_mul, ":fish_factor", ":fish_count", ":placement_skill"),
				(store_random_in_range, ":random", 0, ":distance"),
				(lt, ":random", ":fish_factor"),
				(store_random_in_range, ":move_x", -50, 51),
				(position_move_x, pos1, ":move_x"),
				(position_move_y, pos1, -15),
				(position_get_z, ":height", pos1),
				(val_abs, ":height"),
				(val_sub, ":height", 30),
				(val_min, ":height", 176),
				(store_random_in_range, ":move_z", 50, ":height"),
				(position_move_z, pos1, ":move_z"),
				(set_spawn_position, pos1),
				(spawn_item, "itm_fish", 0, fish_spawn_time),
				(prop_instance_set_position, reg0, pos1),
				(val_sub, ":fish_count", 1),
				(scene_prop_set_slot, ":school_instance_id", slot_scene_prop_stock_count, ":fish_count"),
			(try_end),
		(try_end),
		]),

	("cf_use_fishing_tool", # server: check if the player meets all requirements to catch a fish, then success is based on chance; should be called from ti_on_weapon_attack
	 [(multiplayer_is_server),
		(store_script_param, ":agent_id", 1), # must be valid

		(set_fixed_point_multiplier, 100),
		(position_get_z, ":z_pos", pos1),
		(lt, ":z_pos", z_position_water_level),
		(agent_get_troop_id, ":troop_id", ":agent_id"),
		(store_skill_level, ":labouring", "skl_labouring", ":troop_id"),
		(gt, ":labouring", 0),
		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(agent_get_slot, ":last_fish_instance_id", ":agent_id", slot_agent_fishing_last_school),
		(try_begin), # first check the last fishing school used, to save time
			(gt, ":last_fish_instance_id", -1),
			(prop_instance_get_position, pos2, ":last_fish_instance_id"),
			(get_sq_distance_between_positions, ":sq_distance", pos1, pos2),
			(lt, ":sq_distance", sq(max_distance_to_catch_fish)),
			(assign, ":num_instances", -1),
			(assign, ":fish_instance_id", ":last_fish_instance_id"),
		(else_try), # else check all other schools
			(scene_prop_get_num_instances, ":num_instances", "spr_pw_fish_school"),
			(try_for_range, ":instance_no", 0, ":num_instances"),
				(scene_prop_get_instance, ":fish_instance_id", "spr_pw_fish_school", ":instance_no"),
				(scene_prop_slot_ge, ":fish_instance_id", slot_scene_prop_stock_count, 1),
				(neq, ":fish_instance_id", ":last_fish_instance_id"),
				(prop_instance_get_position, pos2, ":fish_instance_id"),
				(get_sq_distance_between_positions, ":sq_distance", pos1, pos2),
				(lt, ":sq_distance", sq(max_distance_to_catch_fish)),
				(assign, ":num_instances", -1),
				(agent_set_slot, ":agent_id", slot_agent_fishing_last_school, ":fish_instance_id"),
			(try_end),
			(gt, ":num_instances", -1),
			(agent_set_slot, ":agent_id", slot_agent_fishing_last_school, -1),
		(try_end),
		(eq, ":num_instances", -1),
		(store_sqrt, ":distance", ":sq_distance"),
		(val_add, ":distance", 1000),
		(store_random_in_range, ":success", 0, ":distance"),
		(val_mul, ":labouring", 100),
		(lt, ":success", ":labouring"),
		(scene_prop_get_slot, ":fish_count", ":fish_instance_id", slot_scene_prop_stock_count),
		(gt, ":fish_count", 0),
		(val_sub, ":fish_count", 1),
		(scene_prop_set_slot, ":fish_instance_id", slot_scene_prop_stock_count, ":fish_count"),
		(position_get_rotation_around_z, ":rotation", pos1),
		(init_position, pos2),
		(position_copy_rotation, pos1, pos2),
		(val_sub, ":rotation", 90),
		(position_rotate_z, pos1, ":rotation"),
		(set_spawn_position, pos1),
		(spawn_item, "itm_fish", 0, fish_spawn_time),
		(prop_instance_set_position, reg0, pos1),
		(particle_system_burst, "psys_game_water_splash_2", pos1, 10),
		(agent_play_sound, ":agent_id", "snd_jump_begin_water"),
		]),

	("cf_eat_food", # server: handle players consuming food items
	 [(multiplayer_is_server),
		(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":item_id", 2),

		(agent_is_alive, ":agent_id"),
		(agent_get_action_dir, ":direction", ":agent_id"),
		(eq, ":direction", 0),
		(call_script, "script_cf_agent_consume_item", ":agent_id", ":item_id", 1),
		##arthur cancel thirst system
		(try_begin),
			(eq, ":item_id", "itm_beer_jug"),
			(item_set_slot, ":item_id", slot_item_resource_amount, 35),
		(else_try),
			(eq, ":item_id", "itm_wine_jar"),
			(item_set_slot, ":item_id", slot_item_resource_amount, 50),
		(try_end),
		###GGG:thirst system
		#(try_begin),
		#	(this_or_next|eq, ":item_id", "itm_beer_jug"),
		#							 (eq, ":item_id", "itm_wine_jar"),
		#	(try_begin),
		#			(eq, ":item_id", "itm_beer_jug"),
		#			(assign, ":water", 35),
		#	(else_try),
		#			(eq, ":item_id", "itm_wine_jar"),
		#			(assign, ":water", 50),
		#	(try_end),
		#	(agent_get_slot, ":water_amount", ":agent_id", slot_agent_water_amount),
		#	(lt, ":water_amount", max_food_amount),
		#	(val_add, ":water_amount", ":water"),
		#	(val_min, ":water_amount", max_food_amount),
		#	(agent_set_slot, ":agent_id", slot_agent_water_amount, ":water_amount"),
		#	(agent_get_player_id, ":player_id", ":agent_id"),
		#	(player_is_active, ":player_id"),
		#	(multiplayer_send_3_int_to_player, ":player_id", server_event_agent_set_slot, ":agent_id", slot_agent_water_amount, ":water_amount"),     
		(try_begin),     
		###    
			(item_get_slot, ":food", ":item_id", slot_item_resource_amount),
			(gt, ":food", 0),
			(agent_get_slot, ":food_amount", ":agent_id", slot_agent_food_amount),
			(lt, ":food_amount", max_food_amount),
			(val_add, ":food_amount", ":food"),
			(val_min, ":food_amount", max_food_amount),
			(agent_set_slot, ":agent_id", slot_agent_food_amount, ":food_amount"),
			(agent_get_player_id, ":player_id", ":agent_id"),
			(player_is_active, ":player_id"),
			(multiplayer_send_3_int_to_player, ":player_id", server_event_agent_set_slot, ":agent_id", slot_agent_food_amount, ":food_amount"),
		(try_end),
		]),

	("check_agent_health", # server: check for armor encumbrance, poison, and passive healing effects
	 [(store_script_param, ":agent_id", 1), # must be valid

		(try_begin),
			(agent_is_alive, ":agent_id"),
			(agent_get_slot, ":armor_speed_factor", ":agent_id", slot_agent_armor_speed_factor),
			(try_begin),
				(is_between, ":armor_speed_factor", 20, reduction_factor_base),
				(agent_get_horse, ":horse_agent_id", ":agent_id"),
				(eq, ":horse_agent_id", -1),
				(set_fixed_point_multiplier, 100),
				(agent_get_speed, pos1, ":agent_id"),
				(position_get_y, ":speed", pos1),
				(gt, ":speed", 10),
				(store_random_in_range, ":pause", 0, ":armor_speed_factor"),
				(gt, ":pause", 20),
				(agent_set_animation, ":agent_id", "anim_pause_encumbered"),
			(try_end),
			(agent_get_slot, ":poison_amount", ":agent_id", slot_agent_poison_amount),
			(try_begin),
				(gt, ":poison_amount", 0),
				(store_mul, ":damage", ":poison_amount", 6),
				(val_min, ":damage", 10),
				(store_agent_hit_points, ":hit_points", ":agent_id", 1),
				(val_sub, ":hit_points", ":damage"),
				(agent_set_hit_points, ":agent_id", ":hit_points", 1),
				(try_begin),
					(le, ":hit_points", 0),
					(agent_get_slot, ":poisoner_agent_id", ":agent_id", slot_agent_poisoner_agent_id),
					(try_begin),
						(gt, ":poisoner_agent_id", -1),
						(agent_is_active, ":poisoner_agent_id"),
						(agent_get_slot, ":poisoner_player_uid", ":agent_id", slot_agent_poisoner_player_uid),
						(try_begin),
							(gt, ":poisoner_player_uid", -1),
							(agent_get_player_id, ":poisoner_player_id", ":poisoner_agent_id"),
							(player_is_active, ":poisoner_player_id"),
							(player_get_unique_id, ":poisoner_check_uid", ":poisoner_player_id"),
							(eq, ":poisoner_check_uid", ":poisoner_player_uid"),
							(assign, ":poisoner_player_uid", -1),
						(try_end),
						(eq, ":poisoner_player_uid", -1),
					(else_try),
						(assign, ":poisoner_agent_id", ":agent_id"),
					(try_end),
					(agent_deliver_damage_to_agent, ":poisoner_agent_id", ":agent_id", 10),
				(try_end),
			(try_end),
		(try_end),
		]),

	("check_kill_excess_animals", # server: kill random herd animals when the herd animal limit setting is exceeded
	 [
		(try_begin),
			(multiplayer_is_server),
			(assign, ":copied_herd_animal_count", "$g_herd_animal_count"),
			(try_for_agents, ":agent_id"),
				(gt, ":copied_herd_animal_count", "$g_max_herd_animal_count"),
				(agent_slot_ge, ":agent_id", slot_agent_animal_birth_time, 1),
				(agent_is_alive, ":agent_id"),
				(neg|agent_is_human, ":agent_id"),
				(remove_agent, ":agent_id"),
				(val_sub, ":copied_herd_animal_count", 1),
			(try_end),
		(try_end),
		]),

	("check_animal_killed", # server: when an animal is killed, play death sounds, spawn carcass if a herd animal, storing meat and hide counts
	 [(store_script_param, ":dead_agent_id", 1), # must be valid
		(store_script_param, ":killer_agent_id", 2),

		(try_begin),
			(multiplayer_is_server),
			(agent_get_item_id, ":horse_item_id", ":dead_agent_id"),
			(gt, ":horse_item_id", -1),
			(try_begin),
				(item_slot_eq, ":horse_item_id", slot_item_animal_adult_item_id, 0),
				(agent_play_sound, ":dead_agent_id", "snd_horse_neigh"),
			(else_try),
				(val_sub, "$g_herd_animal_count", 1),
				(store_mission_timer_a, "$g_time_last_herd_animal_disappeared"),
				(val_add, "$g_time_last_herd_animal_disappeared", "$g_spawn_item_prune_time"),
				(item_get_slot, ":death_sound", ":horse_item_id", slot_item_animal_death_sound),
				(try_begin),
					(gt, ":death_sound", 0),
					(agent_play_sound, ":dead_agent_id", ":death_sound"),
				(try_end),
				(call_script, "script_animal_remove_from_herd", ":dead_agent_id", -1),
				(item_get_slot, ":meat_count", ":horse_item_id", slot_item_animal_meat_count),
				(item_get_slot, ":hide_count", ":horse_item_id", slot_item_animal_hide_count),
				(try_begin),
					(agent_is_active, ":killer_agent_id"),
					(agent_get_wielded_item, ":wielded_item_id", ":killer_agent_id", 0),
					(try_begin),
						(this_or_next|le, ":wielded_item_id", -1),
						(neg|item_slot_eq, ":wielded_item_id", slot_item_class, item_class_knife),
						(val_sub, ":meat_count", 1),
						(val_sub, ":hide_count", 2),
					(try_end),
					(agent_get_troop_id, ":troop_id", ":killer_agent_id"),
					(store_skill_level, ":butchering_skill", "skl_herding", ":troop_id"),
					(store_proficiency_level, ":weapon_skill", ":troop_id", wpt_one_handed_weapon),
					(try_begin),
						(lt, ":butchering_skill", 1),
						(lt, ":weapon_skill", 90),
						(val_sub, ":meat_count", 1),
						(val_sub, ":hide_count", 1),
					(try_end),
				(else_try),
					(val_div, ":meat_count", 2),
					(val_div, ":hide_count", 2),
				(try_end),
				(agent_get_slot, ":food_count", ":dead_agent_id", slot_agent_animal_food),
				(val_clamp, ":food_count", -2, 2),
				(val_add, ":meat_count", ":food_count"),
				(agent_get_position, pos1, ":dead_agent_id"),
				(set_spawn_position, pos1),
				(spawn_item, "itm_animal_carcass", 0, "$g_spawn_item_prune_time"),
				(prop_instance_set_position, reg0, pos1),
				(agent_set_slot, ":dead_agent_id", slot_agent_animal_carcass_instance_id, reg0),
				(scene_prop_set_slot, reg0, slot_animal_carcass_meat_count, ":meat_count"),
				(scene_prop_set_slot, reg0, slot_animal_carcass_hide_count, ":hide_count"),
			(try_end),
		(try_end),
		]),

	("cf_use_butchering_knife", # server: check for nearby animal carcasses for the agent to butcher
	 [(store_script_param, ":agent_id", 1), # must be valid

		(assign, ":found", 0),
		(agent_get_slot, ":carcass_instance_id", ":agent_id", slot_agent_hunting_last_carcass),
		(try_begin), # first check the last carcass used, to save time
			(prop_instance_is_valid, ":carcass_instance_id"),
			(this_or_next|scene_prop_slot_ge, ":carcass_instance_id", slot_animal_carcass_meat_count, 1),
			(scene_prop_slot_ge, ":carcass_instance_id", slot_animal_carcass_hide_count, 1),
			(prop_instance_get_position, pos2, ":carcass_instance_id"),
			(get_sq_distance_between_positions, ":sq_distance", pos1, pos2),
			(lt, ":sq_distance", sq(max_distance_to_use)),
			(assign, ":found", 1),
		(else_try), # otherwise check all other carcasses
			(agent_get_player_id, ":player_id", ":agent_id"),
			(player_is_active, ":player_id"),
			(store_mission_timer_a, ":time"),
			(lt, ":time", "$g_time_last_herd_animal_disappeared"),
			(player_get_slot, ":last_action_time", ":player_id", slot_player_last_action_time),
			(store_sub, ":interval", ":time", ":last_action_time"),
			(ge, ":interval", carcass_search_min_interval),
			(player_set_slot, ":player_id", slot_player_last_action_time, ":time"),
			(scene_spawned_item_get_num_instances, ":carcass_count", "itm_animal_carcass"),
			(try_for_range, ":other_carcass_no", 0, ":carcass_count"),
				(scene_spawned_item_get_instance, ":other_carcass_instance_id", "itm_animal_carcass", ":other_carcass_no"),
				(this_or_next|scene_prop_slot_ge, ":other_carcass_instance_id", slot_animal_carcass_meat_count, 1),
				(scene_prop_slot_ge, ":other_carcass_instance_id", slot_animal_carcass_hide_count, 1),
				(prop_instance_get_position, pos2, ":other_carcass_instance_id"),
				(get_sq_distance_between_positions, ":sq_distance", pos1, pos2),
				(lt, ":sq_distance", sq(max_distance_to_use)),
				(assign, ":carcass_count", -1),
				(assign, ":found", 1),
				(assign, ":carcass_instance_id", ":other_carcass_instance_id"),
				(agent_set_slot, ":agent_id", slot_agent_hunting_last_carcass, ":other_carcass_instance_id"),
			(try_end),
			(try_begin),
				(eq, ":found", 0),
				(agent_set_slot, ":agent_id", slot_agent_hunting_last_carcass, -1),
			(try_end),
		(try_end),
		(eq, ":found", 1),
		(scene_prop_get_slot, ":hide_count", ":carcass_instance_id", slot_animal_carcass_hide_count),
		(try_begin),
			(gt, ":hide_count", 0),
			(val_sub, ":hide_count", 1),
			(scene_prop_set_slot, ":carcass_instance_id", slot_animal_carcass_hide_count, ":hide_count"),
			(call_script, "script_set_random_spawn_position", 50),
			(spawn_item, "itm_raw_hide", 0, "$g_spawn_item_prune_time"),
		(else_try),
			(scene_prop_get_slot, ":meat_count", ":carcass_instance_id", slot_animal_carcass_meat_count),
			(gt, ":meat_count", 0),
			(val_sub, ":meat_count", 1),
			(scene_prop_set_slot, ":carcass_instance_id", slot_animal_carcass_meat_count, ":meat_count"),
			(call_script, "script_set_random_spawn_position", 50),
			(spawn_item, "itm_raw_meat", 0, "$g_spawn_item_prune_time"),
		(try_end),
		(try_begin),
			(le, ":hide_count", 0),
			(le, ":meat_count", 0),
			(scene_prop_set_prune_time, ":carcass_instance_id", 1),
		(try_end),
		]),

	("cf_animal_add_to_herd", # server: try find a free space for an animal in a herd
	 [(store_script_param, ":animal_agent_id", 1), # must be valid
		(store_script_param, ":herd_manager", 2), # must be a valid instance id
		(store_script_param, ":adult_item_id", 3),

		(scene_prop_slot_eq, ":herd_manager", slot_animal_herd_manager_adult_item_id, ":adult_item_id"),
		(assign, ":free_slot", -1),
		(assign, ":found_herd", 0),
		(item_get_slot, ":loop_end", ":adult_item_id", slot_item_animal_max_in_herd),
		(try_for_range, ":herd_slot", 0, ":loop_end"),
			(scene_prop_get_slot, ":herd_agent_id", ":herd_manager", ":herd_slot"),
			(agent_is_active, ":herd_agent_id"),
			(agent_slot_eq, ":herd_agent_id", slot_agent_animal_herd_manager, ":herd_manager"),
			(agent_get_item_id, ":herd_item_id", ":herd_agent_id"),
			(gt, ":herd_item_id", -1),
			(item_slot_eq, ":herd_item_id", slot_item_animal_adult_item_id, ":adult_item_id"),
			(agent_get_position, pos50, ":herd_agent_id"),
			(get_sq_distance_between_positions, ":sq_distance", pos1, pos50),
			(try_begin),
				(le, ":sq_distance", sq(max_distance_to_include_in_herd)),
				(assign, ":found_herd", 1),
			(else_try),
				(assign, ":loop_end", -1),
			(try_end),
		(else_try),
			(scene_prop_set_slot, ":herd_manager", ":herd_slot", -1),
			(eq, ":free_slot", -1),
			(assign, ":free_slot", ":herd_slot"),
		(try_end),
		(eq, ":found_herd", 1),
		(gt, ":free_slot", -1),
		(scene_prop_set_slot, ":herd_manager", ":free_slot", ":animal_agent_id"),
		(agent_set_slot, ":animal_agent_id", slot_agent_animal_herd_manager, ":herd_manager"),
		(scene_prop_set_prune_time, ":herd_manager", 999999),
		]),

	("animal_add_to_nearby_herd", # server: try add the animal to the herd or another nearby, otherwise spawn a new herd manager
	 [(store_script_param, ":animal_agent_id", 1), # must be valid
		(store_script_param, ":herd_manager", 2),

		(try_begin),
			(agent_is_active, ":animal_agent_id"),
			(agent_get_position, pos1, ":animal_agent_id"),
			(agent_get_item_id, ":animal_item_id", ":animal_agent_id"),
			(gt, ":animal_item_id", -1),
			(item_get_slot, ":adult_item_id", ":animal_item_id", slot_item_animal_adult_item_id),
			(gt, ":adult_item_id", 0),
			(agent_get_slot, ":old_herd_manager", ":animal_agent_id", slot_agent_animal_herd_manager),
			(try_begin),
				(prop_instance_is_valid, ":herd_manager"),
				(call_script, "script_cf_animal_add_to_herd", ":animal_agent_id", ":herd_manager", ":adult_item_id"),
			(else_try),
				(assign, ":checked_herd_manager", ":herd_manager"),
				(scene_spawned_item_get_num_instances, ":herds_end", "itm_animal_herd_manager"),
				(try_for_range, ":herd_no", 0, ":herds_end"),
					(scene_spawned_item_get_instance, ":herd_manager", "itm_animal_herd_manager", ":herd_no"),
					(neq, ":herd_manager", ":checked_herd_manager"),
					(call_script, "script_cf_animal_add_to_herd", ":animal_agent_id", ":herd_manager", ":adult_item_id"),
					(assign, ":herds_end", -1),
				(try_end),
				(eq, ":herds_end", -1),
			(else_try),
				(set_fixed_point_multiplier, 100),
				(init_position, pos0),
				(position_set_z, pos0, -5000),
				(set_spawn_position, pos0),
				(spawn_item, "itm_animal_herd_manager", 0, 999999),
				(assign, ":herd_manager", reg0),
				(prop_instance_set_position, ":herd_manager", pos1, 1),
				(scene_prop_set_slot, ":herd_manager", 0, ":animal_agent_id"),
				(scene_prop_set_slot, ":herd_manager", slot_animal_herd_manager_adult_item_id, ":adult_item_id"),
				(item_get_slot, ":loop_end", ":animal_item_id", slot_item_animal_max_in_herd),
				(try_for_range, ":herd_slot", 1, ":loop_end"),
					(scene_prop_set_slot, ":herd_manager", ":herd_slot", -1),
				(try_end),
				(agent_set_slot, ":animal_agent_id", slot_agent_animal_herd_manager, ":herd_manager"),
			(try_end),
			(try_begin),
				(gt, ":old_herd_manager", -1),
				(neq, ":herd_manager", ":old_herd_manager"),
				(call_script, "script_animal_remove_from_herd", ":animal_agent_id", ":old_herd_manager"),
			(try_end),
		(try_end),
		]),

	("animal_remove_from_herd", # server: remove the animal from the herd manager, if valid
	 [(store_script_param, ":animal_agent_id", 1), # must be valid
		(store_script_param, ":herd_manager", 2),

		(try_begin),
			(agent_get_item_id, ":animal_item_id", ":animal_agent_id"),
			(gt, ":animal_item_id", -1),
			(item_get_slot, ":adult_item_id", ":animal_item_id", slot_item_animal_adult_item_id),
			(gt, ":adult_item_id", 0),
			(try_begin),
				(le, ":herd_manager", -1),
				(agent_get_slot, ":herd_manager", ":animal_agent_id", slot_agent_animal_herd_manager),
				(agent_set_slot, ":animal_agent_id", slot_agent_animal_herd_manager, -1),
			(try_end),
			(prop_instance_is_valid, ":herd_manager"),
			(scene_prop_slot_eq, ":herd_manager", slot_animal_herd_manager_adult_item_id, ":adult_item_id"),
			(item_get_slot, ":loop_end", ":animal_item_id", slot_item_animal_max_in_herd),
			(try_for_range, ":herd_slot", 0, ":loop_end"),
				(scene_prop_get_slot, ":herd_agent_id", ":herd_manager", ":herd_slot"),
				(eq, ":herd_agent_id", ":animal_agent_id"),
				(scene_prop_set_slot, ":herd_manager", ":herd_slot", -1),
				(assign, ":loop_end", -1),
			(try_end),
		(try_end),
		]),

	("cf_spawn_herd_animal", # server: spawn an animal and add to a nearby herd
	 [(store_script_param, ":animal_item_id", 1),
		(store_script_param, ":herd_manager", 2),

		(item_get_slot, ":adult_item_id", ":animal_item_id", slot_item_animal_adult_item_id),
		(gt, ":adult_item_id", 0),
		(val_add, "$g_herd_animal_count", 1),
		(set_spawn_position, pos1),
		(spawn_horse, ":animal_item_id"),
		(assign, ":animal_agent_id", reg0),
		(agent_set_slot, ":animal_agent_id", slot_agent_animal_herd_manager, -1),
		(agent_set_slot, ":animal_agent_id", slot_agent_animal_carcass_instance_id, -1),
		(call_script, "script_animal_add_to_nearby_herd", ":animal_agent_id", ":herd_manager"),
		(store_mission_timer_a, ":time"),
		(try_begin),
			(eq, ":animal_item_id", ":adult_item_id"),
			(item_get_slot, ":grow_time", ":animal_item_id", slot_item_animal_grow_time),
			(val_sub, ":time", ":grow_time"),
		(try_end),
		(val_max, ":time", 1),
		(agent_set_slot, ":animal_agent_id", slot_agent_animal_birth_time, ":time"),
		]),

	("cf_can_spawn_herd_animal", # server: check whether a player can spawn a new herd animal
	 [(store_script_param, ":agent_id", 1), # must be valid

		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(try_begin),
			(ge, "$g_herd_animal_count", "$g_max_herd_animal_count"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_preset_message, "str_herd_animal_limit_reached", preset_message_error),
		(try_end),
		(lt, "$g_herd_animal_count", "$g_max_herd_animal_count"),
		]),

	("animal_get_age", # server: reg0 = the seconds since the animal was born as a child, or extrapolated for spawned adults
	 [(store_script_param, ":animal_agent_id", 1), # must be valid

		(agent_get_slot, ":birth_time", ":animal_agent_id", slot_agent_animal_birth_time),
		(store_mission_timer_a, ":age"),
		(val_sub, ":age", ":birth_time"),
		(val_div, ":age", 60),
		(assign, reg0, ":age"),
		]),

	("animal_check_grow", # server: check if the animal should grow into an adult or birth a child; reg0 = the animal agent id
	 [(store_script_param, ":animal_agent_id", 1), # must be valid

		(agent_get_item_id, ":animal_item_id", ":animal_agent_id"),
		(store_mission_timer_a, ":time"),
		(try_begin),
			(item_slot_eq, ":animal_item_id", slot_item_animal_child_item_id, ":animal_item_id"),
			(agent_get_slot, ":grow_time", ":animal_agent_id", slot_agent_animal_grow_time),
			(try_begin),
				(le, ":grow_time", 0),
				(item_get_slot, ":grow_time", ":animal_item_id", slot_item_animal_grow_time),
				(agent_get_slot, ":birth_time", ":animal_agent_id", slot_agent_animal_birth_time),
				(val_add, ":grow_time", ":birth_time"),
				(agent_set_slot, ":animal_agent_id", slot_agent_animal_grow_time, ":grow_time"),
			(try_end),
			(ge, ":time", ":grow_time"),
			(agent_set_slot, ":animal_agent_id", slot_agent_animal_grow_time, 0),
			(item_get_slot, ":adult_item_id", ":animal_item_id", slot_item_animal_adult_item_id),
			(agent_get_position, pos1, ":animal_agent_id"),
			(set_spawn_position, pos1),
			(spawn_horse, ":adult_item_id"),
			(assign, ":adult_agent_id", reg0),
			(store_agent_hit_points, ":hit_points", ":animal_agent_id", 1),
			(agent_set_hit_points, ":adult_agent_id", ":hit_points", 1),
			(try_for_range, ":slot", 0, slot_agent_animal_end),
				(agent_get_slot, ":value", ":animal_agent_id", ":slot"),
				(agent_set_slot, ":adult_agent_id", ":slot", ":value"),
			(try_end),
			(agent_get_slot, ":herd_manager", ":animal_agent_id", slot_agent_animal_herd_manager),
			(agent_set_slot, ":animal_agent_id", slot_agent_animal_herd_manager, -1),
			(try_begin), # try add the new adult to the herd replacing the child
				(prop_instance_is_valid, ":herd_manager"),
				(scene_prop_slot_eq, ":herd_manager", slot_animal_herd_manager_adult_item_id, ":adult_item_id"),
				(item_get_slot, ":loop_end", ":adult_item_id", slot_item_animal_max_in_herd),
				(try_for_range, ":herd_slot", 0, ":loop_end"),
					(scene_prop_get_slot, ":herd_agent_id", ":herd_manager", ":herd_slot"),
					(eq, ":herd_agent_id", ":animal_agent_id"),
					(scene_prop_set_slot, ":herd_manager", ":herd_slot", ":adult_agent_id"),
					(agent_set_slot, ":adult_agent_id", slot_agent_animal_herd_manager, ":herd_manager"),
					(assign, ":loop_end", -1),
				(try_end),
				(eq, ":loop_end", -1),
			(else_try),
				(call_script, "script_animal_add_to_nearby_herd", ":adult_agent_id", -1),
			(try_end),
			(agent_fade_out, ":animal_agent_id"),
			(assign, ":animal_agent_id", ":adult_agent_id"),
		(else_try),
			(item_slot_eq, ":animal_item_id", slot_item_animal_adult_item_id, ":animal_item_id"),
			(lt, "$g_herd_animal_count", "$g_max_herd_animal_count"),
			(agent_get_slot, ":reproduce_time", ":animal_agent_id", slot_agent_animal_grow_time),
			(this_or_next|le, ":reproduce_time", 0),
			(ge, ":time", ":reproduce_time"),
			(try_begin), # wait one cycle after growing to adult before reproducing
				(gt, ":reproduce_time", 0),
				(agent_get_slot, ":herd_manager", ":animal_agent_id", slot_agent_animal_herd_manager),
				(try_begin),
					(prop_instance_is_valid, ":herd_manager"),
					(scene_prop_slot_eq, ":herd_manager", slot_animal_herd_manager_adult_item_id, ":animal_item_id"),
					(item_get_slot, ":loop_end", ":animal_item_id", slot_item_animal_max_in_herd),
					(try_for_range, ":herd_slot", 0, ":loop_end"), # verify that there is at least one other adult in the herd
						(scene_prop_get_slot, ":other_animal_agent_id", ":herd_manager", ":herd_slot"),
						(neq, ":other_animal_agent_id", ":animal_agent_id"),
						(agent_is_active, ":other_animal_agent_id"),
						(agent_is_alive, ":other_animal_agent_id"),
						(agent_get_item_id, ":other_animal_item_id", ":other_animal_agent_id"),
						(eq, ":other_animal_item_id", ":animal_item_id"),
						(assign, ":loop_end", -1),
					(try_end),
					(eq, ":loop_end", -1),
					(item_get_slot, ":child_item_id", ":animal_item_id", slot_item_animal_child_item_id),
					(agent_get_position, pos1, ":animal_agent_id"),
					(call_script, "script_set_random_spawn_position", 50),
					(copy_position, pos1, pos10),
					(call_script, "script_cf_spawn_herd_animal", ":child_item_id", ":herd_manager"),
				(try_end),
			(try_end),
			(item_get_slot, ":max_reproduce_time", ":animal_item_id", slot_item_animal_grow_time),
			(store_div, ":reproduce_time", ":reproduce_time", 2),
			(val_mul, ":max_reproduce_time", 2),
			(store_random_in_range, ":reproduce_time", ":reproduce_time", ":max_reproduce_time"),
			(val_add, ":reproduce_time", ":time"),
			(agent_set_slot, ":animal_agent_id", slot_agent_animal_grow_time, ":reproduce_time"),
		(try_end),
		(assign, reg0, ":animal_agent_id"),
		]),

	("animal_move", # server: move animals, trying to avoid drowning and running into walls, following the herd leader; failing to reproduce and starving if the leader couldn't move far enough
	 [(store_script_param, ":animal_agent_id", 1), # must be valid
		(store_script_param, ":leader_agent_id", 2), # must be valid

		(set_fixed_point_multiplier, 100),
		(agent_get_slot, ":herd_manager", ":animal_agent_id", slot_agent_animal_herd_manager),
		(assign, ":herd_is_starving", 0),
		(try_begin), # for the leader, check the actual distance moved since last time
			(eq, ":animal_agent_id", ":leader_agent_id"),
			(agent_get_position, pos1, ":animal_agent_id"),
			(store_random_in_range, ":random_angle", -30, 30),
			(prop_instance_get_position, pos6, ":herd_manager"),
			(get_sq_distance_between_positions, ":sq_distance_moved", pos1, pos6),
			(try_begin), # if the distance is insufficient, turn around to try avoid a possible obstruction
				(le, ":sq_distance_moved", sq(500)),
				(assign, ":herd_is_starving", 1),
				(val_add, ":random_angle", 180),
			(else_try),
				(position_get_distance_to_terrain, ":terrain_distance", pos1),
				(val_abs, ":terrain_distance"),
				(ge, ":terrain_distance", 100),
				(assign, ":herd_is_starving", 1),
			(try_end),
			(scene_prop_set_slot, ":herd_manager", slot_animal_herd_manager_starving, ":herd_is_starving"),
			(prop_instance_set_position, ":herd_manager", pos1, 1),
		(else_try),
			(agent_get_scripted_destination, pos1, ":leader_agent_id"),
			(store_random_in_range, ":random_angle", -180, 180),
			(scene_prop_get_slot, ":herd_is_starving", ":herd_manager", slot_animal_herd_manager_starving),
		(try_end),
		(agent_get_slot, ":times_stuck", ":animal_agent_id", slot_agent_animal_times_stuck),
		(agent_get_slot, ":food_amount", ":animal_agent_id", slot_agent_animal_food),
		(try_begin),
			(this_or_next|eq, ":herd_is_starving", 1),
			(ge, ":times_stuck", 5),
			(store_random_in_range, ":starve_chance", 0, 100),
			(lt, ":starve_chance", 50),
			(val_sub, ":food_amount", 1),
			(agent_set_slot, ":animal_agent_id", slot_agent_animal_food, ":food_amount"),
			(lt, ":food_amount", 0),
			(agent_get_item_id, ":animal_item_id", ":animal_agent_id"),
			(item_get_slot, ":death_sound", ":animal_item_id", slot_item_animal_death_sound),
			(try_begin),
				(gt, ":death_sound", 0),
				(agent_play_sound, ":animal_agent_id", ":death_sound"),
			(try_end),
			(item_get_slot, ":starvation_meat_loss", ":animal_item_id", slot_item_animal_meat_count),
			(val_mul, ":starvation_meat_loss", -1),
			(val_sub, ":starvation_meat_loss", 3),
			(lt, ":food_amount", ":starvation_meat_loss"),
			(remove_agent, ":animal_agent_id"),
			(assign, ":animal_agent_id", -1),
		(else_try),
			(eq, ":herd_is_starving", 0),
			(call_script, "script_animal_check_grow", ":animal_agent_id"),
			(assign, ":animal_agent_id", reg0),
			(lt, ":food_amount", 0),
			(val_add, ":food_amount", 1),
			(agent_set_slot, ":animal_agent_id", slot_agent_animal_food, ":food_amount"),
		(try_end),
		(try_begin),
			(neq, ":animal_agent_id", -1),
			(get_scene_boundaries, pos8, pos9),
			(position_get_x, ":scene_min_x", pos8),
			(position_get_y, ":scene_min_y", pos8),
			(position_get_x, ":scene_max_x", pos9),
			(position_get_y, ":scene_max_y", pos9),
			(assign, ":loop_end", 10),
			(try_for_range, ":unused", 0, ":loop_end"), # test multiple different distances and angles diverging from the current heading
				(copy_position, pos2, pos1),
				(position_rotate_z, pos2, ":random_angle"),
				(try_begin),
					(eq, ":animal_agent_id", ":leader_agent_id"),
					(store_random_in_range, ":random_distance", 1500, 2000),
				(else_try),
					(store_random_in_range, ":random_distance", 100, 1000),
				(try_end),
				(position_move_y, pos2, ":random_distance"),
				(copy_position, pos3, pos2),
				(position_set_z, pos3, 0),
				(position_get_distance_to_terrain, ":water_depth", pos3),
				(try_begin), # avoid water and scene boundaries
					(lt, ":water_depth", z_position_water_level * -1),
					(assign, ":continue", 1),
					(try_begin),
						(position_get_x, ":agent_x", pos2),
						(is_between, ":agent_x", ":scene_min_x", ":scene_max_x"),
						(position_get_y, ":agent_y", pos2),
						(is_between, ":agent_y", ":scene_min_y", ":scene_max_y"),
					(else_try),
						(val_add, ":random_angle", 180),
						(assign, ":continue", 0),
					(try_end),
					(eq, ":continue", 1),
					(position_get_distance_to_terrain, ":distance_to_terrain", pos2),
					(val_mul, ":distance_to_terrain", -1),
					(position_move_z, pos2, ":distance_to_terrain"),
					(try_begin),
						(eq, ":animal_agent_id", ":leader_agent_id"),
						(eq, ":times_stuck", 0), # unless the animal didn't move last time, avoid trying to move to a position without clear line of sight
						(copy_position, pos4, pos1),
						(copy_position, pos5, pos2),
						(position_move_z, pos4, 100, 1),
						(position_move_x, pos4, 50),
						(position_move_z, pos5, 100, 1),
						(neg|position_has_line_of_sight_to_position, pos4, pos5),
						(assign, ":continue", 0),
					(try_end),
					(eq, ":continue", 1),
					(store_random_in_range, ":speed", 10, 20),
					(agent_set_speed_limit, ":animal_agent_id", ":speed"),
					(agent_set_scripted_destination, ":animal_agent_id", pos2, 1),
					(assign, ":loop_end", -1),
				(else_try),
					(store_random_in_range, ":random", 0, 45),
					(try_begin),
						(lt, ":random_angle", 0),
						(val_mul, ":random", -1),
					(try_end),
					(val_add, ":random_angle", ":random"),
				(try_end),
			(try_end),
			(try_begin),
				(neq, ":loop_end", -1),
				(val_add, ":times_stuck", 1),
			(else_try),
				(assign, ":times_stuck", 0),
			(try_end),
			(agent_set_slot, ":animal_agent_id", slot_agent_animal_times_stuck, ":times_stuck"),
		(try_end),
		]),

	("animal_hit", # server: handle animal reactions to being hit by various tools and weapons; the damage result is set for ti_on_agent_hit
	 [(store_script_param, ":animal_agent_id", 1), # must be valid
		(store_script_param, ":attacker_agent_id", 2), # must be valid
		(store_script_param, ":damage_dealt", 3),
		(store_script_param, ":weapon_item_id", 4),

		(assign, ":damage_result", ":damage_dealt"),
		(agent_get_troop_id, ":troop_id", ":attacker_agent_id"),
		(store_skill_level, ":herding_skill", "skl_herding", ":troop_id"),
		(try_begin),
			(ge, ":herding_skill", 1),
			(ge, ":weapon_item_id", all_items_begin),
			(item_get_slot, ":item_class", ":weapon_item_id", slot_item_class),
			(try_begin),
				(is_between, ":item_class", item_class_herding_calm, item_class_herding_rouse + 1),
				(assign, ":damage_result", 0),
				(agent_get_position, pos1, ":animal_agent_id"),
				(try_begin), # move the animal in the oppisite direction from the hitting agent, with a random angle variation depending on skill and wildness
					(eq, ":item_class", item_class_herding_rouse),
					(set_fixed_point_multiplier, 100),
					(agent_get_position, pos2, ":attacker_agent_id"),
					(position_transform_position_to_local, pos3, pos2, pos1),
					(position_get_x, ":relative_x", pos3),
					(position_get_y, ":relative_y", pos3),
					(store_atan2, ":angle", ":relative_x", ":relative_y"),
					(convert_from_fixed_point, ":angle"),
					(agent_get_item_id, ":animal_item_id", ":animal_agent_id"),
					(item_get_slot, ":wildness", ":animal_item_id", slot_item_animal_wildness),
					(try_begin),
						(gt, ":wildness", 0),
						(store_mul, ":min_angle", ":wildness", -10),
						(store_mul, ":max_angle", ":wildness", 10),
						(store_random_in_range, ":random_angle", ":min_angle", ":max_angle"),
						(val_div, ":random_angle", ":herding_skill"),
						(val_add, ":angle", ":random_angle"),
						(store_div, ":random_scare_limit", 400, ":herding_skill"),
						(val_mul, ":random_scare_limit", ":wildness"),
						(store_random_in_range, ":distance", 0, ":random_scare_limit"),
					(else_try),
						(assign, ":distance", 0),
					(try_end),
					(val_mul, ":angle", -1),
					(position_copy_rotation, pos1, pos2),
					(position_rotate_z, pos1, ":angle"),
					(val_add, ":distance", 500),
					(store_mul, ":damage_component", ":damage_dealt", 10),
					(val_add, ":distance", ":damage_component"),
					(agent_get_action_dir, ":attack_type", ":attacker_agent_id"),
					(try_begin),
						(eq, ":attack_type", 3),
						(val_mul, ":distance", 2),
					(try_end),
					(position_move_y, pos1, ":distance"),
					(store_random_in_range, ":speed", 10, 20),
					(val_add, ":speed", ":herding_skill"),
					(agent_set_speed_limit, ":animal_agent_id", ":speed"),
				(try_end),
				(agent_set_scripted_destination, ":animal_agent_id", pos1, 0),
				(agent_force_rethink, ":animal_agent_id"),
				(agent_set_slot, ":animal_agent_id", slot_agent_horse_last_rider, -1),
				(try_begin),
					(eq, ":item_class", item_class_herding_calm),
					(agent_get_slot, ":herd_manager", ":animal_agent_id", slot_agent_animal_herd_manager),
					(call_script, "script_animal_add_to_nearby_herd", ":animal_agent_id", ":herd_manager"),
				(else_try), # more likely with higher herding skill: move some other animals in the herd with the target
					(eq, ":item_class", item_class_herding_rouse),
					(assign, ":found_leader", 0),
					(agent_get_slot, ":herd_manager", ":animal_agent_id", slot_agent_animal_herd_manager),
					(try_begin),
						(prop_instance_is_valid, ":herd_manager"),
						(scene_prop_get_slot, ":adult_item_id", ":herd_manager", slot_animal_herd_manager_adult_item_id),
						(ge, ":adult_item_id", all_items_begin),
						(item_get_slot, ":loop_end", ":adult_item_id", slot_item_animal_max_in_herd),
						(try_for_range, ":herd_slot", 0, ":loop_end"),
							(store_random_in_range, ":random_move", ":herding_skill", 21),
							(ge, ":random_move", 10),
							(scene_prop_get_slot, ":herd_agent_id", ":herd_manager", ":herd_slot"),
							(neq, ":herd_agent_id", ":animal_agent_id"),
							(agent_is_active, ":herd_agent_id"),
							(agent_is_alive, ":herd_agent_id"),
							(copy_position, pos4, pos1),
							(store_random_in_range, ":random_angle", 0, 360),
							(position_rotate_z, pos4, ":random_angle"),
							(store_random_in_range, ":random_distance", 100, 1000),
							(position_move_y, pos4, ":random_distance"),
							(agent_set_speed_limit, ":herd_agent_id", ":speed"),
							(agent_set_scripted_destination, ":herd_agent_id", pos4, 0),
							(eq, ":found_leader", 0),
							(assign, ":found_leader", 1),
							(agent_get_slot, ":move_time", ":herd_agent_id", slot_agent_animal_move_time),
							(gt, ":move_time", 0),
							(store_random_in_range, ":extra_time", 10, 21),
							(val_add, ":move_time", ":extra_time"),
							(agent_set_slot, ":herd_agent_id", slot_agent_animal_move_time, ":move_time"),
						(try_end),
					(try_end),
				(try_end),
			(try_end),
			(eq, ":damage_result", 0),
		(else_try),
			(eq, ":weapon_item_id", "itm_wheat_sheaf"),
			(call_script, "script_cf_agent_consume_item", ":attacker_agent_id", ":weapon_item_id", 1),
			(agent_get_slot, ":food", ":animal_agent_id", slot_agent_animal_food),
			(val_add, ":food", 5),
			(agent_get_item_id, ":animal_item_id", ":animal_agent_id"),
			(item_get_slot, ":food_capacity", ":animal_item_id", slot_item_animal_meat_count),
			(val_mul, ":food_capacity", 2),
			(val_min, ":food", ":food_capacity"),
			(agent_set_slot, ":animal_agent_id", slot_agent_animal_food, ":food"),
			(assign, ":damage_result", 0),
		(else_try), # if enough damage is dealt with other weapons, check the whole herd for reactions
			(agent_get_item_id, ":animal_item_id", ":animal_agent_id"),
			(item_get_slot, ":wildness", ":animal_item_id", slot_item_animal_wildness),
			(store_random_in_range, ":minimum_startle_damage", 1, 10),
			(val_sub, ":minimum_startle_damage", ":wildness"),
			(ge, ":damage_dealt", ":minimum_startle_damage"),
			(call_script, "script_animal_react_to_attack", ":attacker_agent_id", ":animal_agent_id", ":damage_dealt"),
			(agent_get_slot, ":herd_manager", ":animal_agent_id", slot_agent_animal_herd_manager),
			(try_begin),
				(prop_instance_is_valid, ":herd_manager"),
				(assign, ":found_leader", 0),
				(scene_prop_get_slot, ":adult_item_id", ":herd_manager", slot_animal_herd_manager_adult_item_id),
				(ge, ":adult_item_id", all_items_begin),
				(item_get_slot, ":loop_end", ":adult_item_id", slot_item_animal_max_in_herd),
				(try_for_range, ":herd_slot", 0, ":loop_end"),
					(scene_prop_get_slot, ":herd_agent_id", ":herd_manager", ":herd_slot"),
					(agent_is_active, ":herd_agent_id"),
					(agent_is_alive, ":herd_agent_id"),
					(call_script, "script_animal_react_to_attack", ":attacker_agent_id", ":herd_agent_id", ":damage_dealt"),
					(eq, ":found_leader", 0),
					(assign, ":found_leader", 1),
					(agent_get_slot, ":move_time", ":herd_agent_id", slot_agent_animal_move_time),
					(gt, ":move_time", 0),
					(store_random_in_range, ":extra_time", 10, 21),
					(val_add, ":move_time", ":extra_time"),
					(agent_set_slot, ":herd_agent_id", slot_agent_animal_move_time, ":move_time"),
				(try_end),
			(try_end),
		(try_end),
		(set_trigger_result, ":damage_result"),
		]),

	("animal_react_to_attack", # server: handle specific animal reactions to being attacked, whether to charge or flee
	 [(store_script_param, ":attacker_agent_id", 1), # must be valid
		(store_script_param, ":animal_agent_id", 2), # must be valid
		(store_script_param, ":damage_dealt", 3),

		(agent_get_item_id, ":animal_item_id", ":animal_agent_id"),
		(try_begin),
			(gt, ":animal_item_id", -1),
			(set_fixed_point_multiplier, 100),
			(agent_get_position, pos1, ":animal_agent_id"),
			(agent_get_position, pos2, ":attacker_agent_id"),
			(position_transform_position_to_local, pos3, pos2, pos1),
			(position_normalize_origin, ":distance_to_animal", pos3),
			(lt, ":distance_to_animal", max_distance_to_include_in_herd),
			(item_get_slot, ":reaction", ":animal_item_id", slot_item_animal_attack_reaction),
			(position_get_x, ":relative_x", pos3),
			(position_get_y, ":relative_y", pos3),
			(store_atan2, ":angle", ":relative_x", ":relative_y"),
			(convert_from_fixed_point, ":angle"),
			(val_mul, ":angle", -1),
			(try_begin),
				(eq, ":reaction", animal_reaction_charge),
				(store_random_in_range, ":distance", 500, 700), # move past the targeted agent, so the animal charges through at speed
				(try_begin),
					(lt, ":distance_to_animal", 200),
					(position_copy_rotation, pos1, pos2),
				(else_try),
					(copy_position, pos1, pos2),
					(val_add, ":angle", 180),
				(try_end),
				(position_rotate_z, pos1, ":angle"),
				(assign, ":speed", 100),
			(else_try),
				(eq, ":reaction", animal_reaction_flee),
				(store_random_in_range, ":random_angle", -70, 71),
				(position_copy_rotation, pos1, pos2),
				(val_add, ":angle", ":random_angle"),
				(position_rotate_z, pos1, ":angle"),
				(store_agent_hit_points, ":max_multiplier", ":animal_agent_id", 0),
				(store_sub, ":min_multiplier", ":max_multiplier", 50),
				(assign, ":speed_limit", ":max_multiplier"),
				(val_clamp, ":max_multiplier", 50, 100),
				(val_clamp, ":min_multiplier", 25, 50),
				(val_clamp, ":speed_limit", 25, 100),
				(store_random_in_range, ":random_multiplier", ":min_multiplier", ":max_multiplier"),
				(assign, ":distance", ":damage_dealt"),
				(val_max, ":distance", 10),
				(val_mul, ":distance", ":random_multiplier"),
				(item_get_slot, ":wildness", ":animal_item_id", slot_item_animal_wildness),
				(try_begin),
					(gt, ":wildness", 0),
					(store_mul, ":extra_distance", ":distance", ":wildness"),
					(val_div, ":extra_distance", 10),
					(val_add, ":distance", ":extra_distance"),
				(try_end),
				(val_max, ":wildness", 1),
				(store_random_in_range, ":speed", ":wildness", 10),
				(val_mul, ":speed", ":damage_dealt"),
				(val_max, ":speed", ":speed_limit"),
			(try_end),
			(position_move_y, pos1, ":distance"),
			(agent_set_speed_limit, ":animal_agent_id", ":speed"),
			(agent_set_scripted_destination, ":animal_agent_id", pos1, 1),
			(agent_force_rethink, ":animal_agent_id"),
		(try_end),
		]),

	("check_agent_horse_speed_factor", # server: adjust riding speed for water, horse health, and the agent being overloaded by weapons or armor
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":horse_agent_id", 2), # must be valid
		(store_script_param, ":under_water", 3), # 1 if the horse is below water level

		(store_agent_hit_points, ":speed_factor", ":horse_agent_id", 0), # horse speed corresponds to health
		(try_begin), # underwater or attached to a cart, speed is clamped down below 50%
			(agent_get_attached_scene_prop, ":attached_spr", ":horse_agent_id"),
			(this_or_next|ge, ":under_water", 1),
			(neq, ":attached_spr", -1),
			(val_clamp, ":speed_factor", 20, 50),
		(else_try), # otherwise, speed reduction for health is between 100% - 50%
			(val_add, ":speed_factor", 50),
			(val_min, ":speed_factor", 100),
		(try_end),
		(agent_get_slot, ":rider_speed_factor", ":agent_id", slot_agent_armor_speed_factor),
		(agent_get_slot, ":weapon_speed_factor", ":agent_id", slot_agent_weapon_speed_factor),
		(val_add, ":rider_speed_factor", ":weapon_speed_factor"),
		(try_begin), # if the agent is using weapons or armor they don't meet requirements for, reduce the speed further
			(gt, ":rider_speed_factor", 0),
			(store_sub, ":rider_speed_factor", reduction_factor_base, ":rider_speed_factor"),
			(val_div, ":rider_speed_factor", 2),
			(val_min, ":speed_factor", ":rider_speed_factor"),
			(val_max, ":speed_factor", 0),
		(try_end),
		(agent_set_horse_speed_factor, ":agent_id", ":speed_factor"),
		(try_begin), # drop couchable lances if unusable, since the different attack method won't be detected by the normal check
			(agent_slot_eq, ":agent_id", slot_agent_cannot_attack, 1),
			(agent_get_wielded_item, ":item_id", ":agent_id", 0),
			(neq, ":item_id", -1),
			(item_slot_eq, ":item_id", slot_item_couchable, 1),
			(call_script, "script_cf_agent_consume_item", ":agent_id", ":item_id", 1),
			(agent_get_position, pos1, ":agent_id"),
			(set_spawn_position, pos1),
			(spawn_item, ":item_id", 0, "$g_spawn_item_prune_time"),
		(try_end),
		]),

	("check_remove_lost_horse", # server: remove horses that have strayed away from their last rider for a long time, to reduce server load
	 [(store_script_param, ":horse_agent_id", 1), # must be valid

		(agent_get_item_id, ":horse_item_id", ":horse_agent_id"),
		(try_begin),
			(le, ":horse_item_id", -1),
		(else_try),
			(neg|item_slot_eq, ":horse_item_id", slot_item_animal_adult_item_id, 0),
		(else_try),
			(agent_get_slot, ":last_rider", ":horse_agent_id", slot_agent_horse_last_rider),
			(agent_get_rider, ":rider_agent_id", ":horse_agent_id"),
			(gt, ":rider_agent_id", -1),
			(try_begin),
				(neq, ":last_rider", ":rider_agent_id"),
				(agent_set_slot, ":horse_agent_id", slot_agent_horse_last_rider, ":rider_agent_id"),
			(try_end),
			(call_script, "script_check_agent_horse_speed_factor", ":rider_agent_id", ":horse_agent_id", 0),
		(else_try), # don't remove horses with carts attached
			(agent_get_attached_scene_prop, ":attached_instance_id", ":horse_agent_id"),
			(prop_instance_is_valid, ":attached_instance_id"),
		(else_try),
			(gt, ":last_rider", -1),
			(try_begin),
				(agent_is_active, ":last_rider"),
				(agent_is_alive, ":last_rider"),
				(agent_get_position, pos1, ":last_rider"),
				(agent_get_position, pos2, ":horse_agent_id"),
				(get_sq_distance_between_positions, ":sq_distance", pos1, pos2),
				(le, ":sq_distance", sq(max_distance_horse_rider)),
			(else_try),
				(agent_set_slot, ":horse_agent_id", slot_agent_horse_last_rider, -1),
				(agent_is_in_special_mode, ":horse_agent_id"),
				(agent_clear_scripted_mode, ":horse_agent_id"),
				(agent_force_rethink, ":horse_agent_id"),
			(try_end),
		(else_try), # negative last rider values count up the amount of checks while strayed
			(le, ":last_rider", -20),
			(store_item_value, ":horse_value", ":horse_item_id"),
			(assign, ":kill", 1),
			(try_begin),
				(ge, ":horse_value", 5000),
				(gt, ":last_rider", -60),
				(assign, ":kill", 0),
			(else_try),
				(ge, ":horse_value", 2000),
				(gt, ":last_rider", -40),
				(assign, ":kill", 0),
			(try_end),
			(eq, ":kill", 1),
			(agent_fade_out, ":horse_agent_id"),
		(else_try),
			(val_sub, ":last_rider", 1),
			(agent_set_slot, ":horse_agent_id", slot_agent_horse_last_rider, ":last_rider"),
		(try_end),
		]),

	("check_agent_drowning", # server: check whether the agent's mouth is below water level, dealing damage after a length of time
	 [(store_script_param, ":agent_id", 1), # must be valid

		(try_begin),
			(agent_is_alive, ":agent_id"),
			##Arthur debug
			#(try_begin),
			#	(agent_get_player_id, ":player_id", ":agent_id"),
			#	(player_is_active, ":player_id"),
			#	(multiplayer_send_string_to_player, ":player_id", server_event_local_chat, "@Drown check"),
			#(try_end),
			(agent_get_troop_id, ":troop_id", ":agent_id"),
      #GGG:bots
      (neq, ":troop_id", "trp_royal_archer"),
      (neq, ":troop_id", "trp_royal_man_at_arms"),
      (neq, ":troop_id", "trp_royal_footman"),
      (neq, ":troop_id", "trp_royal_lord"),
      #
			(neq, ":troop_id", "trp_godlike_hero"),
			(agent_get_item_id, ":horse_item_id", ":agent_id"),
			(neq, ":horse_item_id", "itm_admin_horse"),
			(agent_get_position, pos1, ":agent_id"),
			(agent_get_slot, ":drowning_count", ":agent_id", slot_agent_drowning_count),
			(agent_get_horse, ":horse_agent_id", ":agent_id"),
			(assign, ":drown_height", -192),
			(set_fixed_point_multiplier, 100),
			(position_get_z, ":height", pos1),
			(try_begin), # adjust for the angle of a horses's body making the head higher or lower
				(gt, ":horse_item_id", -1),
				(copy_position, pos2, pos1),
				(position_move_y, pos2, 50),
				(position_move_z, pos2, -200, 1),
				(position_set_z_to_ground_level, pos2),
				(position_get_z, ":horse_height", pos2),
				(store_sub, ":horse_height_difference", ":horse_height", ":height"),
				(val_abs, ":horse_height_difference"),
				(lt, ":horse_height_difference", 100),
				(assign, ":height", ":horse_height"),
			(else_try), # if a rider, add the approximate height of the horse
				(gt, ":horse_agent_id", -1),
				(assign, ":drown_height", -275),
			(else_try),
				(agent_get_crouch_mode, ":is_crouched", ":agent_id"),
				(eq, ":is_crouched", 1),
				(assign, ":drown_height", -127),
			(try_end),
			(try_begin),
				(le, ":height", ":drown_height"),
				(assign, ":under_water", 1),
				(agent_get_player_id, ":player_id", ":agent_id"),
				#(try_begin),
				#	(multiplayer_send_string_to_player, ":player_id", server_event_local_chat, "@You are drowning! Get back to land!"),
				#(try_end),
				(agent_get_speed, pos4, ":agent_id"),
				(position_get_y, ":forwards_speed", pos4),
				(val_abs, ":forwards_speed"),
				(val_div, ":forwards_speed", 200),
				(val_add, ":forwards_speed", 1),
				(val_add, ":drowning_count", ":forwards_speed"), # drown more quickly at higher speed
				(agent_set_slot, ":agent_id", slot_agent_drowning_count, ":drowning_count"),
				(store_sub, ":damage", ":drowning_count", 2),
				(agent_get_troop_id, ":troop_id", ":agent_id"),
				(store_skill_level, ":sailing_skill", "skl_sailing", ":troop_id"),
				#GGG:sailing skill
				#(try_begin),
				#	(ge, ":sailing_skill", 4),
				#	(store_sub, ":need_water", 11, ":sailing_skill"),
				#	(agent_get_slot, ":water_amount", ":agent_id", slot_agent_water_amount),
				#	(ge, ":water_amount", ":need_water"),
				#	(val_sub, ":water_amount", ":need_water"),
				#	(agent_set_slot, ":agent_id", slot_agent_water_amount, ":water_amount"),
				#	(agent_get_player_id, ":player_id", ":agent_id"),
				#	(multiplayer_send_3_int_to_player, ":player_id", server_event_agent_set_slot, ":agent_id", slot_agent_water_amount, ":water_amount"),
				(try_begin),
				#	

					(val_div, ":sailing_skill", 4),
					(val_sub, ":damage", ":sailing_skill"),
					(try_begin),
						(gt, ":damage", 1),
						(val_mul, ":damage", ":damage"),
						(try_begin),
							(eq, "$g_full_respawn_health", 0),
							(val_mul, ":damage", 2),
						(try_end),
						(store_agent_hit_points, ":original_hit_points", ":agent_id", 1),
						(store_sub, ":hit_points", ":original_hit_points", ":damage"),
						(agent_deliver_damage_to_agent, ":agent_id", ":agent_id", 5),
						(agent_set_hit_points, ":agent_id", ":hit_points", 1),
						(try_begin),
							(gt, ":original_hit_points", 5),
							(try_begin),
								(agent_is_human, ":agent_id"),
								(agent_get_player_id, ":player_id", ":agent_id"),
								(try_begin),
									(player_is_active, ":player_id"),
									(player_get_gender, ":gender", ":player_id"),
									(eq, ":gender", tf_female),
									(agent_play_sound, ":agent_id", "snd_woman_drown"),
								(else_try),
									(agent_play_sound, ":agent_id", "snd_man_drown"),
								(try_end),
							(else_try),
								(item_slot_eq, ":horse_item_id", slot_item_animal_adult_item_id, 0),
								(agent_play_sound, ":agent_id", "snd_horse_low_whinny"),
							(try_end),
						(try_end),
					(try_end), #GGG
				(try_end),
			(else_try),
				(assign, ":under_water", 0),
				(gt, ":drowning_count", 0),
				(agent_set_slot, ":agent_id", slot_agent_drowning_count, -2),
				(try_begin),
					(agent_is_human, ":agent_id"),
					(agent_play_sound, ":agent_id", "snd_man_cough"),
				(else_try),
					(agent_play_sound, ":agent_id", "snd_horse_snort"),
				(try_end),
			(try_end),
			(try_begin),
				(neq, ":horse_agent_id", -1),
				(call_script, "script_check_agent_horse_speed_factor", ":agent_id", ":horse_agent_id", ":under_water"),
			(try_end),
		(try_end),
		]),

	("setup_ship", # server: spawn the necessary parts for a ship at mission start
	 [(store_script_param, ":hull_instance_id", 1), # must be valid

		(troop_get_slot, ":ship_array_count", "trp_ship_array", 0),
		(val_add, ":ship_array_count", 1),
		(troop_set_slot, "trp_ship_array", ":ship_array_count", ":hull_instance_id"),
		(troop_set_slot, "trp_ship_array", 0, ":ship_array_count"),
		(try_begin),
			(multiplayer_is_server),
			(neq, "$g_edit_scene", 1),
			(store_script_param, ":sail_scene_prop_id", 2),
			(store_script_param, ":sail_off_scene_prop_id", 3),
			(store_script_param, ":ramp_scene_prop_id", 4),
			(store_script_param, ":hold_scene_prop_id", 5),
			(prop_instance_get_position, pos1, ":hull_instance_id"),
			(try_begin),
				(gt, ":sail_scene_prop_id", -1),
				(copy_position, pos2, pos1),
				(position_set_z, pos2, z_position_to_hide_object),
				(set_spawn_position, pos2),
				(spawn_scene_prop, ":sail_scene_prop_id"),
				(scene_prop_set_slot, ":hull_instance_id", slot_scene_prop_linked_sail, reg0),
				(scene_prop_set_slot, reg0, slot_scene_prop_linked_scene_prop, ":hull_instance_id"),
			(else_try),
				(scene_prop_set_slot, ":hull_instance_id", slot_scene_prop_linked_sail, -1),
			(try_end),
			(try_begin),
				(gt, ":sail_off_scene_prop_id", -1),
				(set_spawn_position, pos1),
				(spawn_scene_prop, ":sail_off_scene_prop_id"),
				(scene_prop_set_slot, ":hull_instance_id", slot_scene_prop_linked_sail_off, reg0),
				(scene_prop_set_slot, reg0, slot_scene_prop_linked_scene_prop, ":hull_instance_id"),
			(else_try),
				(scene_prop_set_slot, ":hull_instance_id", slot_scene_prop_linked_sail_off, -1),
			(try_end),
			(try_begin),
				(gt, ":ramp_scene_prop_id", -1),
				(prop_instance_get_variation_id, ":ramp_start_position", ":hull_instance_id"),
				(try_begin),
					(gt, ":ramp_start_position", 1),
					(assign, ":ramp_start_position", -1),
				(try_end),
				(call_script, "script_ship_get_ramp_relative_position", ":ramp_start_position", 1),
				(position_transform_position_to_parent, pos2, pos1, pos30),
				(set_spawn_position, pos2),
				(spawn_scene_prop, ":ramp_scene_prop_id"),
				(scene_prop_set_slot, ":hull_instance_id", slot_scene_prop_linked_ramp, reg0),
				(scene_prop_set_slot, reg0, slot_scene_prop_linked_scene_prop, ":hull_instance_id"),
				(scene_prop_set_slot, reg0, slot_scene_prop_position, ":ramp_start_position"),
			(else_try),
				(scene_prop_set_slot, ":hull_instance_id", slot_scene_prop_linked_ramp, -1),
			(try_end),
			(try_begin),
				(gt, ":hold_scene_prop_id", -1),
				(set_spawn_position, pos1),
				(spawn_scene_prop, ":hold_scene_prop_id"),
				(scene_prop_set_slot, ":hull_instance_id", slot_scene_prop_linked_hold, reg0),
				(scene_prop_set_slot, reg0, slot_scene_prop_linked_scene_prop, ":hull_instance_id"),
			(else_try),
				(scene_prop_set_slot, ":hull_instance_id", slot_scene_prop_linked_hold, -1),
			(try_end),
			(scene_prop_get_slot, ":cd_scene_prop_id", ":hull_instance_id", slot_scene_prop_collision_kind),
			(try_begin),
				(gt, ":cd_scene_prop_id", -1),
				(scene_prop_get_num_instances, ":num_instances", ":cd_scene_prop_id"),
				(lt, ":num_instances", 2),
				(init_position, pos1),
				(position_set_z, pos1, z_position_to_hide_object),
				(set_spawn_position, pos1),
				(spawn_scene_prop, ":cd_scene_prop_id"),
				(spawn_scene_prop, ":cd_scene_prop_id"),
			(try_end),
		(try_end),
		]),

	("agent_get_ship_station", # check if an agent is within the correct area on a ship to operate one of the stations; reg0 = constant starting with ship_station_
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid

		(assign, ":station", ship_station_not_on_ship),
		(try_begin),
			(agent_is_active, ":agent_id"),
			(agent_is_alive, ":agent_id"),
			(scene_prop_has_agent_on_it, ":instance_id", ":agent_id"),
			(assign, ":station", ship_station_none),
			(prop_instance_get_position, pos1, ":instance_id"),
			(agent_get_position, pos20, ":agent_id"),
			(position_transform_position_to_local, pos21, pos1, pos20),
			(set_fixed_point_multiplier, 100),
			(position_get_x, ":x_pos", pos21),
			(position_get_y, ":y_pos", pos21),
			(position_get_z, ":z_pos", pos21),
			(is_between, ":y_pos", -150, 150),
			(try_begin),
				(is_between, ":x_pos", -50, 250),
				(assign, ":station", ship_station_mast),
			(else_try),
				(scene_prop_get_slot, ":hull_length", ":instance_id", slot_scene_prop_length),
				(val_mul, ":hull_length", -1),
				(lt, ":x_pos", ":hull_length"),
				(lt, ":z_pos", 500),
				(assign, ":station", ship_station_rudder),
			(try_end),
		(try_end),
		(assign, reg0, ":station"),
		]),

	("ship_get_ramp_relative_position", # return the relative position of a ramp on a ship in pos30, for use with position_transform_position_to_parent
	 [(store_script_param, ":ramp_target", 1), # 0 = middle, -1 = left, 1 = right
		(store_script_param, ":match_ground", 2), # 1 = try to angle the ramp down so the end meets ground level

		(init_position, pos30),
		(try_begin),
			(position_move_x, pos30, 200),
			(try_begin),
				(eq, ":ramp_target", 0),
				(position_move_z, pos30, 220),
				(position_rotate_y, pos30, -3),
			(else_try),
				(position_move_z, pos30, 305),
				(copy_position, pos31, pos30),
				(try_begin),
					(gt, ":ramp_target", 0),
					(position_move_y, pos30, 500),
					(position_move_y, pos31, 1250),
					(position_rotate_z, pos30, 90),
				(else_try),
					(position_move_y, pos30, -500),
					(position_move_y, pos31, -1250),
					(position_rotate_z, pos30, -90),
				(try_end),
				(try_begin),
					(eq, ":match_ground", 1),
					(position_transform_position_to_parent, pos32, pos1, pos31),
					(position_move_z, pos32, 500),
					(set_fixed_point_multiplier, 100),
					(position_get_distance_to_ground_level, ":ground_clearance", pos32),
					(val_sub, ":ground_clearance", 500),
					(lt, ":ground_clearance", 750),
					(assign, ":clearance_ramp", ":ground_clearance"),
					(val_abs, ":clearance_ramp"),
					(convert_to_fixed_point, ":clearance_ramp"),
					(val_div, ":clearance_ramp", 750),
					(store_asin, ":ramp_angle", ":clearance_ramp"),
					(convert_from_fixed_point, ":ramp_angle"),
					(val_min, ":ramp_angle", 50),
					(try_begin),
						(lt, ":ground_clearance", 0),
						(val_mul, ":ramp_angle", -1),
					(try_end),
					(position_rotate_y, pos30, ":ramp_angle"),
				(try_end),
			(try_end),
		(try_end),
		]),

	("use_ship_ramp", # server: move a ship's ramp to a different position, based on the relative position of the agent to the ramp
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid

		(prop_instance_get_position, pos1, ":instance_id"),
		(agent_get_position, pos2, ":agent_id"),
		(scene_prop_get_slot, ":hull_instance_id", ":instance_id", slot_scene_prop_linked_scene_prop),
		(scene_prop_get_slot, ":ramp_position", ":instance_id", slot_scene_prop_target_position),
		(assign, ":ramp_target", ":ramp_position"),
		(try_begin),
			(eq, ":ramp_position", 0),
			(position_transform_position_to_local, pos3, pos1, pos2),
			(position_get_y, ":y_pos", pos3),
			(try_begin),
				(lt, ":y_pos", 0),
				(assign, ":ramp_target", 1),
			(else_try),
				(assign, ":ramp_target", -1),
			(try_end),
		(else_try), # don't allow agents off the ship to withdraw the ramp
			(scene_prop_has_agent_on_it, ":hull_instance_id", ":agent_id"),
			(assign, ":ramp_target", 0),
		(try_end),
		(scene_prop_set_slot, ":instance_id", slot_scene_prop_target_position, ":ramp_target"),
		]),

	("cf_check_ship_climb_side", # server and clients: check if the agent is near enough to climb on the ship, performing the movement if the server
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":instance_id", 2), # must be valid

		(scene_prop_slot_eq, ":instance_id", slot_scene_prop_state, scene_prop_state_active),
		(set_fixed_point_multiplier, 100),
		(prop_instance_get_position, pos1, ":instance_id"),
		(agent_get_position, pos2, ":agent_id"),
		(position_transform_position_to_local, pos3, pos1, pos2),
		(position_get_x, ":relative_x", pos3),
		(scene_prop_get_slot, ":hull_length", ":instance_id", slot_scene_prop_length),
		(store_mul, ":neg_hull_length", ":hull_length", -1),
		(is_between, ":relative_x", ":neg_hull_length", ":hull_length"),
		(position_get_y, ":relative_y", pos3),
		(scene_prop_get_slot, ":hull_width", ":instance_id", slot_scene_prop_width),
		(store_mul, ":neg_hull_width", ":hull_width", -1),
		(neg|is_between, ":relative_y", ":neg_hull_width", ":hull_width"),
		(store_add, ":climb_width", ":hull_width", 300),
		(store_mul, ":neg_climb_width", ":climb_width", -1),
		(is_between, ":relative_y", ":neg_climb_width", ":climb_width"),
		(try_begin),
			(multiplayer_is_server),
			(try_begin),
				(gt, ":relative_y", 0),
				(position_set_y, pos3, ":hull_width"),
			(else_try),
				(position_set_y, pos3, ":neg_hull_width"),
			(try_end),
			(position_set_z, pos3, 300),
			(position_transform_position_to_parent, pos4, pos1, pos3),
			(agent_set_position, ":agent_id", pos4),
		(try_end),
		]),

	("cf_client_check_control_ship", # clients: check for keys pressed when at the correct areas of a ship, sending the commands to the server
	 [
		(multiplayer_get_my_player, ":my_player_id"),
		(player_get_agent_id, ":my_agent_id", ":my_player_id"),
		(agent_is_active, ":my_agent_id"),
		(agent_is_alive, ":my_agent_id"),
		(troop_get_slot, ":ship_array_count", "trp_ship_array", 0),
		(store_add, ":ship_array_end", ":ship_array_count", 1),
		(assign, ":climb_instance_id", -1),
		(try_for_range, ":ship_no", 1, ":ship_array_end"),
			(troop_get_slot, ":hull_instance_id", "trp_ship_array", ":ship_no"),
			(call_script, "script_agent_get_ship_station", ":my_agent_id", ":hull_instance_id"),
			(try_begin),
				(eq, reg0, ship_station_not_on_ship),
				(key_clicked, key_up),
				(call_script, "script_cf_check_ship_climb_side", ":my_agent_id", ":hull_instance_id"),
				(assign, ":climb_instance_id", ":hull_instance_id"),
			(try_end),
			(gt, reg0, ship_station_not_on_ship),
			(assign, ":station", reg0),
			(assign, ":forwards", 0),
			(assign, ":rotation", 0),
			(assign, ":fail", 0),
			(try_begin),
				(eq, ":station", ship_station_mast),
				(try_begin),
					(key_clicked, key_up),
					(assign, ":forwards", 1),
				(else_try),
					(key_clicked, key_down),
					(assign, ":forwards", -1),
				(try_end),
			(else_try),
				(eq, ":station", ship_station_rudder),
				(try_begin),
					(key_clicked, key_left),
					(assign, ":rotation", 1),
				(else_try),
					(key_clicked, key_right),
					(assign, ":rotation", -1),
				(try_end),
			(else_try),
				(assign, ":fail", 1),
				(call_script, "script_preset_message", "str_not_at_mast_or_rudder", preset_message_error, 0, 0),
			(try_end),
			(eq, ":fail", 0),
			(multiplayer_send_3_int_to_server, client_event_control_scene_prop, ":hull_instance_id", ":forwards", ":rotation"),
			(assign, ":ship_array_end", -1),
		(try_end),
		(try_begin),
			(neq, ":ship_array_end", -1),
			(neq, ":climb_instance_id", -1),
			(multiplayer_send_2_int_to_server, client_event_control_scene_prop, ":climb_instance_id", 1),
		(try_end),
		(eq, ":ship_array_end", -1),
		]),

	("cf_control_ship", # server: handle player requests to control a ship
	 [(store_script_param, ":player_id", 1),
		(store_script_param, ":instance_id", 2), # must be valid
		(store_script_param, ":forwards", 3),
		(store_script_param, ":rotation", 4),

		(val_clamp, ":forwards", -1, 2),
		(val_clamp, ":rotation", -1, 2),
		(player_is_active, ":player_id"),
		(player_get_agent_id, ":agent_id", ":player_id"),
		(agent_is_alive, ":agent_id"),
		(scene_prop_slot_eq, ":instance_id", slot_scene_prop_state, scene_prop_state_active),
		(try_begin),
			(call_script, "script_agent_get_ship_station", ":agent_id", ":instance_id"),
			(try_begin),
				(eq, reg0, ship_station_not_on_ship),
				(eq, ":forwards", 1),
				(call_script, "script_cf_check_ship_climb_side", ":agent_id", ":instance_id"),
			(try_end),
			(gt, reg0, ship_station_not_on_ship),
			(assign, ":station", reg0),
			(try_begin),
				(eq, ":station", ship_station_mast),
				(try_begin),
					(neq, ":forwards", 0),
					(scene_prop_get_slot, ":current_forwards", ":instance_id", slot_scene_prop_target_position),
					(val_add, ":current_forwards", ":forwards"),
					(scene_prop_get_slot, ":speed_limit", ":instance_id", slot_scene_prop_speed_limit),
					(val_clamp, ":current_forwards", -1, ":speed_limit"),
					(agent_get_troop_id, ":troop_id", ":agent_id"),
					(store_skill_level, ":sailing_skill", "skl_sailing", ":troop_id"),
					(val_max, ":sailing_skill", 1),
					(ge, ":sailing_skill", ":current_forwards"),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_target_position, ":current_forwards"),
				(try_end),
			(else_try),
				(eq, ":station", ship_station_rudder),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_controlling_agent, ":agent_id"),
				(try_begin),
					(eq, ":rotation", 0),
					(eq, ":forwards", 0),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_target_rotation, 0),
				(else_try),
					(scene_prop_get_slot, ":current_rotation", ":instance_id", slot_scene_prop_target_rotation),
					(val_add, ":current_rotation", ":rotation"),
					(val_clamp, ":current_rotation", -ship_rotation_maximum, ship_rotation_maximum + 1),
					(scene_prop_set_slot, ":instance_id", slot_scene_prop_target_rotation, ":current_rotation"),
				(try_end),
			(try_end),
		(try_end),
		(gt, reg0, ship_station_not_on_ship),
		]),

	("move_ship", # server: animate movement of all ship parts together, also handling collision detection
	 [(store_script_param, ":hull_instance_id", 1), # must be valid

		(scene_prop_get_slot, ":ramp_instance_id", ":hull_instance_id", slot_scene_prop_linked_ramp),
		(scene_prop_get_slot, ":forwards", ":hull_instance_id", slot_scene_prop_position),
		(scene_prop_get_slot, ":target_forwards", ":hull_instance_id", slot_scene_prop_target_position),
		(scene_prop_set_slot, ":hull_instance_id", slot_scene_prop_position, ":target_forwards"),
		(try_begin),
			(neq, ":forwards", 0), # ship is moving
			(set_fixed_point_multiplier, 100),
			(prop_instance_get_position, pos1, ":hull_instance_id"),
			(assign, ":crashed", 0),
			(scene_prop_get_slot, ":cd_scene_prop_id", ":hull_instance_id", slot_scene_prop_collision_kind),
			(scene_prop_get_instance, ":cd_instance_id", ":cd_scene_prop_id", 0),
			(prop_instance_set_position, ":cd_instance_id", pos1, 1),
			(init_position, pos4),
			(position_set_z, pos4, z_position_to_hide_object),
			(troop_get_slot, ":ship_array_end", "trp_ship_array", 0),
			(val_add, ":ship_array_end", 1),
			(try_for_range, ":ship_array_slot", 1, ":ship_array_end"), # check collision with other ships
				(troop_get_slot, ":other_hull_instance_id", "trp_ship_array", ":ship_array_slot"),
				(neq, ":other_hull_instance_id", ":hull_instance_id"),
				(scene_prop_get_slot, ":other_forwards", ":other_hull_instance_id", slot_scene_prop_position),
				(assign, ":continue", 1),
				(try_begin), # only check if the other ship is moving or it is later in the list (hasn't been moved and checked itself yet)
					(eq, ":other_forwards", 0),
				(else_try),
					(gt, ":ship_array_slot", "$g_loop_ship_to_check"),
				(else_try),
					(assign, ":continue", 0),
				(try_end),
				(eq, ":continue", 1),
				(scene_prop_get_slot, ":other_cd_scene_prop_id", ":other_hull_instance_id", slot_scene_prop_collision_kind),
				(scene_prop_get_instance, ":other_cd_instance_id", ":other_cd_scene_prop_id", 1), # use primitive collision detecting meshes
				(prop_instance_get_position, pos2, ":other_hull_instance_id"),
				(prop_instance_set_position, ":other_cd_instance_id", pos2, 1),
				(try_begin),
					(prop_instance_intersects_with_prop_instance, ":cd_instance_id", ":other_cd_instance_id"),
					(copy_position, pos2, pos1),
					(scene_prop_get_slot, ":speed_limit", ":hull_instance_id", slot_scene_prop_speed_limit),
					(store_mul, ":max_distance", ":speed_limit", ship_forwards_multiplier),
					(try_begin),
						(le, ":forwards", -1),
						(val_mul, ":max_distance", -1),
					(try_end),
					(position_move_x, pos2, ":max_distance"),
					(prop_instance_set_position, ":cd_instance_id", pos2, 1),
					(prop_instance_intersects_with_prop_instance, ":cd_instance_id", ":other_cd_instance_id"),
					(assign, ":crashed", 1),
					(assign, ":ship_array_end", -1),
				(try_end),
				(prop_instance_set_position, ":other_cd_instance_id", pos4, 1),
			(try_end),
			(try_begin),
				(eq, ":crashed", 0),
				(troop_get_slot, ":collision_props_count", "trp_ship_array", slot_ship_array_collision_props_count),
				(store_add, ":collision_props_end", slot_ship_array_collision_props_begin, ":collision_props_count"),
				(try_for_range, ":collision_prop_slot", slot_ship_array_collision_props_begin, ":collision_props_end"), # check collision with the list of static props near water
					(troop_get_slot, ":collision_instance_id", "trp_ship_array", ":collision_prop_slot"),
					(prop_instance_intersects_with_prop_instance, ":cd_instance_id", ":collision_instance_id"),
					(copy_position, pos2, pos1),
					(scene_prop_get_slot, ":speed_limit", ":hull_instance_id", slot_scene_prop_speed_limit),
					(store_mul, ":max_distance", ":speed_limit", ship_forwards_multiplier),
					(try_begin),
						(le, ":forwards", -1),
						(val_mul, ":max_distance", -1),
					(try_end),
					(position_move_x, pos2, ":max_distance"),
					(prop_instance_set_position, ":cd_instance_id", pos2, 1),
					(prop_instance_intersects_with_prop_instance, ":cd_instance_id", ":collision_instance_id"),
					(assign, ":crashed", 1),
					(assign, ":collision_props_end", -1),
				(try_end),
			(try_end),
			(prop_instance_set_position, ":cd_instance_id", pos4, 1),
			(scene_prop_get_slot, ":ship_length", ":hull_instance_id", slot_scene_prop_length),
			(init_position, pos4),
			(try_begin),
				(gt, ":forwards", 0),
				(position_move_x, pos4, ":ship_length"),
			(else_try),
				(val_mul, ":ship_length", -1),
				(position_move_x, pos4, ":ship_length"),
			(try_end),
			(position_transform_position_to_parent, pos5, pos1, pos4),
			(try_begin), # check collision with the terrain
				(eq, ":crashed", 0),
				(copy_position, pos6, pos5),
				(position_get_distance_to_terrain, ":ground_clearance", pos6),
				(scene_prop_get_slot, ":hull_clearance", ":hull_instance_id", slot_scene_prop_height),
				(gt, ":ground_clearance", ":hull_clearance"),
			(else_try),
				(assign, ":crashed", 1),
				(gt, ":forwards", 1), # don't apply any terrain collision damage at the slowest speed
				(copy_position, pos3, pos1),
				(copy_position, pos1, pos5),
				(store_sub, ":damage", ":forwards", 1),
				(val_mul, ":damage", ":damage"),
				(val_mul, ":damage", 100),
				(try_begin),
					(call_script, "script_cf_damage_ship", ":hull_instance_id", ":damage", 0, 1),
					(eq, ":ship_array_end", -1),
					(call_script, "script_cf_damage_ship", ":other_hull_instance_id", ":damage", 0, 1),
				(try_end),
				(copy_position, pos1, pos3),
			(try_end),
			(try_begin),
				(eq, ":crashed", 0), # stop without damage at the scene boundaries
				(get_scene_boundaries, pos7, pos8),
				(position_get_x, ":hull_end_x", pos5),
				(position_get_x, ":scene_min_x", pos7),
				(gt, ":hull_end_x", ":scene_min_x"),
				(position_get_y, ":hull_end_y", pos5),
				(position_get_y, ":scene_min_y", pos7),
				(gt, ":hull_end_y", ":scene_min_y"),
				(position_get_x, ":scene_max_x", pos8),
				(lt, ":hull_end_x", ":scene_max_x"),
				(position_get_y, ":scene_max_y", pos8),
				(lt, ":hull_end_y", ":scene_max_y"),
			(else_try),
				(assign, ":crashed", 1),
			(try_end),
			(try_begin),
				(eq, ":crashed", 1),
				(assign, ":target_forwards", 0),
				(assign, ":forwards", 0),
				(scene_prop_set_slot, ":hull_instance_id", slot_scene_prop_position, 0),
				(scene_prop_set_slot, ":hull_instance_id", slot_scene_prop_target_position, 0),
				(copy_position, pos3, pos1),
			(else_try),
				(init_position, pos2),
				(store_mul, ":distance", ":forwards", ship_forwards_multiplier),
				(position_move_x, pos2, ":distance"),
				(scene_prop_get_slot, ":rotation", ":hull_instance_id", slot_scene_prop_target_rotation),
				(try_begin),
					(neq, ":rotation", 0),
					(scene_prop_get_slot, ":agent_id", ":hull_instance_id", slot_scene_prop_controlling_agent),
					(call_script, "script_agent_get_ship_station", ":agent_id", ":hull_instance_id"),
					(try_begin), # only keep the rudder setting while the steering agent stays there
						(neq, reg0, ship_station_rudder),
						(scene_prop_set_slot, ":hull_instance_id", slot_scene_prop_target_rotation, 0),
					(try_end),
					(eq, reg0, ship_station_rudder),
					(assign, ":forwards_multiplier", ":forwards"),
					(val_abs, ":forwards_multiplier"),
					(store_mul, ":move_sideways", ":rotation", ":forwards_multiplier"),
					(position_move_y, pos2, ":move_sideways"),
					(store_mul, ":fore_side_ratio", ":move_sideways", ship_rotation_multiplier),
					(convert_to_fixed_point, ":fore_side_ratio"),
					(val_div, ":fore_side_ratio", ":distance"),
					(val_abs, ":fore_side_ratio"),
					(store_atan, ":rotate_angle", ":fore_side_ratio"),
					(convert_from_fixed_point, ":rotate_angle"),
					(try_begin), # the rotation was converted to positive for the trigonometry calculations, convert it back if necessary
						(this_or_next|is_between, 0, ":rotation", ":forwards"),
						(is_between, 0, ":forwards", ":rotation"),
						(val_mul, ":rotate_angle", -1),
					(try_end),
					(position_rotate_z, pos2, ":rotate_angle"),
				(try_end),
				(position_transform_position_to_parent, pos3, pos1, pos2),
				(prop_instance_animate_to_position, ":hull_instance_id", pos3, 100),
				(scene_prop_get_slot, ":hold_instance_id", ":hull_instance_id", slot_scene_prop_linked_hold),
				(try_begin),
					(neq, ":hold_instance_id", -1),
					(prop_instance_animate_to_position, ":hold_instance_id", pos3, 100),
				(try_end),
			(try_end),
			(try_begin),
				(gt, ":target_forwards", 0),
				(scene_prop_get_slot, ":active_sail_instance_id", ":hull_instance_id", slot_scene_prop_linked_sail),
				(scene_prop_get_slot, ":inactive_sail_instance_id", ":hull_instance_id", slot_scene_prop_linked_sail_off),
			(else_try),
				(scene_prop_get_slot, ":active_sail_instance_id", ":hull_instance_id", slot_scene_prop_linked_sail_off),
				(scene_prop_get_slot, ":inactive_sail_instance_id", ":hull_instance_id", slot_scene_prop_linked_sail),
			(try_end),
			(try_begin),
				(neq, ":active_sail_instance_id", -1),
				(prop_instance_set_position, ":active_sail_instance_id", pos1),
				(eq, ":crashed", 0),
				(prop_instance_enable_physics, ":active_sail_instance_id", 1),
				(prop_instance_animate_to_position, ":active_sail_instance_id", pos3, 100),
			(try_end),
			(try_begin),
				(neq, ":inactive_sail_instance_id", -1),
				(neg|scene_prop_slot_eq, ":hull_instance_id", slot_scene_prop_state, scene_prop_state_destroyed),
				(init_position, pos4),
				(position_set_z, pos4, z_position_to_hide_object),
				(prop_instance_stop_animating, ":inactive_sail_instance_id"),
				(prop_instance_set_position, ":inactive_sail_instance_id", pos4),
				(prop_instance_enable_physics, ":inactive_sail_instance_id", 0),
			(try_end),
		(try_end),
		(try_begin), # animate the ramp if necessary, even if the ship is not moving
			(neq, ":ramp_instance_id", -1),
			(scene_prop_get_slot, ":ramp_target", ":ramp_instance_id", slot_scene_prop_target_position),
			(assign, ":continue", 1),
			(try_begin),
				(neq, ":forwards", 0),
				(assign, ":match_ground", 0),
			(else_try),
				(scene_prop_get_slot, ":ramp_position", ":ramp_instance_id", slot_scene_prop_position),
				(neq, ":ramp_position", ":ramp_target"),
				(prop_instance_get_position, pos3, ":hull_instance_id"),
				(assign, ":match_ground", 1),
			(else_try),
				(assign, ":continue", 0),
			(try_end),
			(eq, ":continue", 1),
			(call_script, "script_ship_get_ramp_relative_position", ":ramp_target", ":match_ground"),
			(position_transform_position_to_parent, pos5, pos3, pos30),
			(prop_instance_animate_to_position, ":ramp_instance_id", pos5, 100),
			(scene_prop_set_slot, ":ramp_instance_id", slot_scene_prop_position, ":ramp_target"),
		(try_end),
		]),

	("animate_ship_parts", # server: animate the ship parts together to pos20
	 [(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":animation_time", 2),

		(set_fixed_point_multiplier, 100),
		(prop_instance_get_position, pos22, ":instance_id"),
		(prop_instance_animate_to_position, ":instance_id", pos20, ":animation_time"),
		(copy_position, pos21, pos20),
		(position_set_z, pos21, z_position_to_hide_object),
		(scene_prop_get_slot, ":sail_instance_id", ":instance_id", slot_scene_prop_linked_sail),
		(try_begin),
			(neq, ":sail_instance_id", -1),
			(prop_instance_enable_physics, ":sail_instance_id", 0),
			(prop_instance_stop_animating, ":sail_instance_id"),
			(prop_instance_animate_to_position, ":sail_instance_id", pos21, ":animation_time"),
		(try_end),
		(scene_prop_get_slot, ":sail_off_instance_id", ":instance_id", slot_scene_prop_linked_sail_off),
		(try_begin),
			(neq, ":sail_off_instance_id", -1),
			(prop_instance_stop_animating, ":sail_off_instance_id"),
			(prop_instance_set_position, ":sail_off_instance_id", pos22),
			(prop_instance_enable_physics, ":sail_off_instance_id", 1),
			(prop_instance_animate_to_position, ":sail_off_instance_id", pos20, ":animation_time"),
		(try_end),
		(scene_prop_get_slot, ":ramp_instance_id", ":instance_id", slot_scene_prop_linked_ramp),
		(try_begin),
			(neq, ":ramp_instance_id", -1),
			(prop_instance_animate_to_position, ":ramp_instance_id", pos20, ":animation_time"),
		(try_end),
		(scene_prop_get_slot, ":hold_instance_id", ":instance_id", slot_scene_prop_linked_hold),
		(try_begin),
			(neq, ":hold_instance_id", -1),
			(prop_instance_animate_to_position, ":hold_instance_id", pos20, ":animation_time"),
		(try_end),
		]),

	("cf_damage_ship", # server: apply damage or repairs to the ship, whether from an agent or from crashing
	 [(multiplayer_is_server),
		(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":hit_damage", 2),
		(store_script_param, ":full_hit_points", 3),
		(store_script_param, ":script_damage", 4), # 0 = called from ti_on_scene_prop_hit, 1 = apply the damage manually

		(try_begin),
			(eq, ":script_damage", 1),
			(assign, ":agent_id", -1),
		(else_try),
			(set_fixed_point_multiplier, 1),
			(position_get_x, ":agent_id", pos2), # expects agent id in pos2.x from ti_on_scene_prop_hit
		(try_end),
		(set_fixed_point_multiplier, 100),
		(call_script, "script_cf_hit_repairable_scene_prop", ":instance_id", ":hit_damage", ":full_hit_points", item_class_wood, ":agent_id", 1, ":script_damage"),
		(assign, ":result", reg0),
		(assign, ":hit_points", reg1),
		(try_begin),
			(eq, ":result", repairable_hit),
			(try_begin),
				(eq, ":script_damage", 1),
				(particle_system_burst, "psys_dummy_smoke_big", pos1, 2),
				(particle_system_burst, "psys_dummy_straw_big", pos1, 2),
				(copy_position, pos0, pos1),
				(call_script, "script_play_sound_at_position", "snd_damage_ship"),
			(else_try),
				(particle_system_burst, "psys_dummy_straw", pos1, 10),
				(call_script, "script_hit_scene_prop_play_sound", ":agent_id", ":instance_id", "snd_cut_wood"),
			(try_end),
		(else_try),
			(eq, ":result", repairable_destroyed),
			(prop_instance_get_position, pos20, ":instance_id"),
			(position_get_distance_to_ground_level, ":sinking_time", pos20),
			(position_set_z_to_ground_level, pos20),
			(position_rotate_x, pos20, 40),
			(val_mul, ":sinking_time", 2),
			(call_script, "script_animate_ship_parts", ":instance_id", ":sinking_time"),
			(store_mission_timer_a, ":time"),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_destroyed),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_state_time, ":time"),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_position, 0),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_target_position, 0),
			(call_script, "script_scene_prop_play_sound", ":instance_id", "snd_cut_wood_break"),
		(else_try),
			(eq, ":result", repairable_repairing),
			(agent_play_sound, ":agent_id", "snd_repair_wood"),
			(try_begin),
				(scene_prop_slot_eq, ":instance_id", slot_scene_prop_state, scene_prop_state_destroyed),
				(gt, ":hit_points", 1000), # raise a sunken ship when repaired to over 1000 hit points, to then be used or further repaired
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_state, scene_prop_state_regenerating),
				(prop_instance_get_position, pos20, ":instance_id"),
				(prop_instance_get_starting_position, pos21, ":instance_id"),
				(position_get_z, ":sunk_z", pos20),
				(position_get_z, ":floating_z", pos21),
				(position_set_z, pos20, ":floating_z"),
				(position_get_rotation_around_z, ":z_angle", pos20),
				(init_position, pos22),
				(position_copy_rotation, pos20, pos22),
				(position_rotate_z, pos20, ":z_angle"),
				(store_sub, ":ground_distance", ":floating_z", ":sunk_z"),
				(call_script, "script_animate_ship_parts", ":instance_id", ":ground_distance"),
			(try_end),
		(try_end),
		]),

	("setup_ship_collision_props", # server, edit mode: at mission start, store in an array all scene props near water that seem possible to collide ships into
	 [
		(set_fixed_point_multiplier, 100),
		(assign, ":current_index", slot_ship_array_collision_props_begin),
		(assign, ":count", 0),
		(try_for_range, ":instance_id", 0, max_scene_prop_instance_id),
			(prop_instance_is_valid, ":instance_id"),
			(prop_instance_get_position, pos1, ":instance_id"),
			(position_get_z, ":prop_height", pos1),
			(le, ":prop_height", 500),
			(position_set_z, pos1, 0),
			(position_get_distance_to_terrain, ":terrain_distance", pos1),
			(gt, ":terrain_distance", -500),
			(this_or_next|gt, ":terrain_distance", 0),
			(le, ":prop_height", 0),
			(scene_prop_slot_eq, ":instance_id", slot_scene_prop_collision_kind, 0),
			(troop_set_slot, "trp_ship_array", ":current_index", ":instance_id"),
			(val_add, ":current_index", 1),
		(try_end),
		(store_sub, ":count", ":current_index", slot_ship_array_collision_props_begin),
		(troop_set_slot, "trp_ship_array", slot_ship_array_collision_props_count, ":count"),
		]),

	("setup_ferry", # server: at mission start, calculate angle, positions, and movement distances for the ferry boat
	 [(store_script_param, ":instance_id", 1), # must be valid
		(store_script_param, ":winch_scene_prop_id", 2),

		(scene_prop_get_slot, ":platform_1_instance_id", ":instance_id", slot_scene_prop_linked_platform_1),
		(scene_prop_get_slot, ":platform_2_instance_id", ":instance_id", slot_scene_prop_linked_platform_2),
		(try_begin),
			(gt, ":platform_1_instance_id", 0),
			(gt, ":platform_2_instance_id", 0),
			(set_fixed_point_multiplier, 100),
			(prop_instance_get_position, pos1, ":platform_1_instance_id"),
			(prop_instance_get_position, pos2, ":platform_2_instance_id"),
			(position_set_z, pos1, 0),
			(position_set_z, pos2, 0),
			(scene_prop_get_slot, ":length", ":instance_id", slot_scene_prop_length),
			(get_distance_between_positions, ":max_distance", pos1, pos2),
			(val_sub, ":max_distance", ":length"),
			(val_sub, ":max_distance", ":length"),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_max_distance, ":max_distance"),
			(scene_prop_get_slot, ":move_distance", ":instance_id", slot_scene_prop_speed_limit),
			(store_div, ":max_position", ":max_distance", ":move_distance"),
			(store_mod, ":remainder", ":max_distance", ":move_distance"),
			(try_begin),
				(gt, ":remainder", 20),
				(val_add, ":max_position", 1),
			(try_end),
			(val_add, ":max_position", 1),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_max_position, ":max_position"),
			(set_fixed_point_multiplier, 1000000), # line up the ferry boat pointing exactly between platforms
			(position_transform_position_to_local, pos3, pos1, pos2),
			(position_get_x, ":relative_x", pos3),
			(position_get_y, ":relative_y", pos3),
			(store_atan2, ":angle", ":relative_x", ":relative_y"),
			(val_mul, ":angle", -1),
			(position_rotate_x_floating, pos1, 90 * 1000000), # hack to emulate missing position_rotate_z_floating operation
			(position_rotate_y_floating, pos1, ":angle"),
			(position_rotate_x_floating, pos1, -90 * 1000000),
			(set_fixed_point_multiplier, 100),
			(position_move_y, pos1, ":length"),
			(prop_instance_set_position, ":instance_id", pos1),
			(scene_prop_get_slot, ":winch_height", ":instance_id", slot_scene_prop_height),
			(position_move_z, pos1, ":winch_height"),
			(set_spawn_position, pos1),
			(spawn_scene_prop, ":winch_scene_prop_id"),
			(scene_prop_set_slot, reg0, slot_scene_prop_linked_scene_prop, ":instance_id"),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_linked_ferry_winch, reg0),
			(scene_prop_set_slot, ":instance_id", slot_scene_prop_controlling_agent, -1),
		(try_end),
		]),

	("cf_use_ferry_winch", # server: handle players controlling a ferry boat
	 [(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":winch_instance_id", 2), # must be valid
		(store_script_param, ":is_platform", 3), # 0 = winch with full control, 1 = platform only allowing pulling the boat towards it

		(agent_get_player_id, ":player_id", ":agent_id"),
		(player_is_active, ":player_id"),
		(agent_is_alive, ":agent_id"),
		(scene_prop_get_slot, ":ferry_instance_id", ":winch_instance_id", slot_scene_prop_linked_scene_prop),
		(gt, ":ferry_instance_id", 0),
		(set_fixed_point_multiplier, 100),
		(assign, ":direction", 0),
		(try_begin),
			(eq, ":is_platform", 0),
			(prop_instance_get_position, pos1, ":ferry_instance_id"),
			(agent_get_position, pos2, ":agent_id"),
			(position_transform_position_to_local, pos3, pos1, pos2),
			(position_get_y, ":relative_y_position", pos3),
			(try_begin),
				(ge, ":relative_y_position", 0),
				(assign, ":direction", -1),
			(else_try),
				(assign, ":direction", 1),
			(try_end),
			(scene_prop_set_slot, ":ferry_instance_id", slot_scene_prop_controlling_agent, ":agent_id"),
		(else_try),
			(assign, ":platform_instance_id", ":winch_instance_id"),
			(scene_prop_get_slot, ":winch_instance_id", ":ferry_instance_id", slot_scene_prop_linked_ferry_winch),
			(scene_prop_get_slot, ":controlling_agent_id", ":ferry_instance_id", slot_scene_prop_controlling_agent),
			(try_begin), # don't allow pulling from the platforms if the previously controlling agent is still on board
				(neq, ":controlling_agent_id", ":agent_id"),
				(agent_is_active, ":controlling_agent_id"),
				(agent_is_alive, ":controlling_agent_id"),
				(scene_prop_has_agent_on_it, ":ferry_instance_id", ":controlling_agent_id"),
				(multiplayer_send_int_to_player, ":player_id", server_event_play_sound, "snd_failure"),
				(assign, ":is_platform", -1),
			(else_try),
				(scene_prop_set_slot, ":ferry_instance_id", slot_scene_prop_controlling_agent, -1),
			(try_end),
			(neq, ":is_platform", -1),
			(scene_prop_get_slot, ":platform_1_instance_id", ":ferry_instance_id", slot_scene_prop_linked_platform_1),
			(try_begin),
				(eq, ":platform_instance_id", ":platform_1_instance_id"),
				(assign, ":direction", -1),
			(else_try),
				(scene_prop_get_slot, ":platform_2_instance_id", ":ferry_instance_id", slot_scene_prop_linked_platform_2),
				(eq, ":platform_instance_id", ":platform_2_instance_id"),
				(assign, ":direction", 1),
			(try_end),
		(try_end),
		(neq, ":direction", 0),
		(scene_prop_get_slot, ":current_target", ":ferry_instance_id", slot_scene_prop_target_position),
		(scene_prop_get_slot, ":max_position", ":ferry_instance_id", slot_scene_prop_max_position),
		(val_add, ":current_target", ":direction"),
		(is_between, ":current_target", 0, ":max_position"),
		(store_sub, ":last_position", ":max_position"),
		(scene_prop_get_slot, ":move_distance", ":ferry_instance_id", slot_scene_prop_speed_limit),
		(scene_prop_get_slot, ":max_distance", ":ferry_instance_id", slot_scene_prop_max_distance),
		(try_begin),
			(eq, ":current_target", ":last_position"),
			(assign, ":total_distance", ":max_distance"),
		(else_try), # calculate the total distance from the start to avoid accumulating errors
			(store_mul, ":total_distance", ":current_target", ":move_distance"),
			(val_clamp, ":total_distance", 0, ":max_distance"),
		(try_end),
		(prop_instance_get_starting_position, pos1, ":winch_instance_id"),
		(position_set_z, pos1, 0),
		(position_move_y, pos1, ":total_distance"),
		(prop_instance_stop_animating, ":ferry_instance_id"),
		(prop_instance_get_position, pos5, ":ferry_instance_id"),
		(prop_instance_set_position, ":ferry_instance_id", pos1, 1),
		(assign, ":crashed", 0),
		(init_position, pos4),
		(position_set_z, pos4, z_position_to_hide_object),
		(troop_get_slot, ":ship_array_end", "trp_ship_array", 0),
		(val_add, ":ship_array_end", slot_ship_array_begin),
		(try_for_range, ":ship_array_slot", slot_ship_array_begin, ":ship_array_end"), # check for collision with all ships
			(troop_get_slot, ":other_hull_instance_id", "trp_ship_array", ":ship_array_slot"),
			(scene_prop_get_slot, ":other_cd_scene_prop_id", ":other_hull_instance_id", slot_scene_prop_collision_kind),
			(scene_prop_get_instance, ":other_cd_instance_id", ":other_cd_scene_prop_id", 1),
			(prop_instance_get_position, pos2, ":other_hull_instance_id"),
			(prop_instance_set_position, ":other_cd_instance_id", pos2, 1),
			(try_begin),
				(prop_instance_intersects_with_prop_instance, ":ferry_instance_id", ":other_cd_instance_id"),
				(assign, ":crashed", 1),
				(assign, ":ship_array_end", -1),
				(call_script, "script_scene_prop_play_sound", ":ferry_instance_id", "snd_cut_wood_break"),
			(try_end),
			(prop_instance_set_position, ":other_cd_instance_id", pos4, 1),
		(try_end),
		(prop_instance_set_position, ":ferry_instance_id", pos5, 1),
		(eq, ":crashed", 0),
		(scene_prop_set_slot, ":ferry_instance_id", slot_scene_prop_target_position, ":current_target"),
		(prop_instance_animate_to_position, ":ferry_instance_id", pos1, 200),
		(scene_prop_get_slot, ":winch_height", ":ferry_instance_id", slot_scene_prop_height),
		(position_move_z, pos1, ":winch_height"),
		(try_begin),
			(gt, ":direction", 0),
			(assign, ":winch_rotation", -72000),
		(else_try),
			(assign, ":winch_rotation", 72000),
		(try_end),
		(prop_instance_stop_animating, ":winch_instance_id"),
		(prop_instance_rotate_to_position, ":winch_instance_id", pos1, 200, ":winch_rotation"),
		]),

	("cf_turn_windmill_fans", # clients: make windmill fans rotate, only visually
	 [(store_script_param_1, ":fan_no"),

		(scene_prop_get_instance, ":instance_id", "spr_windmill_fan_turning", ":fan_no"),
		(prop_instance_get_position, pos1, ":instance_id"),
		(position_rotate_y, pos1, 45),
		(prop_instance_animate_to_position, ":instance_id", pos1, 450),
		(val_add, ":fan_no", 1),
		(call_script, "script_cf_turn_windmill_fans", ":fan_no"),
		]),

	("scene_set_day_time", # clients: at mission start, set the time of day, skybox, and haze from scene prop values
	 [
		###GGG:daytime
		#(try_begin),
		#  (scene_prop_get_instance, ":instance_id", "spr_pw_scene_day_time", 0),
		#  (prop_instance_get_variation_id, ":day_time", ":instance_id"),
		#  (val_min, ":day_time", 23),
		#(else_try),
		#  (assign, ":day_time", 12),
		#(try_end),
		(try_begin),
			(eq, "$hours", 0),
			(assign, ":day_time", 12),
		(else_try),
			(gt, "$hours", 0),
			(val_sub, "$hours", 1),
			(assign, ":day_time", "$hours"),
		(try_end),
		(scene_set_day_time, ":day_time"),
		###

		(try_begin),
			(scene_prop_get_instance, ":instance_id", "spr_pw_scene_cloud_haze", 0),
			(prop_instance_get_variation_id, ":cloud", ":instance_id"),
			(val_min, ":cloud", 100),
			(set_global_cloud_amount, ":cloud"),
			(prop_instance_get_variation_id_2, ":haze", ":instance_id"),
			(val_min, ":haze", 100),
			(set_global_haze_amount, ":haze"),
		(try_end),
		]),

	("scene_adjust_weather_situation", # server: periodically adjust the position and intensity of weather systems in the scene
	 [
		(set_fixed_point_multiplier, 100),
		(store_random_in_range, ":squall", "$g_weather_volatility", 100),
		(try_begin), # adjust wind direction and strength, if it exists in the scene
			(scene_prop_get_instance, ":wind_instance_id", "spr_pw_scene_wind_direction", 0),
			(prop_instance_get_position, pos1, ":wind_instance_id"),
			(position_get_z, ":wind_strength", pos1),
			(store_random_in_range, ":strength_change", -2000, 2000),
			(store_random_in_range, ":angle_change", -30, 30),
			(store_random_in_range, ":change_duration", loop_weather_adjust_interval * 200, loop_weather_adjust_interval * 800),
			(try_begin),
				(ge, ":squall", 90),
				(val_mul, ":strength_change", 3),
				(val_mul, ":angle_change", 3),
				(val_div, ":change_duration", 3),
			(try_end),
			(store_add, ":next_wind_strength", ":strength_change"),
			(prop_instance_get_variation_id, ":min_wind_strength", ":wind_instance_id"),
			(val_mul, ":min_wind_strength", 100),
			(val_max, ":next_wind_strength", ":min_wind_strength"),
			(prop_instance_get_variation_id_2, ":max_wind_strength", ":wind_instance_id"),
			(val_mul, ":max_wind_strength", 100),
			(val_min, ":next_wind_strength", ":max_wind_strength"),
			(copy_position, pos2, pos1),
			(position_rotate_z, pos2, ":angle_change"),
			(position_set_z, pos2, ":next_wind_strength"),
			(prop_instance_stop_animating, ":wind_instance_id"),
			(prop_instance_animate_to_position, ":wind_instance_id", pos2, ":change_duration"),
		(else_try),
			(assign, ":wind_strength", 0),
			(init_position, pos1),
		(try_end),
		(get_scene_boundaries, pos8, pos9),
		(position_get_x, ":scene_min_x", pos8),
		(position_get_x, ":scene_max_x", pos9),
		(position_get_y, ":scene_min_y", pos8),
		(position_get_y, ":scene_max_y", pos9),
		(scene_prop_get_num_instances, ":num_instances", "spr_pw_scene_precipitation"),
		(try_for_range, ":instance_no", 0, ":num_instances"),
			(scene_prop_get_instance, ":precipitation_instance_id", "spr_pw_scene_precipitation", ":instance_no"),
			(prop_instance_get_position, pos2, ":precipitation_instance_id"),
			(try_begin), # move precipitation with the current wind
				(gt, ":wind_strength", 0),
				(position_copy_rotation, pos2, pos1),
				(position_get_x, ":current_x", pos2),
				(position_get_y, ":current_y", pos2),
				(try_begin), # check for precipitation areas moving off the scene edge
					(is_between, ":current_x", ":scene_min_x", ":scene_max_x"),
					(is_between, ":current_y", ":scene_min_y", ":scene_max_y"),
					(position_move_y, pos2, ":wind_strength"),
					(position_get_x, ":target_x", pos2),
					(position_get_y, ":target_y", pos2),
					(try_begin), # when targeting to move off the edge, stop at the edge and fade out
						(lt, ":target_x", ":scene_min_x"),
						(store_sub, ":target_x", ":scene_min_x", 2),
						(position_set_z, pos2, 0),
					(else_try),
						(ge, ":target_x", ":scene_max_x"),
						(store_add, ":target_x", ":scene_max_x", 2),
						(position_set_z, pos2, 0),
					(try_end),
					(try_begin),
						(lt, ":target_y", ":scene_min_y"),
						(store_sub, ":target_y", ":scene_min_y", 2),
						(position_set_z, pos2, 0),
					(else_try),
						(ge, ":target_y", ":scene_max_y"),
						(store_add, ":target_y", ":scene_max_y", 2),
						(position_set_z, pos2, 0),
					(try_end),
					(position_set_x, pos2, ":target_x"),
					(position_set_y, pos2, ":target_y"),
				(else_try), # when already at the edge, wrap around to the opposite side and fade in
					(position_set_z, pos2, 0),
					(try_begin),
						(lt, ":current_x", ":scene_min_x"),
						(val_sub, ":scene_max_x", 1), # bring inside scene for next check
						(position_set_x, pos2, ":scene_max_x"),
					(else_try),
						(ge, ":current_x", ":scene_max_x"),
						(position_set_x, pos2, ":scene_min_x"),
					(try_end),
					(try_begin),
						(lt, ":current_y", ":scene_min_y"),
						(val_sub, ":scene_max_y", 1), # bring inside scene for next check
						(position_set_y, pos2, ":scene_max_y"),
					(else_try),
						(ge, ":current_y", ":scene_max_y"),
						(position_set_y, pos2, ":scene_min_y"),
					(try_end),
					(prop_instance_stop_animating, ":precipitation_instance_id"),
					(prop_instance_set_position, ":precipitation_instance_id", pos2),
				(try_end),
			(try_end),
			(position_get_z, ":precipitation_intensity", pos2),
			(prop_instance_get_variation_id, ":min_precipitation_intensity", ":precipitation_instance_id"),
			(val_mul, ":min_precipitation_intensity", 100),
			(prop_instance_get_variation_id_2, ":max_precipitation_intensity", ":precipitation_instance_id"),
			(val_mul, ":max_precipitation_intensity", 100),
			(scene_prop_get_slot, ":intensity_acceleration", ":precipitation_instance_id", slot_scene_prop_target_rotation),
			(try_begin), # if the weather is controlled by an administrator, force it to be fine or precipitating
				(eq, "$g_force_weather", 0),
				(assign, ":precipitation_intensity", 0),
			(else_try),
				(eq, "$g_force_weather", 1),
				(assign, ":precipitation_intensity", 10000),
			(else_try), # or if dynamic, change the acceleration of the precipitation intensity so it doesn't just fluctuate over a small range
				(try_begin),
					(this_or_next|ge, ":precipitation_intensity", ":max_precipitation_intensity"),
					(gt, ":intensity_acceleration", 1000),
					(store_random_in_range, ":intensity_acceleration_change", -200, 0),
				(else_try),
					(this_or_next|le, ":precipitation_intensity", ":min_precipitation_intensity"),
					(lt, ":intensity_acceleration", -1500),
					(store_random_in_range, ":intensity_acceleration_change", 0, 201),
				(else_try),
					(store_random_in_range, ":intensity_acceleration_change", -200, 201),
				(try_end),
				(try_begin),
					(gt, ":squall", 90),
					(val_mul, ":intensity_acceleration_change", 3),
				(try_end),
				(val_add, ":intensity_acceleration", ":intensity_acceleration_change"),
				(scene_prop_set_slot, ":precipitation_instance_id", slot_scene_prop_target_rotation, ":intensity_acceleration"),
				(val_add, ":precipitation_intensity", ":intensity_acceleration"),
				(val_max, ":precipitation_intensity", ":min_precipitation_intensity"),
				(val_min, ":precipitation_intensity", ":max_precipitation_intensity"),
			(try_end),
			(position_set_z, pos2, ":precipitation_intensity"),
			(prop_instance_stop_animating, ":precipitation_instance_id"),
			(prop_instance_animate_to_position, ":precipitation_instance_id", pos2, loop_weather_adjust_interval * 100),
		(try_end),
		]),

	("cf_adjust_weather_effects", # clients: recalculate the weather effects that should be currently happening, based on view position
	 [
		(set_fixed_point_multiplier, 100),
		(assign, "$g_current_precipitation_intensity", 0),
		(mission_cam_get_position, pos1),
		(position_get_distance_to_terrain, ":terrain_distance", pos1),
		(gt, ":terrain_distance", -100), # if underground, don't display precipitation
		(scene_prop_get_num_instances, ":num_instances", "spr_pw_scene_precipitation"),
		(try_for_range, ":instance_no", 0, ":num_instances"), # calculate overall intensity from all nearby precipitation systems
			(scene_prop_get_instance, ":instance_id", "spr_pw_scene_precipitation", ":instance_no"),
			(prop_instance_get_position, pos2, ":instance_id"),
			(position_get_z, ":intensity", pos2),
			(gt, ":intensity", 0),
			(position_get_z, ":view_height", pos1),
			(position_set_z, pos2, ":view_height"),
			(get_distance_between_positions, ":distance", pos1, pos2),
			(prop_instance_get_scale, pos3, ":instance_id"),
			(position_get_scale_x, ":precipitation_width", pos3),
			(val_mul, ":precipitation_width", 100),
			(lt, ":distance", ":precipitation_width"),
			(store_sub, ":intensity_reduction", ":precipitation_width", ":distance"),
			(val_mul, ":intensity_reduction", 200),
			(val_div, ":intensity_reduction", ":precipitation_width"),
			(try_begin),
				(lt, ":intensity_reduction", 100),
				(val_mul, ":intensity", ":intensity_reduction"),
				(val_div, ":intensity", 100),
			(try_end),
			(val_div, ":intensity", 100),
			(val_max, "$g_current_precipitation_intensity", ":intensity"),
		(try_end),
		(try_begin), # change from rain to snow when above the set level
			(scene_prop_get_instance, ":snow_level_instance_id", "spr_pw_scene_snow_level", 0),
			(prop_instance_get_position, pos2, ":snow_level_instance_id"),
			(position_get_z, ":camera_height", pos1),
			(position_get_z, ":snow_level_height", pos2),
			(ge, ":camera_height", ":snow_level_height"),
			(assign, "$g_current_precipitation_particles", "psys_dynamic_snow"),
		(else_try),
			(assign, "$g_current_precipitation_particles", "psys_dynamic_rain"),
		(try_end),
		(try_begin), # play rain sound if heavy enough (volume flags do not seem to work in the play_sound operation)
			(eq, "$g_current_precipitation_particles", "psys_dynamic_rain"),
			(ge, "$g_current_precipitation_intensity", 50),
			(try_begin),
				(eq, "$g_rain_sound_channel", -1),
				(play_sound, "snd_rain"),
				(store_last_sound_channel, "$g_rain_sound_channel"),
			(try_end),
		(else_try), # otherwise stop rain sound
			(this_or_next|lt, "$g_current_precipitation_intensity", 50),
			(eq, "$g_current_precipitation_particles", "psys_dynamic_snow"),
			(neq, "$g_rain_sound_channel", -1),
			(stop_sound_channel, "$g_rain_sound_channel"),
			(assign, "$g_rain_sound_channel", -1),
		(try_end),
		(try_begin), # get scene fog color and distance
			(scene_prop_get_instance, ":fog_instance_id", "spr_pw_scene_fog", 0),
			(set_fixed_point_multiplier, 10),
			(prop_instance_get_position, pos2, ":fog_instance_id"),
			(position_get_z, "$g_target_fog_distance", pos2),
			(val_max, "$g_target_fog_distance", 1),
			(set_fixed_point_multiplier, 0xFF * 200),
			(prop_instance_get_scale, pos3, ":fog_instance_id"),
			(position_get_scale_x, "$g_target_fog_red", pos3),
			(position_get_scale_y, "$g_target_fog_green", pos3),
			(position_get_scale_z, "$g_target_fog_blue", pos3),
		(else_try),
			(assign, "$g_target_fog_distance", 10000),
			(assign, "$g_target_fog_red", 140 * 200),
			(assign, "$g_target_fog_green", 162 * 200),
			(assign, "$g_target_fog_blue", 173 * 200),
		(try_end), # darken fog in heavy precipitation
		(set_fixed_point_multiplier, 100),
		(store_add, ":intensity_darken", "$g_current_precipitation_intensity", 200),
		(val_clamp, ":intensity_darken", 200, 301),
		(val_div, "$g_target_fog_red", ":intensity_darken"),
		(val_div, "$g_target_fog_green", ":intensity_darken"),
		(val_div, "$g_target_fog_blue", ":intensity_darken"),
		(store_sub, ":precipitation_fog_distance", 100, "$g_current_precipitation_intensity"),
		(convert_to_fixed_point, ":precipitation_fog_distance"),
		(store_pow, ":precipitation_fog_distance", ":precipitation_fog_distance", 400),
		(val_div, ":precipitation_fog_distance", 5000000),
		(val_add, ":precipitation_fog_distance", 20),
		(val_min, "$g_target_fog_distance", ":precipitation_fog_distance"),
		]),

	("cf_render_weather_effects", # clients: emit weather particle systems and set fog
	 [
		(set_fixed_point_multiplier, 100),
		(try_begin), # emit precipitation blocks which are not under cover
			(eq, "$g_disable_rain_snow_particles", 0),
			(ge, "$g_current_precipitation_intensity", 20),
			(gt, "$g_current_precipitation_particles", 0),
			(mission_cam_get_position, pos1),
			(position_get_distance_to_terrain, ":terrain_distance", pos1),
			(gt, ":terrain_distance", -100),
			(position_get_z, ":height", pos1),
			(gt, ":height", z_position_water_level - 100),
			(init_position, pos2),
			(position_copy_origin, pos2, pos1),
			(position_get_rotation_around_z, ":z_rotation", pos1),
			(position_rotate_z, pos2, ":z_rotation"),
			(position_move_x, pos2, -1600),
			(position_move_y, pos2, 2000),
			(try_for_range, reg1, -4, 5),
				(try_for_range, reg2, -4, 5),
					(copy_position, pos3, pos2),
					(position_set_z, pos3, 100000),
					(copy_position, pos4, pos2),
					(try_begin),
						(position_set_z_to_ground_level, pos4),
						(position_move_z, pos4, 100, 1),
						(position_has_line_of_sight_to_position, pos4, pos3),
						(position_get_z, ":above_ground_height", pos4),
						(position_get_z, ":view_height", pos2),
						(try_begin),
							(gt, ":above_ground_height", ":view_height"),
							(position_move_z, pos4, 1000, 1),
						(else_try),
							(val_add, ":view_height", 1000),
							(position_set_z, pos4, ":view_height"),
						(try_end),
						(particle_system_burst, "$g_current_precipitation_particles", pos4, "$g_current_precipitation_intensity"),
					(else_try),
					(try_end),
					(position_move_x, pos2, 400),
				(try_end),
				(position_move_x, pos2, -3600),
				(position_move_y, pos2, -400),
			(try_end),
		(try_end),
		(try_begin),
			(gt, "$g_target_fog_distance", 0),
			(try_begin), # reset the color immediately when fog is cleared
				(ge, "$g_current_fog_distance", 2000),
				(assign, "$g_current_fog_red", 0),
				(assign, "$g_current_fog_green", 0),
				(assign, "$g_current_fog_blue", 0),
			(try_end),
			(try_begin), # for long distances, clear the fog
				(ge, "$g_target_fog_distance", 2000),
				(ge, "$g_current_fog_distance", 2000),
				(set_fog_distance, 0, 0),
			(else_try),
				(le, "$g_current_fog_distance", 0),
				(assign, "$g_current_fog_distance", "$g_target_fog_distance"),
			(else_try), # otherwise smoothly interpolate fog color and distance
				(neq, "$g_current_fog_distance", "$g_target_fog_distance"),
				(store_sub, ":merge_amount", "$g_current_fog_distance", "$g_target_fog_distance"),
				(val_abs, ":merge_amount"),
				(val_div, ":merge_amount", 10),
				(val_clamp, ":merge_amount", 1, 51),
				(try_begin),
					(gt, "$g_current_fog_distance", "$g_target_fog_distance"),
					(val_sub, "$g_current_fog_distance", ":merge_amount"),
					(val_max, "$g_current_fog_distance", "$g_target_fog_distance"),
				(else_try),
					(lt, "$g_current_fog_distance", "$g_target_fog_distance"),
					(val_add, "$g_current_fog_distance", ":merge_amount"),
					(val_min, "$g_current_fog_distance", "$g_target_fog_distance"),
				(try_end),
			(try_end),
			(try_begin),
				(eq, "$g_current_fog_red", 0),
				(assign, "$g_current_fog_red", "$g_target_fog_red"),
			(else_try),
				(gt, "$g_current_fog_red", "$g_target_fog_red"),
				(val_sub, "$g_current_fog_red", 1),
			(else_try),
				(lt, "$g_current_fog_red", "$g_target_fog_red"),
				(val_add, "$g_current_fog_red", 1),
			(try_end),
			(try_begin),
				(eq, "$g_current_fog_green", 0),
				(assign, "$g_current_fog_green", "$g_target_fog_green"),
			(else_try),
				(gt, "$g_current_fog_green", "$g_target_fog_green"),
				(val_sub, "$g_current_fog_green", 1),
			(else_try),
				(lt, "$g_current_fog_green", "$g_target_fog_green"),
				(val_add, "$g_current_fog_green", 1),
			(try_end),
			(try_begin),
				(eq, "$g_current_fog_blue", 0),
				(assign, "$g_current_fog_blue", "$g_target_fog_blue"),
			(else_try),
				(gt, "$g_current_fog_blue", "$g_target_fog_blue"),
				(val_sub, "$g_current_fog_blue", 1),
			(else_try),
				(lt, "$g_current_fog_blue", "$g_target_fog_blue"),
				(val_add, "$g_current_fog_blue", 1),
			(try_end),
			(store_mul, ":red", "$g_current_fog_red", 0x10000),
			(store_mul, ":green", "$g_current_fog_green", 0x100),
			(store_or, ":fog_color", ":red", ":green"),
			(val_or, ":fog_color", "$g_current_fog_blue"),
			(set_fog_distance, "$g_current_fog_distance", ":fog_color"),
		(try_end),
		]),

	("cf_play_scene_ambient_sound", # clients: check if an ambient sound emitter scene prop should be played
	 [(store_script_param, ":instance_id", 1), # must be valid

		(prop_instance_get_variation_id_2, ":probability", ":instance_id"),
		(le, ":probability", 100),
		(prop_instance_get_variation_id, ":sound_id", ":instance_id"),
		(val_add, ":sound_id", ambient_sounds_begin),
		(is_between, ":sound_id", ambient_sounds_begin, ambient_sounds_end),
		(store_random_in_range, ":random", 0, 100),
		(lt, ":random", ":probability"),
		(mission_cam_get_position, pos1),
		(prop_instance_get_position, pos2, ":instance_id"),
		(get_sq_distance_between_positions, ":sq_distance", pos1, pos2),
		(lt, ":sq_distance", sq(max_distance_to_play_sound)),
		(play_sound_at_position, ":sound_id", pos2, sf_vol_15|sf_priority_7),
		]),

	("music_set_situation", # clients: check if the music type should be changed for a different situation
	 [
		(multiplayer_get_my_player, ":player_id"),
		(try_begin),
			(player_is_active, ":player_id"),
			(player_get_slot, ":faction_id", ":player_id", slot_player_faction_id),
		(else_try),
			(assign, ":faction_id", "fac_commoners"),
		(try_end),
		(assign, ":situation", mtf_sit_travel),
		(try_begin),
			(gt, "$g_recent_nearby_deaths_factor", 100),
			(assign, ":situation", mtf_sit_fight),
		(else_try),
			(mission_cam_get_position, pos1),
			(ge, ":faction_id", castle_factions_begin),
			(call_script, "script_cf_find_closest_scene_prop", "spr_pw_castle_capture_point", sq(10000)),
			(call_script, "script_scene_prop_get_owning_faction", reg0),
			(gt, reg1, -1),
			(assign, ":nearby_castle_faction_id", reg0),
			(try_begin),
				(eq, ":nearby_castle_faction_id", ":faction_id"), # nearest to one of the player faction's castles
				(assign, ":peaceful_loop_end", factions_end),
				(try_for_range, ":other_faction_id", castle_factions_begin, ":peaceful_loop_end"),
					(neq, ":other_faction_id", ":faction_id"),
					(faction_slot_eq, ":other_faction_id", slot_faction_is_active, 1),
					(call_script, "script_cf_factions_are_hostile", ":faction_id", ":other_faction_id"),
					(get_max_players, ":max_players"),
					(try_for_range, ":other_player_id", 1, ":max_players"),
						(player_is_active, ":other_player_id"),
						(player_slot_eq, ":other_player_id", slot_player_faction_id, ":other_faction_id"),
						(assign, ":max_players", -1),
					(try_end),
					(eq, ":max_players", -1),
					(assign, ":peaceful_loop_end", 0),
				(try_end),
				(try_begin),
					(eq, ":peaceful_loop_end", 0), # the player's faction is hostile to another occupied faction, not at peace
					(assign, ":situation", mtf_sit_ambushed),
				(else_try),
					(assign, ":situation", mtf_sit_tavern),
				(try_end),
			(else_try),
				(faction_slot_eq, ":nearby_castle_faction_id", slot_faction_is_active, 1),
				(call_script, "script_cf_factions_are_hostile", ":faction_id", ":nearby_castle_faction_id"),
				(get_max_players, ":max_players"),
				(try_for_range, ":other_player_id", 1, ":max_players"),
					(player_is_active, ":other_player_id"),
					(player_slot_eq, ":other_player_id", slot_player_faction_id, ":nearby_castle_faction_id"),
					(assign, ":max_players", -1),
				(try_end),
				(eq, ":max_players", -1), # nearest to a castle occupied by a hostile faction
				(assign, ":situation", mtf_sit_siege),
			(else_try),
				(assign, ":situation", mtf_sit_town),
			(try_end),
		(else_try),
			(set_fixed_point_multiplier, 100),
			(position_get_distance_to_terrain, ":terrain_distance", pos1),
			(position_get_distance_to_ground_level, ":ground_distance", pos1),
			(store_sub, ":difference", ":terrain_distance", ":ground_distance"),
			(val_abs, ":difference"),
			(gt, ":difference", 50), # mission camera is not directly above terrain, probably in a town or building
			(try_begin),
				(player_is_active, ":player_id"),
				(player_get_agent_id, ":agent_id", ":player_id"),
				(agent_is_active, ":agent_id"),
				(agent_is_alive, ":agent_id"),
				(this_or_next|agent_has_item_equipped, ":agent_id", "itm_lock_pick"),
				(agent_has_item_equipped, ":agent_id", "itm_poisoned_dagger"),
				(assign, ":situation", mtf_sit_town_infiltrate),
			(else_try),
				(call_script, "script_cf_find_closest_scene_prop", "spr_pw_process_tavern", sq(1000)),
				(assign, ":situation", mtf_sit_tavern),
			(else_try),
				(assign, ":situation", mtf_sit_town),
			(try_end),
		(try_end),
		(music_set_situation, ":situation"),
		(val_div, "$g_recent_nearby_deaths_factor", 3),
		(val_mul, "$g_recent_nearby_deaths_factor", 2),
		]),

  #GGG:bots
 ("after_mission_start_spawn_bots", # server: check if more testing bots should be spawned
  [
    (store_current_scene, ":current_scene"),
    (modify_visitors_at_site, ":current_scene"),

    #(assign, "$g_bot_count", 30),
    #(call_script, "script_check_spawn_bots", -1),
    #Arthur: No bots please
   ]),
 #

	("check_spawn_bots", # server: check if more testing bots should be spawned
	 [(store_script_param, ":dead_agent_id", 1),

		(try_begin),
			(multiplayer_is_server),
			(try_begin),
				(le, ":dead_agent_id", -1),
				(store_sub, ":bots_to_spawn", "$g_bot_count", "$g_spawned_bot_count"),
				(val_max, "$g_spawned_bot_count", "$g_bot_count"),        
			(else_try),
				(assign, ":bots_to_spawn", 0),
				(agent_is_human, ":dead_agent_id"),
				(agent_get_player_id, ":player_id", ":dead_agent_id"),
				(neg|player_is_active, ":player_id"),        
				(try_begin),
					(le, "$g_spawned_bot_count", "$g_bot_count"),
					(assign, ":bots_to_spawn", 1),
				(else_try),
					(val_sub, "$g_spawned_bot_count", 1),
				(try_end),
			(try_end),
			(ge, ":bots_to_spawn", 1),
			(store_current_scene, ":current_scene"),
			(modify_visitors_at_site, ":current_scene"),
			(try_for_range, ":unused", 0, ":bots_to_spawn"),
			###GGG:bots
				#(store_random_in_range, ":entry_point", 0, 5),
				#(store_random_in_range, ":troop_id", playable_troops_begin, "trp_godlike_hero"),
				(store_random_in_range, ":range", 0, 8),
        (try_begin),
            (eq, ":range", 0),
            (store_random_in_range, ":entry_point", 5, 10),
            (assign, ":troop_id", "trp_royal_footman"),
        (else_try),
            (eq, ":range", 1),
            (store_random_in_range, ":entry_point", 15, 20),
            (assign, ":troop_id", "trp_royal_footman"),
        (else_try),
            (eq, ":range", 2),
            (store_random_in_range, ":entry_point", 25, 30),
            (assign, ":troop_id", "trp_royal_footman"),
        (else_try),
            (eq, ":range", 3),
            (store_random_in_range, ":entry_point", 35, 40),
            (assign, ":troop_id", "trp_royal_man_at_arms"),
        (else_try),
            (eq, ":range", 4),
            (store_random_in_range, ":entry_point", 45, 50),
            (assign, ":troop_id", "trp_royal_man_at_arms"),
        (else_try),
            (eq, ":range", 5),
            (store_random_in_range, ":entry_point", 55, 60),
            (assign, ":troop_id", "trp_royal_archer"),
        (else_try),
            (eq, ":range", 6),
            (store_random_in_range, ":entry_point", 65, 70),
            (assign, ":troop_id", "trp_royal_archer"),
        (else_try),
            (eq, ":range", 7),
            (store_random_in_range, ":entry_point", 75, 80),
            (assign, ":troop_id", "trp_royal_lord"),
        (try_end),
				(add_visitors_to_current_scene, ":entry_point", ":troop_id", 1, 0, -1),
			###
			(try_end),
		(try_end),
		]),

	("cf_client_agent_is_inactive", # clients: try to check that the agent is not moving or fighting
	 [
		(assign, ":action", 0),
		(multiplayer_get_my_player, ":player_id"),
		(try_begin),
			(player_is_active, ":player_id"),
			(player_get_agent_id, ":agent_id", ":player_id"),
			(agent_is_active, ":agent_id"),
			(agent_is_alive, ":agent_id"),
			(agent_get_speed, pos1, ":agent_id"),
			(position_get_x, ":action", pos1),
			(eq, ":action", 0),
			(position_get_y, ":action", pos1),
			(eq, ":action", 0),
			(agent_get_defend_action, ":action", ":agent_id"),
		(try_end),
		(eq, ":action", 0),
		]),

	("show_welcome_message", # clients: display the server welcome and game information messages
	 [
		(str_store_welcome_message, s10),
		(store_add, ":name_string_id", lazy.sub(game_type_names_begin, game_type_mission_templates_begin), "$g_game_type"),
		(str_store_string, s11, ":name_string_id"),
		(store_add, ":info_string_id", lazy.sub(game_type_info_strings_begin, game_type_mission_templates_begin), "$g_game_type"),
		(str_store_string, s12, ":info_string_id"),
		(call_script, "script_preset_message", "str_pw_welcome", preset_message_read_object, "str_join_game", 0),
		]),

	("request_poll", # server: handle requests for polls from players
	 [(store_script_param, ":poll_type", 1), # constants starting with poll_type_
		(store_script_param, ":requester_player_id", 2),
		(store_script_param, ":value_1", 3),

		(try_begin),
			(player_is_active, ":requester_player_id"),
			(assign, ":value_2", -1),
			(assign, ":gold_cost", 0),
			(assign, ":poll_faction_id", factions_end),
			(assign, ":poll_error", 0),
			(try_begin), # ensure a global poll is not running
				(neg|faction_slot_eq, factions_end, slot_faction_poll_end_time, 0),
				(assign, ":poll_error", poll_result_existing),
			(else_try), # for a new global poll, ensure that a faction poll is not running
				(neq, ":poll_type", poll_type_faction_lord),
				(try_for_range, ":other_faction_id", factions_begin, factions_end),
					(neg|faction_slot_eq, ":other_faction_id", slot_faction_poll_end_time, 0),
					(assign, ":poll_error", poll_result_existing),
				(try_end),
				(eq, ":poll_error", poll_result_existing),
			(else_try),
				(eq, ":poll_type", poll_type_change_scene),
				(eq, "$g_scenes_voteable", 1),
				(is_between, ":value_1", scenes_begin, scenes_end),
				(assign, ":gold_cost", poll_cost_change_scene),
				(store_sub, ":scene_name_id", ":value_1", scenes_begin),
				(val_add, ":scene_name_id", scene_names_begin),
				(str_store_string, s1, ":scene_name_id"),
				(str_store_string, s0, "str_poll_change_scene"),
			(else_try),
				(this_or_next|eq, ":poll_type", poll_type_kick_player),
				(eq, ":poll_type", poll_type_ban_player),
				(neq, ":value_1", ":requester_player_id"),
				(player_is_active, ":value_1"),
				(neg|player_is_admin, ":value_1"),
				(assign, ":log_string_id", -1),
				(try_begin),
					(eq, ":poll_type", poll_type_kick_player),
					(eq, "$g_kick_voteable", 1),
					(assign, ":gold_cost", poll_cost_kick_player),
					(assign, ":log_string_id", "str_poll_kick_player"),
				(else_try),
					(eq, "$g_ban_voteable", 1),
					(assign, ":gold_cost", poll_cost_ban_player),
					(assign, ":log_string_id", "str_poll_ban_player"),
				(try_end),
				(gt, ":log_string_id", -1),
				(str_store_player_username, s1, ":value_1"),
				#(store_script_param, ":value_2", 4),
				(str_store_string, s0, ":log_string_id"),
			(else_try),
				(eq, ":poll_type", poll_type_faction_lord),
				(player_is_active, ":value_1"),
				(player_get_slot, ":poll_faction_id", ":requester_player_id", slot_player_faction_id),
				(try_begin), # ensure that the player is not voting for themself and the faction is not locked
					#(neq, ":value_1", ":requester_player_id"),
					(faction_slot_eq, ":poll_faction_id", slot_faction_is_locked, 0),
				(else_try), # but allow admins to override the last conditions
					(player_is_admin, ":requester_player_id"),
					(player_slot_eq, ":requester_player_id", slot_player_admin_no_factions, 0),
				(else_try),
					(assign, ":poll_error", poll_result_invalid),
				(try_end),
				(eq, ":poll_error", 0),
				(assign, ":poll_error", poll_result_existing),
				(faction_slot_eq, ":poll_faction_id", slot_faction_poll_end_time, 0),
				(assign, ":poll_error", 0),
				(is_between, ":poll_faction_id", castle_factions_begin, factions_end),
				(player_slot_eq, ":value_1", slot_player_faction_id, ":poll_faction_id"),
				(assign, ":gold_cost", poll_cost_faction_lord),
				(str_store_player_username, s1, ":value_1"),
				(str_store_faction_name, s2, ":poll_faction_id"),
				(str_store_string, s0, "str_poll_faction_lord"),
			(else_try),
				(eq, ":poll_error", 0),
				(assign, ":poll_error", poll_result_invalid),
			(try_end),
			(try_begin),
				(neq, ":poll_error", 0),
				(multiplayer_send_int_to_player, ":requester_player_id", server_event_show_poll, ":poll_error"),
			(try_end),
			(eq, ":poll_error", 0),
			(call_script, "script_cf_check_enough_gold", ":requester_player_id", ":gold_cost"),
			(call_script, "script_player_adjust_gold", ":requester_player_id", ":gold_cost", -1),
			(assign, ":voter_count", 0),
			(get_max_players, ":max_players"),
			(try_for_range, ":player_id", 1, ":max_players"),
				(player_is_active, ":player_id"),
				(this_or_next|eq, ":poll_faction_id", factions_end),
				(player_slot_eq, ":player_id", slot_player_faction_id, ":poll_faction_id"),
				(player_slot_eq, ":player_id", slot_player_poll_faction_id, 0),
				(player_set_slot, ":player_id", slot_player_poll_faction_id, ":poll_faction_id"),
				(try_begin),
					(eq, ":value_2", -1),
					(multiplayer_send_3_int_to_player, ":player_id", server_event_show_poll, ":poll_type", ":requester_player_id", ":value_1"),
				(else_try),
					(multiplayer_send_4_int_to_player, ":player_id", server_event_show_poll, ":poll_type", ":requester_player_id", ":value_1", ":value_2"),
				(try_end),
				(val_add, ":voter_count", 1),
			(try_end),
			(gt, ":voter_count", 0),
			(str_store_player_username, s3, ":requester_player_id"),
			(server_add_message_to_log, "str_poll_log"),
			(store_mission_timer_a, ":end_time"),
			(val_add, ":end_time", poll_time_duration),
			(faction_set_slot, ":poll_faction_id", slot_faction_poll_end_time, ":end_time"),
			(faction_set_slot, ":poll_faction_id", slot_faction_poll_voter_count, ":voter_count"),
			(faction_set_slot, ":poll_faction_id", slot_faction_poll_yes_votes, 0),
			(faction_set_slot, ":poll_faction_id", slot_faction_poll_no_votes, 0),
			(faction_set_slot, ":poll_faction_id", slot_faction_poll_type, ":poll_type"),
			(faction_set_slot, ":poll_faction_id", slot_faction_poll_value_1, ":value_1"),
			(faction_set_slot, ":poll_faction_id", slot_faction_poll_value_2, ":value_2"),
			(try_begin), # save target player information in case they disconnect before the poll ends
				(this_or_next|eq, ":poll_type", poll_type_kick_player),
				(eq, ":poll_type", poll_type_faction_lord),
				(player_get_unique_id, ":unique_id", ":value_1"),
				(faction_set_slot, ":poll_faction_id", slot_faction_poll_target_unique_id, ":unique_id"),
			(else_try),
				(eq, ":poll_type", poll_type_ban_player),
				(save_ban_info_of_player, ":value_1"),
			(try_end),
		(try_end),
		]),

	("show_poll", # clients: handle showing polls or poll results
	 [(store_script_param, ":poll_type", 1), # constants starting with poll_type_ and poll_result_

		(try_begin),
			(ge, ":poll_type", 0),
			(assign, "$g_poll_type", ":poll_type"),
			(store_script_param, "$g_poll_requester_player_id", 2),
			(store_script_param, "$g_poll_value_1", 3),
			(store_mission_timer_a, "$g_poll_end_time"),
			(val_add, "$g_poll_end_time", poll_time_duration),
			(start_presentation, "prsnt_show_poll"),
		(else_try),
			(eq, ":poll_type", poll_result_existing),
			(display_message, "str_poll_existing", poll_result_color),
		(else_try),
			(eq, ":poll_type", poll_result_invalid),
			(display_message, "str_poll_invalid", poll_result_color),
		(else_try),
			(try_begin),
				(is_presentation_active, "prsnt_show_poll"),
				(assign, "$g_hide_poll", 1),
			(try_end),
			(eq, ":poll_type", poll_result_no),
			(display_message, "str_poll_result_no", poll_result_color),
		(else_try),
			(eq, ":poll_type", poll_result_yes),
			(display_message, "str_poll_result_yes", poll_result_color),
		(else_try),
			(eq, ":poll_type", poll_result_admin_no),
			(display_message, "str_poll_result_admin_no", poll_result_color),
		(else_try),
			(eq, ":poll_type", poll_result_admin_yes),
			(display_message, "str_poll_result_admin_yes", poll_result_color),
		(try_end),
		]),

	("poll_vote", # server: handle player votes for polls
	 [(store_script_param, ":player_id", 1), # must be valid
		(store_script_param, ":vote", 2),

		(try_begin),
			(player_get_slot, ":poll_faction_id", ":player_id", slot_player_poll_faction_id),
			(gt, ":poll_faction_id", 0),
			(player_set_slot, ":player_id", slot_player_poll_faction_id, 0), # prevent the player voting again
			(ge, ":poll_faction_id", castle_factions_begin),
			(le, ":poll_faction_id", factions_end),
			(faction_slot_ge, ":poll_faction_id", slot_faction_poll_end_time, 1),
			(assign, ":remove_vote", 0),
			(try_begin),
				(neq, ":poll_faction_id", factions_end),
				(neg|player_slot_eq, ":player_id", slot_player_faction_id, ":poll_faction_id"),
				(assign, ":remove_vote", 1), # remove vote if the player was not in the faction at the start of the poll
			(else_try),
				(eq, ":vote", poll_vote_abstain),
				(assign, ":remove_vote", 1),
			(try_end),
			(try_begin),
				(eq, ":remove_vote", 1),
				(faction_get_slot, ":voter_count", ":poll_faction_id", slot_faction_poll_voter_count),
				(val_sub, ":voter_count", 1),
				(faction_set_slot, ":poll_faction_id", slot_faction_poll_voter_count, ":voter_count"),
			(try_end),
			(eq, ":remove_vote", 0),
			(try_begin),
				(eq, ":vote", poll_vote_no),
				(faction_get_slot, ":no_votes", ":poll_faction_id", slot_faction_poll_no_votes),
				(val_add, ":no_votes", 1),
				(faction_set_slot, ":poll_faction_id", slot_faction_poll_no_votes, ":no_votes"),
			(else_try),
				(eq, ":vote", poll_vote_yes),
				(faction_get_slot, ":yes_votes", ":poll_faction_id", slot_faction_poll_yes_votes),
				(val_add, ":yes_votes", 1),
				(faction_set_slot, ":poll_faction_id", slot_faction_poll_yes_votes, ":yes_votes"),
			(else_try),
				(assign, ":poll_result", 0),
				(try_begin),
					(eq, ":vote", poll_vote_admin_no),
					(assign, ":poll_result", poll_result_admin_no),
				(else_try),
					(eq, ":vote", poll_vote_admin_yes),
					(assign, ":poll_result", poll_result_admin_yes),
				(try_end),
				(neq, ":poll_result", 0),
				(player_is_admin, ":player_id"),
				(player_slot_eq, ":player_id", slot_player_admin_no_override_poll, 0),
				(faction_set_slot, ":poll_faction_id", slot_faction_poll_end_time, 0),
				(call_script, "script_apply_poll_consequences", ":poll_faction_id", ":poll_result"),
			(try_end),
		(try_end),
		]),

	("check_polls_ended", # server: check all factions for polls that have ended
	 [
		(store_mission_timer_a, ":current_time"),
		(store_add, ":factions_end", factions_end, 1),
		(try_for_range, ":poll_faction_id", castle_factions_begin, ":factions_end"),
			(faction_get_slot, ":end_time", ":poll_faction_id", slot_faction_poll_end_time),
			(ge, ":end_time", 1),
			(faction_get_slot, ":voter_count", ":poll_faction_id", slot_faction_poll_voter_count),
			(faction_get_slot, ":yes_votes", ":poll_faction_id", slot_faction_poll_yes_votes),
			(faction_get_slot, ":no_votes", ":poll_faction_id", slot_faction_poll_no_votes),
			(store_add, ":received_votes", ":yes_votes", ":no_votes"),
			(this_or_next|ge, ":received_votes", ":voter_count"),
			(ge, ":current_time", ":end_time"),
			(faction_set_slot, ":poll_faction_id", slot_faction_poll_end_time, 0),
			(store_sub, ":abstain_votes", ":voter_count", ":received_votes"),
			(val_mul, ":abstain_votes", 3),
			(val_div, ":abstain_votes", 10),
			(store_add, ":total_votes", ":received_votes", ":abstain_votes"),
			(val_max, ":total_votes", 1),
			(store_mul, ":vote_ratio", ":yes_votes", 100),
			(val_div, ":vote_ratio", ":total_votes"),
			(try_begin),
				(ge, ":vote_ratio", "$g_valid_vote_ratio"),
				(assign, ":poll_result", poll_result_yes),
			(else_try),
				(assign, ":poll_result", poll_result_no),
			(try_end),
			(call_script, "script_apply_poll_consequences", ":poll_faction_id", ":poll_result"),
		(try_end),
		]),

	("apply_poll_consequences", # server: try to apply the poll consequences, displaying the result to voters
	 [(store_script_param, ":poll_faction_id", 1),
		(store_script_param, ":poll_result", 2), # constants starting with poll_result_

		(faction_get_slot, ":poll_type", ":poll_faction_id", slot_faction_poll_type),
		(faction_get_slot, ":value_1", ":poll_faction_id", slot_faction_poll_value_1),
		(try_begin),
			(this_or_next|eq, ":poll_result", poll_result_yes),
			(eq, ":poll_result", poll_result_admin_yes),
			(this_or_next|eq, ":poll_type", poll_type_kick_player),
			(eq, ":poll_type", poll_type_faction_lord),
			(player_is_active, ":value_1"),
			(player_get_unique_id, ":check_unique_id", ":value_1"),
			(faction_get_slot, ":target_unique_id", ":poll_faction_id", slot_faction_poll_target_unique_id),
		(else_try),
			(assign, ":check_unique_id", -1),
			(assign, ":target_unique_id", -1),
		(try_end),
		(get_max_players, ":max_players"),
		(try_for_range, ":player_id", 1, ":max_players"),
			(player_is_active, ":player_id"),
			(this_or_next|eq, ":poll_faction_id", factions_end),
			(player_slot_eq, ":player_id", slot_player_faction_id, ":poll_faction_id"),
			(player_set_slot, ":player_id", slot_player_poll_faction_id, 0),
			(multiplayer_send_int_to_player, ":player_id", server_event_show_poll, ":poll_result"),
			(neq, ":check_unique_id", ":target_unique_id"),
			(player_get_unique_id, ":check_unique_id", ":value_1"),
			(eq, ":check_unique_id", ":target_unique_id"),
			(assign, ":value_1", ":player_id"),
		(try_end),
		(try_begin),
			(neq, ":poll_result", poll_result_yes),
			(neq, ":poll_result", poll_result_admin_yes),
		(else_try),
			(eq, ":poll_type", poll_type_change_scene),
			(assign, "$g_next_scene", ":value_1"),
		(else_try),
			(eq, ":poll_type", poll_type_kick_player),
			(player_is_active, ":value_1"),
			(eq, ":check_unique_id", ":target_unique_id"),
			(kick_player, ":value_1"),
		(else_try),
			(eq, ":poll_type", poll_type_ban_player),
			(ban_player_using_saved_ban_info),
		(else_try),
			(eq, ":poll_type", poll_type_faction_lord),
			(this_or_next|neg|player_is_active, ":value_1"),
			(eq, ":check_unique_id", ":target_unique_id"),
			(call_script, "script_cf_faction_set_lord", ":value_1", ":target_unique_id", ":poll_faction_id"),
		(try_end),
		]),

	("select_target_agent", # clients: find the agent projected closest to the center of the view, highlighting them and storing in $g_target_agent_id and $g_target_player_id
	 [
		(set_fixed_point_multiplier, 1000),
		(multiplayer_get_my_player, ":my_player_id"),
		(player_get_agent_id, ":my_agent_id", ":my_player_id"),
		(assign, ":closest_score", int(math.sqrt(select_agent_max_x * select_agent_max_x + select_agent_max_y * select_agent_max_y))),
		(convert_to_fixed_point, ":closest_score"),
		(assign, "$g_target_agent_id", -1),
		(mission_cam_get_position, pos1),
		(try_for_agents, ":agent_id"),
			(agent_is_human, ":agent_id"),
			(agent_set_slot, ":agent_id", slot_agent_is_targeted, 0),
			(neq, ":agent_id", ":my_agent_id"),
			(agent_get_item_slot, ":body_item_id", ":agent_id", ek_body),
			(neq, ":body_item_id", "itm_invisible_body"),
			(agent_get_position, pos2, ":agent_id"),
			(position_move_z, pos2, 160),
			(agent_get_horse, ":horse", ":agent_id"),
			(try_begin),
				(ge, ":horse", 0),
				(position_move_z, pos2, 80),
			(try_end),
			(get_sq_distance_between_positions, ":sq_distance", pos1, pos2),
			(le, ":sq_distance", sq(max_distance_to_see_labels)),
			(position_has_line_of_sight_to_position, pos1, pos2),
			(position_get_screen_projection, pos3, pos2),
			(position_get_x, ":x_pos", pos3),
			(val_sub, ":x_pos", presentation_max_x / 2),
			(val_abs, ":x_pos"),
			(lt, ":x_pos", select_agent_max_x),
			(position_get_y, ":y_pos", pos3),
			(val_sub, ":y_pos", presentation_max_y / 2),
			(val_abs, ":y_pos"),
			(lt, ":y_pos", select_agent_max_y),
			(val_mul, ":x_pos", ":x_pos"),
			(val_mul, ":y_pos", ":y_pos"),
			(store_add, ":score", ":x_pos", ":y_pos"),
			(convert_to_fixed_point, ":score"),
			(store_sqrt, ":score", ":score"),
			(lt, ":score", ":closest_score"),
			(assign, ":closest_score", ":score"),
			(assign, "$g_target_agent_id", ":agent_id"),
		(try_end),
		(try_begin),
			(gt, "$g_target_agent_id", -1),
			(agent_get_position, pos2, "$g_target_agent_id"),
			(particle_system_burst, "psys_target_agent", pos2, 1),
			(agent_set_slot, "$g_target_agent_id", slot_agent_is_targeted, 1), # set an agent slot for verification if that agent dies before the usage
			(agent_get_player_id, ":target_player_id", "$g_target_agent_id"),
			(try_begin),
				(player_is_active, ":target_player_id"),
				(assign, "$g_target_player_id", ":target_player_id"),
				(assign, "$g_target_player_overlay_id", -1),
				(player_set_slot, "$g_target_player_id", slot_player_list_button_id, -1),
			(try_end),
			(try_begin),
				(neg|is_presentation_active, "prsnt_target_agent_name"),
				(start_presentation, "prsnt_target_agent_name"),
			(try_end),
		(else_try),
			(player_is_active, "$g_target_player_id"),
			(player_slot_eq, "$g_target_player_id", slot_player_list_button_id, -1),
			(assign, "$g_target_player_id", -1),
		(try_end),
		(set_fixed_point_multiplier, 100),
		]),

	("select_target_corpse", # clients: find the nearby corpse projected closest to the center of the view, highlighing them and storing in $g_target_corpse_instance_id
	 [
		(set_fixed_point_multiplier, 1000),
		(multiplayer_get_my_player, ":player_id"),
		(try_begin),
			(player_is_active, ":player_id"),
			(player_get_agent_id, ":agent_id", ":player_id"),
			(agent_is_active, ":agent_id"),
			(agent_is_alive, ":agent_id"),
			(assign, ":closest_score", int(math.sqrt(select_agent_max_x * select_agent_max_x + select_agent_max_y * select_agent_max_y))),
			(convert_to_fixed_point, ":closest_score"),
			(assign, "$g_target_corpse_instance_id", -1),
			(mission_cam_get_position, pos1),
			(scene_spawned_item_get_num_instances, ":corpse_count", "itm_agent_corpse"),
			(try_for_range, ":corpse_no", 0, ":corpse_count"),
				(scene_spawned_item_get_instance, ":corpse_instance_id", "itm_agent_corpse", ":corpse_no"),
				(scene_prop_set_slot, ":corpse_instance_id", slot_scene_prop_inventory_targeted, 0),
				(prop_instance_get_position, pos2, ":corpse_instance_id"),
				(get_sq_distance_between_positions, ":sq_distance", pos1, pos2),
				(le, ":sq_distance", sq(max_distance_to_see_labels)),
				(position_get_screen_projection, pos3, pos2),
				(position_get_x, ":x_pos", pos3),
				(val_sub, ":x_pos", presentation_max_x / 2),
				(val_abs, ":x_pos"),
				(lt, ":x_pos", select_agent_max_x),
				(position_get_y, ":y_pos", pos3),
				(val_sub, ":y_pos", presentation_max_y / 2),
				(val_abs, ":y_pos"),
				(lt, ":y_pos", select_agent_max_y),
				(val_mul, ":x_pos", ":x_pos"),
				(val_mul, ":y_pos", ":y_pos"),
				(store_add, ":score", ":x_pos", ":y_pos"),
				(convert_to_fixed_point, ":score"),
				(store_sqrt, ":score", ":score"),
				(lt, ":score", ":closest_score"),
				(assign, ":closest_score", ":score"),
				(assign, "$g_target_corpse_instance_id", ":corpse_instance_id"),
			(try_end),
			(try_begin),
				(gt, "$g_target_corpse_instance_id", -1),
				(prop_instance_get_position, pos2, "$g_target_corpse_instance_id"),
				(particle_system_burst, "psys_target_agent", pos2, 1),
				(scene_prop_set_slot, "$g_target_corpse_instance_id", slot_scene_prop_inventory_targeted, 1), 
			(try_end),
		(try_end),
		(set_fixed_point_multiplier, 100),
		]),

	("loot_target_corpse", # clients: request to loot the currently targeted corpse
	 [
		(try_begin),
			(prop_instance_is_valid, "$g_target_corpse_instance_id"),
			(scene_prop_slot_eq, "$g_target_corpse_instance_id", slot_scene_prop_inventory_targeted, 1),
			(multiplayer_get_my_player, ":player_id"),
			(player_is_active, ":player_id"),
			(player_get_agent_id, ":agent_id", ":player_id"),
			(agent_is_active, ":agent_id"),
			(agent_is_alive, ":agent_id"),
			(agent_get_position, pos1, ":agent_id"),
			(prop_instance_get_position, pos2, "$g_target_corpse_instance_id"),
			(get_sq_distance_between_positions, ":sq_distance", pos1, pos2),
			(try_begin),
			(str_store_player_username, s2, ":player_id"),
		(server_add_message_to_log, "@{s2} looted a corpse!"),
				(le, ":sq_distance", sq(max_distance_to_loot)),
				(scene_prop_set_slot, "$g_target_corpse_instance_id", slot_scene_prop_inventory_count, corpse_inventory_slots),
				(scene_prop_set_slot, "$g_target_corpse_instance_id", slot_scene_prop_inventory_max_length, corpse_inventory_max_length),
				(multiplayer_send_2_int_to_server, client_event_agent_loot_armor, "$g_target_corpse_instance_id"),
			(else_try),
				(call_script, "script_preset_message", "str_too_far_away_loot", preset_message_error, 0, 0),
			(try_end),
		(try_end),
		]),

 ("cf_admin_action", # server: check player requests to use admin tools, applying if successful
	 [(store_script_param, ":admin_action", 1), # constants starting with admin_action_
		(store_script_param, ":admin_player_id", 2), # must be valid
		(store_script_param, ":target_player_id", 3),

		(player_is_admin, ":admin_player_id"),
		(try_begin), # this tool and ones past it are applied to the admin themself
			(ge, ":admin_action", admin_action_teleport_forwards),
			(assign, ":target_player_id", ":admin_player_id"),
		(try_end),
		(player_is_active, ":target_player_id"),
		(try_begin),
			(eq, ":admin_action", admin_action_kick_player),
			(player_slot_eq, ":admin_player_id", slot_player_admin_no_kick, 0),
			(kick_player, ":target_player_id"),
			#Record starts from here
			(player_get_unique_id, reg1, ":target_player_id"),
			(str_store_player_username, s1, ":admin_player_id"),
			(str_store_player_username, s2, ":target_player_id"),
			(send_message_to_url, "@http://localhost/backendDsDvC/record.php?guid={reg1}&name={s2}&admin={s1}&type=Kicked"),
		(else_try),
			(eq, ":admin_action", admin_action_ban_player_temp),
			(player_slot_eq, ":admin_player_id", slot_player_admin_no_temporary_ban, 0),
			(ban_player, ":target_player_id", 1, ":admin_player_id"),
			#Record starts from here
			(player_get_unique_id, reg1, ":target_player_id"),
			(str_store_player_username, s1, ":admin_player_id"),
			(str_store_player_username, s2, ":target_player_id"),
			(send_message_to_url, "@http://localhost/backendDsDvC/record.php?guid={reg1}&name={s2}&admin={s1}&type=TempBan"),
		(else_try),
			(eq, ":admin_action", admin_action_ban_player_perm),
			(player_slot_eq, ":admin_player_id", slot_player_admin_no_permanent_ban, 0),
			 # (ban_player, ":target_player_id", 0, ":admin_player_id"),
			#Record starts from here
			(player_get_unique_id, reg1, ":target_player_id"),
			(str_store_player_username, s1, ":admin_player_id"),
			(str_store_player_username, s2, ":target_player_id"),
			(send_message_to_url, "@http://localhost/backendDsDvC/record.php?guid={reg1}&name={s2}&admin={s1}&type=PermBan"),
			# kick player cause ban
			(assign, ":player_id", ":target_player_id"),
			(assign, ":rejection_string_id", "@You got banned permanently!"),
			(multiplayer_send_2_int_to_player, ":player_id", server_event_preset_message, ":rejection_string_id", preset_message_error|preset_message_log),
			(store_mission_timer_a, ":time"), # kick the player after a short delay to try ensure they see the rejection message
			(val_add, ":time", name_server_kick_delay_interval),
			(player_set_slot, ":player_id", slot_player_kick_at_time, ":time"),
		(else_try),
			(eq, ":admin_action", admin_action_mute_player),
			(player_slot_eq, ":admin_player_id", slot_player_admin_no_mute, 0),
			(player_get_is_muted, ":is_muted", ":target_player_id"),
			(try_begin),
				(eq, ":is_muted", 0),
				(assign, ":is_muted", 1),
			(else_try),
				(assign, ":is_muted", 0),
			(try_end),
			(player_set_is_muted, ":target_player_id", ":is_muted", 1),
		(else_try),
			(lt, ":admin_action", admin_action_remove_horses), # tools before this are applied to the target player's agent
			(player_get_agent_id, ":agent_id", ":target_player_id"),
			(agent_is_active, ":agent_id"),
			(try_begin),
				(eq, ":admin_action", admin_action_kill_player),
				(player_slot_eq, ":admin_player_id", slot_player_admin_no_kill_fade, 0),
				(agent_deliver_damage_to_agent, ":agent_id", ":agent_id", 500),
			 #Record starts from here
				(player_get_unique_id, reg1, ":target_player_id"),
				(str_store_player_username, s1, ":admin_player_id"),
				(str_store_player_username, s2, ":target_player_id"),
				(send_message_to_url, "@http://localhost/backendDsDvC/record.php?guid={reg1}&name={s2}&admin={s1}&type=Kill"),
			(else_try),
				(eq, ":admin_action", admin_action_fade_player_out),
				(player_slot_eq, ":admin_player_id", slot_player_admin_no_kill_fade, 0),
				(agent_fade_out, ":agent_id"),
				#Record starts from here
				(player_get_unique_id, reg1, ":target_player_id"),
				(str_store_player_username, s1, ":admin_player_id"),
				(str_store_player_username, s2, ":target_player_id"),
				(send_message_to_url, "@http://localhost/backendDsDvC/record.php?guid={reg1}&name={s2}&admin={s1}&type=Fade"),
				(try_for_range, ":player_equip_slot", slot_player_equip_item_0, slot_player_equip_end),
					(player_set_slot, ":target_player_id", ":player_equip_slot", 0),
				(try_end),
				(agent_get_slot, ":freeze_instance_id", ":agent_id", slot_agent_freeze_instance_id),
				(try_begin),
					(gt, ":freeze_instance_id", -1),
					(call_script, "script_remove_scene_prop", ":freeze_instance_id"),
					(agent_set_slot, ":agent_id", slot_agent_freeze_instance_id, -1),
				(try_end),
				(player_set_slot, ":target_player_id", slot_player_spawn_state, player_spawn_state_dead),
			(else_try),
				(eq, ":admin_action", admin_action_freeze_player),
				(player_slot_eq, ":admin_player_id", slot_player_admin_no_freeze, 0),
				(agent_get_horse, ":horse_agent_id", ":agent_id"),
				(agent_get_slot, ":freeze_instance_id", ":agent_id", slot_agent_freeze_instance_id),
				(try_begin),
					(gt, ":freeze_instance_id", -1),
					(call_script, "script_remove_scene_prop", ":freeze_instance_id"),
					(agent_set_slot, ":agent_id", slot_agent_freeze_instance_id, -1),
					(agent_set_speed_modifier, ":agent_id", 100),
					(try_begin),
						(gt, ":horse_agent_id", -1),
						(agent_set_speed_modifier, ":horse_agent_id", 100),
					(try_end),
				(else_try),
					(try_begin),
						(gt, ":horse_agent_id", -1),
						(assign, ":freeze_scene_prop_id", "spr_code_freeze_horse_agent"),
						(agent_set_speed_modifier, ":horse_agent_id", 0),
					(else_try),
						(assign, ":freeze_scene_prop_id", "spr_code_freeze_agent"),
					(try_end),
					(agent_get_position, pos1, ":agent_id"),
					(call_script, "script_reuse_or_spawn_scene_prop", ":freeze_scene_prop_id"),
					(prop_instance_set_position, reg0, pos1),
					(agent_set_slot, ":agent_id", slot_agent_freeze_instance_id, reg0),
					(agent_set_speed_modifier, ":agent_id", 0),
				(try_end),
			###GGG:admin tool 
			(else_try),
				(eq, ":admin_action", admin_action_add_outlaw_player),
				(player_slot_eq, ":admin_player_id", slot_player_admin_no_freeze, 0),
				(player_get_slot,  ":target_outlaw_rating", ":target_player_id", slot_player_outlaw_rating),
				(lt, ":target_outlaw_rating", outlaw_rating_maximum),
				(call_script, "script_player_change_check_outlaw_rating", ":target_player_id", 1, 0),
			(else_try),
				(eq, ":admin_action", admin_action_sub_outlaw_player),
				(player_slot_eq, ":admin_player_id", slot_player_admin_no_freeze, 0),
				(player_get_slot,  ":target_outlaw_rating", ":target_player_id", slot_player_outlaw_rating),
				(ge, ":target_outlaw_rating", 1),
				(call_script, "script_player_change_check_outlaw_rating", ":target_player_id", -1, 0),
			(else_try),
				(player_slot_eq, ":admin_player_id", slot_player_admin_no_teleport_self, 0),
				(eq, ":admin_action", admin_action_teleport_player_to_admin), 
				(player_get_agent_id, ":admin_agent_id", ":admin_player_id"),
				(agent_is_active, ":admin_agent_id"),
				(agent_get_position, pos1, ":admin_agent_id"),
				(position_move_y, pos1, 100),
				#(agent_set_position, ":agent_id", pos1),
				#Arthur optimize teleport
				(call_script, "script_cf_teleport_agent_to_pos", ":agent_id", pos1),

			###
			(else_try),
				(player_slot_eq, ":admin_player_id", slot_player_admin_no_teleport_self, 0),
				(this_or_next|eq, ":admin_action", admin_action_teleport_to_player),
				(this_or_next|eq, ":admin_action", admin_action_teleport_behind_player),
				(eq, ":admin_action", admin_action_teleport_forwards),
				(player_get_agent_id, ":admin_agent_id", ":admin_player_id"),
				(try_begin),
					(agent_is_active, ":admin_agent_id"),
					(try_begin),
						(eq, ":admin_action", admin_action_teleport_to_player),
						(agent_get_position, pos1, ":agent_id"),
						(position_move_y, pos1, 100),
					(else_try),
						(eq, ":admin_action", admin_action_teleport_behind_player),        
						(agent_get_position, pos1, ":agent_id"),            
						(position_move_y, pos1, -200),
					(else_try),
						(eq, ":admin_action", admin_action_teleport_forwards),
						(agent_get_position, pos1, ":admin_agent_id"),
						(position_move_y, pos1, 300),
						(position_move_z, pos1, 100),
					(try_end),
					(agent_set_position, ":admin_agent_id", pos1),
					#Arthur optimize teleport
					(call_script, "script_cf_teleport_agent_to_pos", ":admin_agent_id", pos1),
				(try_end),
			(else_try),
				(player_slot_eq, ":admin_player_id", slot_player_admin_no_admin_items, 0),
				(try_begin),
					(eq, ":admin_action", admin_action_get_armor),
					(troop_set_slot, "trp_temp_array", slot_player_equip_head, "itm_black_helmet"),
					(troop_set_slot, "trp_temp_array", slot_player_equip_body, "itm_black_armor"),
					(troop_set_slot, "trp_temp_array", slot_player_equip_foot, "itm_black_greaves"),
					(troop_set_slot, "trp_temp_array", slot_player_equip_gloves, "itm_gauntlets"),
				(else_try),
					(eq, ":admin_action", admin_action_get_invisible),
					(troop_set_slot, "trp_temp_array", slot_player_equip_head, "itm_invisible_head"),
					(troop_set_slot, "trp_temp_array", slot_player_equip_body, "itm_invisible_body"),
					(troop_set_slot, "trp_temp_array", slot_player_equip_foot, "itm_invisible_foot"),
					(troop_set_slot, "trp_temp_array", slot_player_equip_gloves, "itm_invisible_hand"),
				(else_try),
					(troop_set_slot, "trp_temp_array", slot_player_equip_body, 0),
				(try_end),
				(neg|troop_slot_eq, "trp_temp_array", slot_player_equip_body, 0),
				(agent_get_item_slot, ":equipped_item_id", ":agent_id", ek_body),
				(try_begin), # if the admin body armor selected is already equipped, return the previous armor
					(troop_slot_eq, "trp_temp_array", slot_player_equip_body, ":equipped_item_id"),
					(try_for_range, ":slot", slot_player_equip_head, slot_player_equip_gloves + 1),
						(player_get_slot, ":item_id", ":target_player_id", ":slot"),
						(try_begin),
							(neq, ":item_id", -1),
							(val_abs, ":item_id"),
							(ge, ":item_id", all_items_begin),
						(else_try),
							(store_sub, ":item_id", ":slot", slot_player_equip_head),
							(val_add, ":item_id", "itm_no_head"),
						(try_end),
						(troop_set_slot, "trp_temp_array", ":slot", ":item_id"),
					(try_end),
				(else_try),
					(eq, ":admin_action", admin_action_get_invisible),
					(agent_equip_item, ":agent_id", "itm_invisible_sword"),
				(try_end),
				(try_for_range, ":slot", slot_player_equip_head, slot_player_equip_gloves + 1),
					(troop_get_slot, ":item_id", "trp_temp_array", ":slot"),
					(call_script, "script_change_armor", ":agent_id", ":item_id"),
				(try_end),
			(else_try),
				(eq, ":admin_action", admin_action_refill_health),
				(player_slot_eq, ":admin_player_id", slot_player_admin_no_heal_self, 0),
				(agent_set_hit_points, ":agent_id", 100, 0),
				(call_script, "script_cf_clean_blood", ":agent_id"),
			(else_try),
				(eq, ":admin_action", admin_action_become_godlike),
				(player_slot_eq, ":admin_player_id", slot_player_admin_no_godlike_troop, 0),
				(player_get_troop_id, ":troop_id", ":admin_player_id"),
				(try_begin), # if the admin is already using the godlike hero, return to the previous troop
					(eq, ":troop_id", "trp_godlike_hero"),
					(player_get_slot, ":new_troop_id", ":admin_player_id", slot_player_non_lord_troop_id),
					(try_begin),
						(neg|is_between, ":new_troop_id", playable_troops_begin, playable_troops_end),
						(assign, ":new_troop_id", playable_troops_begin),
						(player_set_slot, ":admin_player_id", slot_player_non_lord_troop_id, playable_troops_begin),
					(try_end),
				(else_try),
					(player_set_slot, ":admin_player_id", slot_player_non_lord_troop_id, ":troop_id"),
					(assign, ":new_troop_id", "trp_godlike_hero"),
				(try_end),
				(player_set_troop_id, ":admin_player_id", ":new_troop_id"),
				(agent_set_hit_points, ":agent_id", 100, 0),
				(call_script, "script_player_add_equipped_items", ":admin_player_id", ":new_troop_id"),
				(call_script, "script_player_add_default_troop_items", ":admin_player_id", ":new_troop_id"),
				(call_script, "script_player_add_default_troop_armor", ":admin_player_id", ":new_troop_id"),
				(call_script, "script_player_add_spawn_items", ":admin_player_id", 1),
				(call_script, "script_player_respawn_in_place", ":admin_player_id"),
			(else_try),
				(eq, ":admin_action", admin_action_get_horse),
				(player_slot_eq, ":admin_player_id", slot_player_admin_no_admin_items, 0),
				(agent_get_position, pos1, ":agent_id"),
				(position_move_x, pos1, 50),
				(position_set_z_to_ground_level, pos1),
				(set_spawn_position, pos1),
				(spawn_horse, "itm_admin_horse"),
			(else_try),
				(assign, ":admin_action", -1),
			(try_end),
		(else_try),
			(eq, ":admin_action", admin_action_remove_horses),
			(player_slot_eq, ":admin_player_id", slot_player_admin_no_admin_items, 0),
			(try_for_agents, ":horse_agent_id"),
				(agent_get_item_id, ":horse_item_id", ":horse_agent_id"),
				(eq, ":horse_item_id", "itm_admin_horse"),
				(agent_get_rider, ":rider_agent_id", ":horse_agent_id"),
				(try_begin),
					(neg|agent_is_active, ":rider_agent_id"),
					(agent_fade_out, ":horse_agent_id"),
				(else_try),
					(agent_get_player_id, ":rider_player_id", ":rider_agent_id"),
					(player_is_active, ":rider_player_id", ":rider_agent_id"),
					(player_is_admin, ":rider_player_id"),
				(else_try),
					(agent_deliver_damage_to_agent, ":agent_id", ":horse_agent_id", 1000),
					(agent_fade_out, ":horse_agent_id"),
				(try_end),
			(try_end),
		(else_try),
			(eq, ":admin_action", admin_action_remove_stray_horses),
			(player_slot_eq, ":admin_player_id", slot_player_admin_no_animals, 0),
			(try_for_agents, ":horse_agent_id"),
				(agent_get_item_id, ":horse_item_id", ":horse_agent_id"),
				(gt, ":horse_item_id", -1),
				(agent_get_rider, ":rider_agent_id", ":horse_agent_id"),
				(neg|agent_is_active, ":rider_agent_id"),
				(neg|agent_slot_ge, ":horse_agent_id", slot_agent_horse_last_rider, 0),
				(agent_slot_eq, ":horse_agent_id", slot_agent_animal_herd_manager, -1),
				(agent_get_attached_scene_prop, ":attached_instance_id", ":horse_agent_id"),
				(neg|prop_instance_is_valid, ":attached_instance_id"),
				(agent_fade_out, ":horse_agent_id"),
			(try_end),
		#GGG:admin tools
		(else_try),
			(eq, ":admin_action", admin_action_remove_wild_animals),
			(player_slot_eq, ":admin_player_id", slot_player_admin_no_animals, 0),
			(try_for_agents, ":horse_agent_id"),
				(agent_get_item_id, ":horse_item_id", ":horse_agent_id"),
				(is_between,":horse_item_id","itm_deer","itm_stick"),
				(call_script, "script_animal_remove_from_herd", ":horse_agent_id", -1),
				(val_sub, "$g_herd_animal_count", 1), # ensure that other herd animals can take its place
				(agent_fade_out, ":horse_agent_id"),
			(try_end),
		(else_try),
			(eq, ":admin_action", admin_action_remove_corpses),
			(player_slot_eq, ":admin_player_id", slot_player_admin_no_animals, 0),
			(try_for_range, ":corpse_item_id", "itm_animal_carcass", "itm_corpses_end"),
				(scene_spawned_item_get_num_instances, ":max_corpses", ":corpse_item_id"),
				(try_for_range, ":corpses_num", 0, ":max_corpses"),
					(scene_spawned_item_get_instance, ":corpses_id", ":corpse_item_id", ":corpses_num"),
					(prop_instance_is_valid, ":corpses_id"),
					(scene_prop_set_prune_time, ":corpses_id", 1),
				(try_end),
			(try_end),
		(else_try),
			(eq, ":admin_action", admin_action_remove_all_weapons),
			(try_for_range, ":weapon_item_id", "itm_club", "itm_sumpter_horse"),
				(scene_spawned_item_get_num_instances, ":max_weapons", ":weapon_item_id"),
				(try_for_range, ":weapons_num", 0, ":max_weapons"),
					(scene_spawned_item_get_instance, ":weapon_id", ":weapon_item_id", ":weapons_num"),
					(prop_instance_is_valid, ":weapon_id"),
					(scene_prop_set_prune_time, ":weapon_id", 1),
				(try_end),
			(try_end),
		(else_try),
			(eq, ":admin_action", admin_action_reset_carts),
			(player_slot_eq, ":admin_player_id", slot_player_admin_no_ships, 0),
			(try_for_range, ":cart_prop", "spr_pw_cart_a", "spr_pw_ship_a"),
				(scene_prop_get_num_instances, ":max_carts", ":cart_prop"),
				(try_for_range, ":cart_num", 0, ":max_carts"),
					(scene_prop_get_instance, ":cart_id", ":cart_prop", ":cart_num"),
					(prop_instance_is_valid, ":cart_id"),
					(scene_prop_slot_eq, ":cart_id", slot_scene_prop_attached_to_agent, -1), #ensure the carts are not being used
					(prop_instance_get_starting_position, pos1, ":cart_id"),
					(prop_instance_set_position, ":cart_id", pos1),
				(try_end),
			(try_end),
		#
		(else_try),
			(eq, ":admin_action", admin_action_teleport_to_ships),
			(player_slot_eq, ":admin_player_id", slot_player_admin_no_ships, 0),
			(player_get_agent_id, ":agent_id", ":admin_player_id"),
			(agent_is_active, ":agent_id"),
			(troop_get_slot, ":loop_end", "trp_ship_array", slot_ship_array_count),
			(gt, ":loop_end", 0),
			(val_add, ":loop_end", slot_ship_array_begin),
			(player_get_slot, ":target_ship_slot", ":admin_player_id", slot_player_teleport_to_ship_no),
			(try_for_range, ":unused", slot_ship_array_begin, ":loop_end"),
				(val_add, ":target_ship_slot", 1),
				(try_begin),
					(neg|is_between, ":target_ship_slot", slot_ship_array_begin, ":loop_end"),
					(assign, ":target_ship_slot", slot_ship_array_begin),
				(try_end),
				(troop_get_slot, ":instance_id", "trp_ship_array", ":target_ship_slot"),
				(scene_prop_slot_eq, ":instance_id", slot_scene_prop_state, scene_prop_state_active),
				(assign, ":loop_end", -1),
			(try_end),
			(try_begin),
				(eq, ":loop_end", -1),
				(prop_instance_get_position, pos1, ":instance_id"),
				(position_move_z, pos1, 500, 1),
				(agent_set_position, ":agent_id", pos1),
				(player_set_slot, ":admin_player_id", slot_player_teleport_to_ship_no, ":target_ship_slot"),
			(try_end),
		(else_try),
			(eq, ":admin_action", admin_action_reset_ships),
			(player_slot_eq, ":admin_player_id", slot_player_admin_no_ships, 0),
			(troop_get_slot, ":ship_array_count", "trp_ship_array", slot_ship_array_count),
			(gt, ":ship_array_count", 0),
			(player_get_agent_id, ":agent_id", ":admin_player_id"),
			(store_add, ":loop_end", slot_ship_array_begin, ":ship_array_count"),
			(try_for_range, ":ship_slot", slot_ship_array_begin, ":loop_end"),
				(troop_get_slot, ":hull_instance_id", "trp_ship_array", ":ship_slot"),
				(assign, ":reset", 0),
				(try_begin), # reset all destroyed ships
					(scene_prop_slot_eq, ":hull_instance_id", slot_scene_prop_state, scene_prop_state_destroyed),
					(assign, ":reset", 1),
				(else_try), # and also any that the admin is standing on
					(agent_is_active, ":agent_id"),
					(scene_prop_has_agent_on_it, ":hull_instance_id", ":agent_id"),
					(assign, ":reset", 2),
				(try_end),
				(gt, ":reset", 0),
				(scene_prop_set_slot, ":hull_instance_id", slot_scene_prop_state, scene_prop_state_active),
				(scene_prop_set_slot, ":hull_instance_id", slot_scene_prop_position, 0),
				(scene_prop_set_slot, ":hull_instance_id", slot_scene_prop_target_position, 0),
				(scene_prop_set_slot, ":hull_instance_id", slot_scene_prop_rotation, 0),
				(scene_prop_set_slot, ":hull_instance_id", slot_scene_prop_target_rotation, 0),
				(scene_prop_get_slot, ":hit_points", ":hull_instance_id", slot_scene_prop_full_hit_points),
				(scene_prop_set_hit_points, ":hull_instance_id", ":hit_points"),
				(scene_prop_set_slot, ":hull_instance_id", slot_scene_prop_next_resource_hp, ":hit_points"),
				(prop_instance_get_starting_position, pos1, ":hull_instance_id"),
				(prop_instance_stop_animating, ":hull_instance_id"),
				(prop_instance_set_position, ":hull_instance_id", pos1),
				(scene_prop_get_slot, ":sail_instance_id", ":hull_instance_id", slot_scene_prop_linked_sail),
				(try_begin),
					(gt, ":sail_instance_id", -1),
					(prop_instance_stop_animating, ":sail_instance_id"),
					(set_fixed_point_multiplier, 100),
					(init_position, pos2),
					(position_set_z, pos2, z_position_to_hide_object),
					(prop_instance_set_position, ":sail_instance_id", pos2),
				(try_end),
				(scene_prop_get_slot, ":sail_off_instance_id", ":hull_instance_id", slot_scene_prop_linked_sail_off),
				(try_begin),
					(gt, ":sail_off_instance_id", -1),
					(prop_instance_stop_animating, ":sail_off_instance_id"),
					(prop_instance_set_position, ":sail_off_instance_id", pos1),
				(try_end),
				(scene_prop_get_slot, ":ramp_instance_id", ":hull_instance_id", slot_scene_prop_linked_ramp),
				(try_begin),
					(gt, ":ramp_instance_id", -1),
					(prop_instance_stop_animating, ":ramp_instance_id"),
					(prop_instance_get_variation_id, ":ramp_start_position", ":hull_instance_id"),
					(try_begin),
						(gt, ":ramp_start_position", 1),
						(assign, ":ramp_start_position", -1),
					(try_end),
					(call_script, "script_ship_get_ramp_relative_position", ":ramp_start_position", 1),
					(position_transform_position_to_parent, pos2, pos1, pos30),
					(prop_instance_set_position, ":ramp_instance_id", pos2),
				(try_end),
				(try_begin),
					(scene_prop_get_slot, ":hold_instance_id", ":hull_instance_id", slot_scene_prop_linked_hold),
					(gt, ":hold_instance_id", -1),
					(prop_instance_stop_animating, ":hold_instance_id"),
					(prop_instance_set_position, ":hold_instance_id", pos1),
					(eq, ":reset", 1),
					(scene_prop_get_slot, ":inventory_slot_end", ":hold_instance_id", slot_scene_prop_inventory_count),
					(gt, ":inventory_slot_end", 0),
					(val_add, ":inventory_slot_end", slot_scene_prop_inventory_begin),
					(try_for_range, ":inventory_slot", slot_scene_prop_inventory_begin, ":inventory_slot_end"),
						(scene_prop_set_slot, ":hold_instance_id", ":inventory_slot", 0),
					(try_end),
				(try_end),
				(try_begin),
					(eq, ":reset", 2),
					(entry_point_get_position, pos2, 0),
					(agent_set_position, ":agent_id", pos2),
				(try_end),
			(try_end),
		(else_try),
			(assign, ":admin_action", -1),
		(try_end),
		(gt, ":admin_action", -1),
		(store_add, ":log_string_id", admin_action_log_strings_begin, ":admin_action"),
		(str_store_string, s3, ":log_string_id"),
		(player_get_unique_id, reg0, ":admin_player_id"),
		(str_store_player_username, s0, ":admin_player_id"),
		(try_begin),
			(neq, ":target_player_id", ":admin_player_id"),
			(player_get_unique_id, reg1, ":target_player_id"),
			(str_store_player_username, s1, ":target_player_id"),
			(assign, ":log_string_id", "str_log_admin_target_player"),
		(else_try),
			(assign, ":log_string_id", "str_log_admin_target_self"),
		(try_end),
		(server_add_message_to_log, ":log_string_id"),
		]),

	#GGG:faction tools
 ("cf_admin_faction_action", # server: check player requests to use admin tools, applying if successful
	 [(store_script_param, ":admin_action", 1), # constants starting with admin_action_
		(store_script_param, ":admin_player_id", 2), # must be valid
		(store_script_param, ":target_faction_id", 3),

		(player_is_admin, ":admin_player_id"),
		(try_begin),
			(eq, ":admin_action", admin_action_lock_faction_capture),
			(player_slot_eq, ":admin_player_id", slot_player_admin_no_factions, 0),
			(faction_get_slot, ":can_use", ":target_faction_id", slot_faction_alow_use_capture),
			(try_begin),
				(eq, ":can_use", 0),
				(assign, ":can_use", 1),
			(else_try),
				(assign, ":can_use", 0),
			(try_end),
			(faction_set_slot, ":target_faction_id", slot_faction_alow_use_capture, ":can_use"),
			(get_max_players, ":max_players"),
			(try_for_range, ":other_player_id", 1, ":max_players"),
				(player_is_active, ":other_player_id"),
				(multiplayer_send_3_int_to_player, ":other_player_id", server_event_faction_set_slot, ":target_faction_id", slot_faction_alow_use_capture, ":can_use"),
			(try_end),
			(str_store_faction_name, s5, ":target_faction_id"),
		(else_try),
			(eq, ":admin_action", admin_action_lock_faction),
			(player_slot_eq, ":admin_player_id", slot_player_admin_no_factions, 0),
			(faction_get_slot, ":locked", ":target_faction_id", slot_faction_is_locked),
			(try_begin),
				(eq, ":locked", 0),
				(assign, ":locked", 1),
				(str_clear, s4),
			(else_try),
				(assign, ":locked", 0),
				(str_store_string, s4, "str_un"),
			(try_end),
			(faction_set_slot, ":target_faction_id", slot_faction_is_locked, ":locked"),
			(get_max_players, ":max_players"),
			(try_for_range, ":other_player_id", 1, ":max_players"),
				(player_is_active, ":other_player_id"),
				(multiplayer_send_3_int_to_player, ":other_player_id", server_event_faction_set_slot, ":target_faction_id", slot_faction_is_locked, ":locked"),
			(try_end),
			(str_store_faction_name, s5, ":target_faction_id"),
		(else_try),
			(assign, ":admin_action", -1),
		(try_end),
		(gt, ":admin_action", -1),

		(store_add, ":log_string_id", admin_action_log_strings_begin, ":admin_action"),
		(str_store_string, s3, ":log_string_id"),
		(player_get_unique_id, reg0, ":admin_player_id"),
		(str_store_player_username, s0, ":admin_player_id"),
		(try_begin),
			(eq, ":admin_action", admin_action_lock_faction_capture),
			(assign, ":log_string_id", "str_log_admin_lock_faction_capture"),
		(else_try),
			(assign, ":log_string_id", "str_log_admin_lock_faction"),
		(try_end),
		(server_add_message_to_log, ":log_string_id"),
		]),

	("cf_admin_hit_stockpile_with_admin_scalpel",
		 [(multiplayer_is_server),
			(store_script_param, ":instance_id", 1),
			(store_script_param, ":agent_id", 2),

			(agent_is_active, ":agent_id"),
			(agent_is_alive, ":agent_id"),

			(agent_get_player_id, ":player_id", ":agent_id"),

			(player_is_active, ":player_id"),
			(player_is_admin, ":player_id"),
		 
			(agent_get_wielded_item, ":wielded_item_id", ":agent_id", 0),
			(gt, ":wielded_item_id", -1),


			(try_begin),
				(eq, ":wielded_item_id", "itm_admin_scalpel"),
		
				(scene_prop_get_slot, ":item_id", ":instance_id", slot_scene_prop_item_id),
		
				(is_between, ":item_id", all_items_begin, all_items_end),
		
				(assign, ":stock_count", 10),
				(scene_prop_set_slot, ":instance_id", slot_scene_prop_stock_count, ":stock_count"),
		
				(multiplayer_send_3_int_to_player, ":player_id", server_event_scene_prop_set_slot, ":instance_id", slot_scene_prop_stock_count, ":stock_count"),
				(str_store_string, s1, "@You refilled the stock count with 10!"),
				(multiplayer_send_string_to_player, ":player_id", server_event_local_chat, s1),
			(try_end),
		]),
	#

	("cf_faction_admin_action", # server: check player requests to use faction lord tools, applying if successful
	 [(store_script_param, ":action", 1), # constants starting with faction_admin_action_
		(store_script_param, ":sender_player_id", 2), # must be valid
		(store_script_param, ":value_1", 3),

		(player_get_slot, ":faction_id", ":sender_player_id", slot_player_faction_id),
		(player_get_unique_id, ":unique_id", ":sender_player_id"),
		(faction_slot_eq, ":faction_id", slot_faction_lord_player_uid, ":unique_id"),
		(assign, ":fail", 0),
		(try_begin),
			(eq, ":action", faction_admin_action_change_banner),
			(is_between, ":value_1", banner_meshes_begin, banner_meshes_end),
			(assign, ":loop_end", factions_end),
			(try_for_range, ":other_faction_id", factions_begin, ":loop_end"), # ensure that the banner is not currently in use by another faction
				(faction_slot_eq, ":other_faction_id", slot_faction_banner_mesh, ":value_1"),
				(faction_slot_eq, ":other_faction_id", slot_faction_is_active, 1),
				(assign, ":loop_end", -1),
				(multiplayer_send_3_int_to_player, ":sender_player_id", server_event_preset_message, "str_banner_used_by_s1", preset_message_faction|preset_message_fail_sound, ":other_faction_id"),
			(try_end),
			(neq, ":loop_end", -1),
			(call_script, "script_cf_check_enough_gold", ":sender_player_id", faction_cost_change_banner),
			(call_script, "script_player_adjust_gold", ":sender_player_id", faction_cost_change_banner, -1),
			(faction_set_slot, ":faction_id", slot_faction_banner_mesh, ":value_1"),
			(get_max_players, ":max_players"),
			(try_for_range, ":player_id", 1, ":max_players"),
				(player_is_active, ":player_id"),
				(multiplayer_send_3_int_to_player, ":player_id", server_event_faction_set_slot, ":faction_id", slot_faction_banner_mesh, ":value_1"),
			(try_end),
			(call_script, "script_redraw_castle_banners", redraw_faction_banners, ":faction_id"),
			(call_script, "script_cf_save_faction", ":faction_id"), #GGG:save faction
		(else_try),
			(this_or_next|eq, ":action", faction_admin_action_kick_player),
			(eq, ":action", faction_admin_action_outlaw_player),
			(player_is_active, ":value_1"),
			(player_slot_eq, ":value_1", slot_player_faction_id, ":faction_id"),
			(neq, ":value_1", ":sender_player_id"),
			(faction_slot_eq, ":faction_id", slot_faction_poll_end_time, 0),
			(assign, ":continue", 1),
			(try_begin),
				(eq, ":action", faction_admin_action_kick_player),
				(assign, ":cost", faction_cost_kick_player),
			(else_try),
				(assign, ":cost", faction_cost_outlaw_player),
				(player_get_slot, ":outlaw_rating", ":value_1", slot_player_outlaw_rating),
				(le, ":outlaw_rating", 0),
				(assign, ":continue", 0),
			(try_end),
			(eq, ":continue", 1),
			(try_begin),
				(player_slot_eq, ":value_1", slot_player_last_faction_kicked_from, ":faction_id"),
			(else_try),
				(call_script, "script_cf_check_enough_gold", ":sender_player_id", ":cost"),
				(call_script, "script_player_adjust_gold", ":sender_player_id", ":cost", -1),
			(else_try),
				(assign, ":continue", 0),
			(try_end),
			(eq, ":continue", 1),
			(player_set_troop_id, ":value_1", "trp_peasant"),
			(try_begin),
				(eq, ":action", faction_admin_action_kick_player),
				(call_script, "script_change_faction", ":value_1", "fac_commoners", change_faction_type_no_respawn),
			(else_try),
				(call_script, "script_player_change_check_outlaw_rating", ":value_1", outlaw_rating_for_lord_outlawed, 1),
			(try_end),
			(player_set_slot, ":value_1", slot_player_last_faction_kicked_from, ":faction_id"),
		(else_try),
			(eq, ":action", faction_admin_action_mute_player),
			(player_is_active, ":value_1"),
			(player_slot_eq, ":value_1", slot_player_faction_id, ":faction_id"),
			(try_begin),
				(player_slot_eq, ":value_1", slot_player_faction_chat_muted, 0),
				(faction_slot_eq, ":faction_id", slot_faction_poll_end_time, 0),
				(assign, ":is_muted", 1),
			(else_try),
				(assign, ":is_muted", 0),
			(try_end),
			(player_set_slot, ":value_1", slot_player_faction_chat_muted, ":is_muted"),
			(multiplayer_send_3_int_to_player, ":sender_player_id", server_event_player_set_slot, ":value_1", slot_player_faction_chat_muted, ":is_muted"),
		(else_try),
			(assign, ":key_slot", -1),
			(try_begin),
				(eq, ":action", faction_admin_action_toggle_player_door_key),
				(assign, ":key_slot", slot_player_has_faction_door_key),
			(else_try),
				(eq, ":action", faction_admin_action_toggle_player_money_key),
				(assign, ":key_slot", slot_player_has_faction_money_key),
			(else_try),
				(eq, ":action", faction_admin_action_toggle_player_item_key),
				(assign, ":key_slot", slot_player_has_faction_item_key),
			(else_try),
				(eq, ":action", faction_admin_action_toggle_player_announce),
				(assign, ":key_slot", slot_player_can_faction_announce),
			(try_end),
			(gt, ":key_slot", -1),
			(player_is_active, ":value_1"),
			(player_slot_eq, ":value_1", slot_player_faction_id, ":faction_id"),
			(try_begin),
				(player_slot_eq, ":value_1", ":key_slot", 0),
				(assign, ":has_key", 1),
			(else_try),
				(assign, ":has_key", 0),
			(try_end),
			(player_set_slot, ":value_1", ":key_slot", ":has_key"),
			(multiplayer_send_3_int_to_player, ":sender_player_id", server_event_player_set_slot, ":value_1", ":key_slot", ":has_key"),
		(else_try),
			(assign, ":new_relation", -1),
			(try_begin),
				(eq, ":action", faction_admin_action_set_relation_hostile),
				(assign, ":new_relation", 0),
			(else_try),
				(eq, ":action", faction_admin_action_set_relation_peaceful),
				(assign, ":new_relation", 1),
			(try_end),
			(gt, ":new_relation", -1),
			(is_between, ":value_1", castle_factions_begin, factions_end),
			(faction_slot_eq, ":value_1", slot_faction_is_active, 1),
			(store_add, ":relation_slot", slot_faction_relations_begin, ":value_1"),
			(faction_get_slot, ":previous_relation", ":faction_id", ":relation_slot"),
			(faction_set_slot, ":faction_id", ":relation_slot", ":new_relation"),
			(call_script, "script_display_faction_relation_change", ":faction_id", ":value_1", ":previous_relation", ":new_relation"),
			(get_max_players, ":max_players"),
			(try_for_range, ":player_id", 1, ":max_players"),
				(player_is_active, ":player_id"),
				(multiplayer_send_3_int_to_player, ":player_id", server_event_faction_set_slot, ":faction_id", ":relation_slot", ":new_relation"),
			(try_end),
		(else_try),
			(assign, ":fail", 1),
		(try_end),
		(eq, ":fail", 0),
		]),

#GGG:check woman
	("cf_is_player_female", # server: Check if player is female. Due to scene props cant check this.
	 [(multiplayer_is_server),
		(store_script_param, ":player_id", 1), # must be valid
		(player_is_active, ":player_id"),
		(player_get_gender, ":gender", ":player_id"),
		(eq, ":gender", tf_female),
		]),

#GGG:check sitting
	("cf_do_custom_anims", # server: Do custom animations e.g. surrender
	 [(multiplayer_is_server),
		(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":anim", 2), # must be valid
		(store_script_param, ":body", 3),
		#(try_begin),
		#  (eq, ":anim", "anim_surrender"),
		#  (agent_set_wielded_item, ":agent_id", -1),
		#  (agent_set_animation, ":agent_id", ":anim", ":body"),
		#(else_try),
			(agent_set_animation, ":agent_id", ":anim", ":body"),
		#(try_end),
		]),

#GGG:music
	("cf_has_enough_skill_level", # server: Handle checking for required skill level
	 [(multiplayer_is_server),
		(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":skill", 2), # must be valid
		(store_script_param, ":required", 3), # must be valid
		(agent_get_troop_id, ":troop_id", ":agent_id"),
		(store_skill_level, ":troop_skill_level", ":skill", ":troop_id"),
		(assign,reg4,1),
		(try_begin),
			(ge, ":troop_skill_level", ":required"),
			(assign, reg4, 0),
		(try_end),
		]),

	("cf_can_play_musical_instrument", # server: Handle starting a musical instrument
	 [(multiplayer_is_server),
		(store_script_param, ":agent_id", 1), # must be valid
		(store_script_param, ":anim", 2), # must be valid
		(store_script_param, ":sound", 3), # must be valid
		(agent_get_slot,":playingmusic", ":agent_id", slot_agent_playing_music),
		(assign, reg5, 1),
		(eq, ":playingmusic", 0),
		(agent_get_wielded_item, ":weapon", ":agent_id", 0),
		(try_begin),
			(eq, ":anim", "anim_play_lute"),
			(try_begin),
				(eq, ":weapon", "itm_lute"),
				(agent_set_slot, ":agent_id", slot_agent_playing_music, ":sound"),
				(assign, reg5, 0),
			(try_end),
		(else_try),
			(eq, ":anim", "anim_play_lyre"),
			(try_begin),
				(eq, ":weapon", "itm_lyre"),
				(agent_set_slot, ":agent_id", slot_agent_playing_music, ":sound"),
				(assign, reg5, 0),
			(try_end),
		#(else_try),
		#  (eq,":anim","anim_play_horn"),
		#  (try_begin),
		#    (eq,":weapon","itm_warhorn"),
		#    (agent_set_slot,":agent_id",slot_agent_playing_music, ":sound"),
		#    (assign,reg5,0),
		#  (try_end),
		(try_end),
		]),

	("cf_check_musical_instrument", # server: Keep checking if user can continue to play music
	 [(multiplayer_is_server),
		(get_max_players, ":max_players"),
		(try_for_range, ":player_id", 1, ":max_players"),
			(player_is_active, ":player_id"),
			(player_get_agent_id, ":agent_id", ":player_id"),
			(agent_is_active, ":agent_id"),
			(agent_is_alive, ":agent_id"),
			(agent_get_slot, ":playing", ":agent_id", slot_agent_playing_music),
			(try_begin),
				(ge, ":playing", 1),
				(agent_get_animation, ":anim", ":agent_id", 1),
				(assign, ":fail", 1),
				(try_begin),
					(eq,":anim","anim_play_lute"),
					(assign, ":fail", 0),
				(else_try),
					(eq,":anim","anim_play_lyre"),
					(assign, ":fail", 0),
				#(else_try),
				#  (eq,":anim","anim_play_horn"),
				#    (assign,":fail",0),
				(try_end),
				(try_begin),
					(eq, ":fail", 1),
					(call_script, "script_cf_stop_playing_musical_instrument", ":agent_id"),
				(try_end),
			(try_end),
		(try_end),
		]),
		
	("cf_stop_playing_musical_instrument", # server: Handle stop playing a musical instrument
	 [(multiplayer_is_server),
		(store_script_param, ":agent_id", 1), # must be valid
		(agent_is_active, ":agent_id"),
		(agent_is_human, ":agent_id"),
		(agent_get_slot, ":playingmusic", ":agent_id", slot_agent_playing_music),
		(gt, ":playingmusic", 0),
		(assign, reg20, 1),
		(agent_set_slot, ":agent_id", slot_agent_playing_music,0),
		(get_max_players, ":max_players"),
		(try_for_range, ":player_id", 1, ":max_players"),
			(player_is_active, ":player_id"),
			(multiplayer_send_int_to_player, ":player_id", server_event_agent_stop_sound, ":agent_id"),
			(call_script, "script_cf_do_custom_anims", ":agent_id", "anim_pose_finish",1),
		(try_end),
		]),
		
	("client_stop_playing_musical_instrument", # client: Handle stop playing a musical instrument
	 [
		(store_script_param, ":agent_id", 1), # must be valid
		(try_begin),
		 (neg|multiplayer_is_dedicated_server),
			(try_begin),
				(agent_is_active, ":agent_id"),
				(agent_stop_sound, ":agent_id"),
			(try_end),
		(try_end),
		]),
#

	#GGG:shield bash
	("shield_bash_trigger", 
	 [
		(get_player_agent_no, ":agent"),
		(try_begin),
			(agent_is_active, ":agent"),
			(agent_is_alive, ":agent"),
			(agent_get_horse, ":horse", ":agent"),
			(eq, ":horse", -1),#not on horse
			(agent_get_wielded_item, ":item", ":agent", 1),
			(gt, ":item", 0),#has shield
			(agent_get_animation, ":anim", ":agent", 0),
			(neg|is_between, ":anim", "anim_walk_forward_crouch", "anim_ride_0"),#is not crouching
			(try_begin),
				(game_in_multiplayer_mode),
				(multiplayer_send_int_to_server, client_event_request_animation, agent_shield_bash),
			(else_try),
				(agent_slot_eq, ":agent", slot_agent_shieldbash_cooldown, 0), #colldown for sp vc-2854
				(call_script, "script_shield_bash", ":agent"),
			(try_end),
		(try_end),
	]),

	("shield_bash", 
	 [
		(store_script_param, ":agent", 1),
		#(store_script_param, ":player", 2),
		
		(try_begin),
			(agent_get_position, pos1, ":agent"),
			(agent_set_animation, ":agent", "anim_shield_bash"),
			(agent_set_slot, ":agent", slot_agent_shieldbash_cooldown, shielbash_miss_cooldown),# 1x2= 2sec
			
			#(try_begin),
				(try_for_players, ":i", 1),
					(multiplayer_send_3_int_to_player, ":i", client_event_request_animation, agent_shield_bash, ":agent", "anim_shield_bash"),
				(try_end),
			#  (player_get_gender, ":gender", ":player"),
			#(else_try),
			#  (agent_get_troop_id, ":troop", ":agent"),
			#  (troop_get_type, ":gender", ":troop"),
			#  (val_mod, ":gender", 2),
			#(try_end),
			#(try_begin),
			#  (eq, ":gender", 0),
			#  (agent_play_sound, ":agent", "snd_man_yell"),
			#(else_try),
			#  (agent_play_sound, ":agent", "snd_woman_yell"),
			#(try_end),
			
			(assign, ":victim", -1),
			(assign, ":min_dist", 125),#125cm
			(try_begin),#Players
				(neg|agent_is_non_player, ":agent"),
				(try_for_agents, ":i"),
					(neq, ":i", ":agent"),
					(agent_is_alive, ":i"),
					(agent_is_human, ":i"),
					(agent_get_position, pos2, ":i"),
					(get_distance_between_positions, ":dist", pos1, pos2),
					(le, ":dist", ":min_dist"),
					(neg|position_is_behind_position, pos2, pos1),
					(assign, ":victim", ":i"),
					(assign, ":min_dist", ":dist"),
				(try_end),
			(try_end),
			(agent_is_active, ":victim"),
			(agent_get_horse, ":horse", ":victim"),
			(eq, ":horse", -1),#not on horse
			
			(agent_set_slot, ":agent", slot_agent_shieldbash_cooldown, shielbash_hit_cooldown),# 10x2= 20sec after successful hit
			(agent_set_animation, ":victim", "anim_shield_bash_hit"),
			(agent_play_sound, ":victim", "snd_shield_hit_wood_wood"),
			(try_for_players, ":i", 1),
				(multiplayer_send_3_int_to_player, ":i", client_event_request_animation, agent_shield_bash, ":victim", "anim_shield_bash_hit"),
			(try_end),
		(try_end),
	]),

	#GGG:loot weapon
	("loot_weapon_trigger", 
	 [
		(get_player_agent_no, ":agent"),
		(try_begin),
			(agent_is_active, ":agent"),
			(agent_is_alive, ":agent"),
			(agent_get_horse, ":horse", ":agent"),
			(eq, ":horse", -1),#not on horse
			(agent_get_wielded_item, ":shield", ":agent", 1),
			(le, ":shield", 0),
			(agent_get_wielded_item, ":weapon", ":agent", 0),
			(ge, ":weapon", 0),
			(item_get_type, ":type", ":weapon"),
			(this_or_next|eq, ":type", itp_type_one_handed_wpn),
			(eq, ":type", itp_type_two_handed_wpn),
			(agent_get_animation, ":anim", ":agent", 0),
			(neg|is_between, ":anim", "anim_walk_forward_crouch", "anim_ride_0"),#is not crouching
			(try_begin),
				(game_in_multiplayer_mode),
				(multiplayer_send_int_to_server, client_event_request_animation, agent_loot_weapon),
			(else_try),
				(call_script, "script_loot_weapon", ":agent"),
			(try_end),
		(try_end),
	]),

	("loot_weapon", 
	 [
		(store_script_param, ":agent", 1),
		
		(try_begin),
			(agent_get_position, pos1, ":agent"),
			
			(assign, ":victim", -1),
			(assign, ":min_dist", 125),#125cm
			(try_begin),#Players
				(neg|agent_is_non_player, ":agent"),
				(try_for_agents, ":i"),
					(neq, ":i", ":agent"),
					(agent_is_alive, ":i"),
					(agent_is_human, ":i"),
					(agent_get_position, pos2, ":i"),
					(get_distance_between_positions, ":dist", pos1, pos2),
					(le, ":dist", ":min_dist"),
					(neg|position_is_behind_position, pos2, pos1),
					(assign, ":victim", ":i"),
					(assign, ":min_dist", ":dist"),
				(try_end),
			(try_end),
			(agent_is_active, ":victim"),
			(agent_get_horse, ":horse", ":victim"),
			(eq, ":horse", -1),#not on horse
			(agent_get_wielded_item, ":shield", ":victim", 1),
			(le, ":shield", 0),
			(agent_get_wielded_item, ":weapon", ":victim", 0),
			(ge, ":weapon", 0),
			(item_get_type, ":type", ":weapon"),
			(this_or_next|eq, ":type", itp_type_one_handed_wpn),
			(eq, ":type", itp_type_two_handed_wpn),
			
			(try_begin),
				(agent_get_defend_action, ":action", ":victim"),
				(is_between, ":action", 1, 3),
				(agent_set_wielded_item, ":victim", -1), 
				(agent_play_sound, ":victim", "snd_hit_metal_metal"),
			(try_end),
		(try_end),
	]),
#

		#script_wse_multiplayer_message_received
# Called each time a composite multiplayer message is received
# INPUT
# script param 1 = sender player no
# script param 2 = event no
("wse_multiplayer_message_received", [
	(store_script_param, ":player_no", 1),
	(store_script_param, ":event_no", 2),
]),

#script_wse_game_saved
# Called each time after game is saved successfully
("wse_game_saved", [
]),

#script_wse_savegame_loaded
# Called each time after savegame is loaded successfully
("wse_savegame_loaded", [
]),

#script_wse_chat_message_received
# Called each time a chat message is received (both for servers and clients)
# INPUT
# script param 1 = sender player no
# script param 2 = chat type (0 = global, 1 = team)
# s0 = message
# OUTPUT
# trigger result = anything non-zero suppresses default chat behavior. Server will not even broadcast messages to clients.
# result string = changes message text for default chat behavior (if not suppressed).
("wse_chat_message_received", [
	(store_script_param, ":player_no", 1),
	(store_script_param, ":chat_type", 2),
]),

#script_wse_console_command_received
# Called each time a command is typed on the dedicated server console or received with RCON (after parsing standard commands)
# INPUT
# script param 1 = command type (0 - local, 1 - remote)
# s0 = text
# OUTPUT
# trigger result = anything non-zero if the command succeeded
# result string = message to display on success (if empty, default message will be used)
("wse_console_command_received", [
	(store_script_param, ":command_type", 1),
]),

#script_wse_get_agent_scale
# Called each time an agent is created
# INPUT
# script param 1 = troop no
# script param 2 = horse item no
# script param 3 = horse item modifier
# script param 4 = player no
# OUTPUT
# trigger result = agent scale (fixed point)
("wse_get_agent_scale", [
	(store_script_param, ":troop_no", 1),
	(store_script_param, ":horse_item_no", 2),
	(store_script_param, ":horse_item_modifier", 3),
	(store_script_param, ":player_no", 4),
]),

#script_wse_window_opened
# Called each time a window (party/inventory/character) is opened
# INPUT
# script param 1 = window no
# script param 2 = window param 1
# script param 3 = window param 2
# OUTPUT
# trigger result = presentation that replaces the window (if not set or negative, window will open normally)
("wse_window_opened", [
	(store_script_param, ":window_no", 1),
	(store_script_param, ":window_param_1", 2),
	(store_script_param, ":window_param_2", 3),
]),


#script_wse_get_server_info
# Called each time a http request for server info received (http://server_ip:server_port/)
# OUTPUT
# trigger result = anything non-zero replace message text for response info 
# result string =  message text for response info 
("wse_get_server_info", [
]),


	("initialize_animation_menu_strings", # set up the starting and ending string ids for the animation menu
	 [
		(troop_set_slot, "trp_animation_menu_strings", 0, "str_menu_guestures"), # offset 0 is for the main menu to select sub menus
		(troop_set_slot, "trp_animation_menu_strings", 0 + animation_menu_end_offset, "str_anim_cheer"),
		(troop_set_slot, "trp_animation_menu_strings", 1, "str_anim_cheer"),
		(troop_set_slot, "trp_animation_menu_strings", 1 + animation_menu_end_offset, "str_anim_away_vile_beggar"),
		(troop_set_slot, "trp_animation_menu_strings", 2, "str_anim_away_vile_beggar"),
		(troop_set_slot, "trp_animation_menu_strings", 2 + animation_menu_end_offset, "str_anim_war_cry"),
		(troop_set_slot, "trp_animation_menu_strings", 3, "str_anim_war_cry"),
		(troop_set_slot, "trp_animation_menu_strings", 3 + animation_menu_end_offset, "str_anim_stand_and_deliver"),
		(troop_set_slot, "trp_animation_menu_strings", 4, "str_anim_stand_and_deliver"),
		(troop_set_slot, "trp_animation_menu_strings", 4 + animation_menu_end_offset, "str_anim_lute_1"), #ggg:str_log_animation
		(troop_set_slot, "trp_animation_menu_strings", 5, "str_anim_lute_1"),
		(troop_set_slot, "trp_animation_menu_strings", 5 + animation_menu_end_offset, "str_log_animation"),
		]),

	("initialize_animation_durations", []), # copies animation durations in milliseconds from module_animations.py to slots of trp_animation_durations

])

first_animation_menu_entry = True
# Define an animation and / or sound for triggering from the animation menu. See the recognized parameters in the script below.
def animation_menu_entry(string_id, **kwargs):
	result = [(else_try), (eq, ":string_id", string_id)]
	global first_animation_menu_entry
	if first_animation_menu_entry:
		result = result[1:]
		first_animation_menu_entry = False
	for name in kwargs:
		value = kwargs[name]
		if not isinstance(value, basestring):
			value = int(value)
		result.append((assign, ":" + name, value))
	return lazy.block(result)

scripts.extend([

	("cf_try_execute_animation", # clients, server: check if an agent can play an animation; if successful, on clients return test result in reg0 or send a message, execute if the server
	 [(store_script_param, ":player_id", 1), # must be valid
		(store_script_param, ":string_id", 2),
		(store_script_param, ":only_test", 3), # if 1, the level of tests passed is returned in reg0

		(assign, ":test_passed", 0),
		(try_begin),
			#Arthur: No more checks
			#(player_get_is_muted, ":is_muted", ":player_id"),
			#(this_or_next|eq, ":is_muted", 0),
			#(neg|multiplayer_is_server),
			(player_get_agent_id, ":agent_id", ":player_id"),
			(agent_is_active, ":agent_id"),
			(agent_is_alive, ":agent_id"),
			(store_mission_timer_a_msec, ":time_ms"),
			(agent_get_slot, ":end_time_ms", ":agent_id", slot_agent_animation_end_time_ms),
			(gt, ":time_ms", ":end_time_ms"),
			(agent_get_slot, ":recent_animations_delay_ms", ":agent_id", slot_agent_recent_animations_delay_ms),
			(try_begin),
				(is_between, ":string_id", animation_strings_begin, animation_strings_end),
				(agent_slot_eq, ":agent_id", slot_agent_last_animation_string_id, ":string_id"),
			(else_try),
				(val_sub, ":recent_animations_delay_ms", 5000),
			(try_end),
			(store_add, ":delayed_time_ms", ":recent_animations_delay_ms", ":end_time_ms"),
			(gt, ":time_ms", ":delayed_time_ms"),
			(assign, ":test_passed", 1),

			(assign, ":animation", -1), # optional agent animation played
			(assign, ":woman_alt_animation", -1), # optional alternate animation played if the agent is a woman.
			(assign, ":upper_body_only", 1), # 0 = override the full body movement animations, 1 = override the upper body parts only
			(assign, ":sound", -1), # optional sound to play for men or women
			(assign, ":man_sound", -1), # optional sound to play only for men
			(assign, ":woman_sound", -1), # optional sound to play only for women
			(assign, ":duration_ms", 0), # duration in milliseconds: animations are set automatically, but this should be set when only playing a sound
			(assign, ":prevent_if_wielding", 0), # 1 = prevent this animation from being triggered if the agent is wielding any items
			(assign, ":prevent_if_moving", 0), # 1 = prevent this animation from being triggered if the agent is moving
			(assign, ":add_to_chat", 0), # display the animation string in the local chat for near the player
			#GGG:music
			(assign, ":music", -1), # ensure that music is handled correctly
			(assign, ":instrument", -1), # required wielded item
			(try_begin), # the first script parameter is the name string id, which must be in the appropriate section of module_strings.py
				animation_menu_entry("str_anim_cheer", animation="anim_cheer", man_sound="snd_man_victory"),
				animation_menu_entry("str_anim_clap", animation="anim_man_clap", woman_alt_animation="anim_woman_clap", prevent_if_wielding=1),
				animation_menu_entry("str_anim_raise_sword", animation="anim_pose_raise_sword"),
				animation_menu_entry("str_anim_hands_on_hips", animation="anim_pose_hands_on_hips", prevent_if_wielding=1, prevent_if_moving=1),
				animation_menu_entry("str_anim_arms_crossed", animation="anim_pose_arms_crossed", prevent_if_wielding=1, prevent_if_moving=1),
				animation_menu_entry("str_anim_stand_still", animation="anim_stand_lord", woman_alt_animation="anim_stand_lady", prevent_if_moving=1),
				animation_menu_entry("str_anim_away_vile_beggar", man_sound="snd_away_vile_beggar", duration_ms=2100, add_to_chat=1),
				animation_menu_entry("str_anim_my_lord", man_sound="snd_my_lord", duration_ms=700, add_to_chat=1),
				animation_menu_entry("str_anim_almost_harvesting_season", man_sound="snd_almost_harvesting_season", duration_ms=1900, add_to_chat=1),
				animation_menu_entry("str_anim_whats_this_then", man_sound="snd_whats_this_then", duration_ms=1300, add_to_chat=1),
				animation_menu_entry("str_anim_out_for_a_stroll_are_we", man_sound="snd_out_for_a_stroll_are_we", duration_ms=1900, add_to_chat=1),
				animation_menu_entry("str_anim_we_ride_to_war", man_sound="snd_we_ride_to_war", duration_ms=2600, add_to_chat=1),
				animation_menu_entry("str_anim_less_talking_more_raiding", man_sound="snd_less_talking_more_raiding", duration_ms=1900, add_to_chat=1),
				animation_menu_entry("str_anim_you_there_stop", man_sound="snd_you_there_stop", duration_ms=1700, add_to_chat=1),
				animation_menu_entry("str_anim_war_cry", man_sound="snd_man_warcry", woman_sound="snd_woman_yell", duration_ms=2100),
				animation_menu_entry("str_anim_tear_you_limb_from_limb", man_sound="snd_tear_you_limb_from_limb", duration_ms=3100, add_to_chat=1),
				animation_menu_entry("str_anim_better_not_be_a_manhunter", man_sound="snd_better_not_be_a_manhunter", duration_ms=2300, add_to_chat=1),
				animation_menu_entry("str_anim_drink_from_your_skull", man_sound="snd_drink_from_your_skull", duration_ms=1800, add_to_chat=1),
				animation_menu_entry("str_anim_gods_will_decide_your_fate", man_sound="snd_gods_will_decide_your_fate", duration_ms=2100, add_to_chat=1),
				animation_menu_entry("str_anim_nice_head_on_shoulders", man_sound="snd_nice_head_on_shoulders", duration_ms=2400, add_to_chat=1),
				animation_menu_entry("str_anim_hunt_you_down", man_sound="snd_hunt_you_down", duration_ms=2100, add_to_chat=1),
				animation_menu_entry("str_anim_dead_men_tell_no_tales", man_sound="snd_dead_men_tell_no_tales", duration_ms=1800, add_to_chat=1),
				animation_menu_entry("str_anim_stand_and_deliver", man_sound="snd_stand_and_deliver", duration_ms=1500, add_to_chat=1),
				animation_menu_entry("str_anim_your_money_or_your_life", man_sound="snd_your_money_or_your_life", duration_ms=2100, add_to_chat=1),
				animation_menu_entry("str_anim_have_our_pay_or_fun", man_sound="snd_have_our_pay_or_fun", duration_ms=3200, add_to_chat=1),
				animation_menu_entry("str_anim_word_about_purse_belongings", man_sound="snd_word_about_purse_belongings", duration_ms=3800, add_to_chat=1),
				animation_menu_entry("str_anim_easy_way_or_hard_way", man_sound="snd_easy_way_or_hard_way", duration_ms=3400, add_to_chat=1),
				animation_menu_entry("str_anim_everything_has_a_price", man_sound="snd_everything_has_a_price", duration_ms=3100, add_to_chat=1),
				animation_menu_entry("str_anim_slit_your_throat", man_sound="snd_slit_your_throat", duration_ms=2400, add_to_chat=1),
				#GGG:new anim
				animation_menu_entry("str_anim_lute_1", animation="anim_play_lute", man_sound="snd_lute_1", woman_sound="snd_lute_1", music=2, instrument="itm_lute"),
				animation_menu_entry("str_anim_lute_2", animation="anim_play_lute", man_sound="snd_lute_2", woman_sound="snd_lute_2", music=2, instrument="itm_lute"),
				animation_menu_entry("str_anim_lute_3", animation="anim_play_lute", man_sound="snd_lute_3", woman_sound="snd_lute_3", music=2, instrument="itm_lute"),
				animation_menu_entry("str_anim_lute_4", animation="anim_play_lute", man_sound="snd_lute_4", woman_sound="snd_lute_4", music=2, instrument="itm_lute"),
				animation_menu_entry("str_anim_lyre_1", animation="anim_play_lyre", man_sound="snd_lyre_1", woman_sound="snd_lyre_1", music=3, instrument="itm_lyre"),
				animation_menu_entry("str_anim_lyre_2", animation="anim_play_lyre", man_sound="snd_lyre_2", woman_sound="snd_lyre_2", music=3, instrument="itm_lyre"),
				animation_menu_entry("str_anim_lyre_3", animation="anim_play_lyre", man_sound="snd_lyre_3", woman_sound="snd_lyre_3", music=3, instrument="itm_lyre"),
				animation_menu_entry("str_anim_lyre_4", animation="anim_play_lyre", man_sound="snd_lyre_4", woman_sound="snd_lyre_4", music=3, instrument="itm_lyre"),
			(else_try),
				(assign, ":string_id", -1),
			(try_end),
			(gt, ":string_id", -1),

			(player_get_gender, ":gender", ":player_id"),
			(try_begin),
				(eq, ":gender", tf_female),
				(gt, ":woman_alt_animation", -1),
				(assign, ":animation", ":woman_alt_animation"),
			(try_end),
			(player_get_agent_id, ":agent_id", ":player_id"),
			(try_begin),
				(eq, ":prevent_if_wielding", 1),
				(agent_get_wielded_item, ":weapon", ":agent_id", 0),
				(agent_get_wielded_item, ":shield", ":agent_id", 0),
				(this_or_next|neq, ":weapon", -1),
				(neq, ":shield", -1),
				(assign, ":animation", -1),
			(try_end),
			#GGG:music
			(try_begin),
				(ge, ":instrument", 0),
				(agent_get_wielded_item, ":instrumentheld", ":agent_id", 0),
				(neq, ":instrumentheld", ":instrument"),
				(assign, ":animation", -1),
				(assign, ":man_sound", -1),
				(assign, ":woman_sound", -1),
			(try_end),
			#
			(try_begin),
				(eq, ":prevent_if_moving", 1),
				(set_fixed_point_multiplier, 100),
				(agent_get_speed, pos0, ":agent_id"),
				(position_get_y, ":forwards_speed", pos0),
				(position_get_x, ":sideways_speed", pos0),
				(this_or_next|gt, ":forwards_speed", 10),
				(gt, ":sideways_speed", 10),
				(assign, ":animation", -1),
			(try_end),
			(try_begin),
				(eq, ":gender", tf_male),
				(gt, ":man_sound", -1),
				(assign, ":sound", ":man_sound"),
			(else_try),
				(eq, ":gender", tf_female),
				(gt, ":woman_sound", -1),
				(assign, ":sound", ":woman_sound"),
			(try_end),
			#GGG:musician
			(try_begin),#cancel music if playing already
				(agent_slot_ge, ":agent_id", slot_agent_playing_music, 1),
				(call_script, "script_cf_stop_playing_musical_instrument", ":agent_id"),
				(call_script, "script_client_stop_playing_musical_instrument", ":agent_id"),
			(try_end),
			(try_begin),# Music handle animations/sound
				(ge,":music",0), # is the agent playing music
				(call_script, "script_cf_has_enough_skill_level", ":agent_id", "skl_herding", ":music"),
				(call_script, "script_cf_can_play_musical_instrument", ":agent_id", ":animation", ":sound"),
				(try_begin),
					(this_or_next|eq,reg4,1),
					(eq,reg5,1),
					(eq, reg5, 1),
					(assign, ":animation", -1),
					(assign, ":sound", -1),
				(try_end),
			(try_end),
			#
			(this_or_next|gt, ":animation", -1),
			(this_or_next|gt, ":sound", -1),
			(eq, ":add_to_chat", 1),
			(assign, ":test_passed", 2),
			(eq, ":only_test", 0),
			(try_begin),
				(multiplayer_is_server),
				(str_store_player_username, s1, ":player_id"),
				(str_store_string, s0, ":string_id"),
				(server_add_message_to_log, "str_log_animation"),
				(try_begin),
					(eq, ":add_to_chat", 1),
					(get_max_players, ":max_players"),
					(agent_get_position, pos0, ":agent_id"),
					(try_for_range, ":other_player_id", 1, ":max_players"),
						(player_is_active, ":other_player_id"),
						(try_begin),
							(eq, ":player_id", ":other_player_id"),
						(else_try),
							(player_get_agent_id, ":other_agent_id", ":other_player_id"),
							(agent_is_active, ":other_agent_id"),
							(agent_is_alive, ":other_agent_id"),
							(agent_get_position, pos1, ":other_agent_id"),
							(get_sq_distance_between_positions, ":distance", pos0, pos1),
							(le, ":distance", sq(max_distance_local_animation)),
						(else_try),
							(assign, ":other_player_id", -1),
						(try_end),
						(neq, ":other_player_id", -1),
						(multiplayer_send_2_int_to_player, ":other_player_id", server_event_local_animation, ":player_id", ":string_id"),
					(try_end),
				(try_end),
				(try_begin),
					(gt, ":animation", -1),
					(agent_set_animation, ":agent_id", ":animation", ":upper_body_only"),
				(try_end),
				(try_begin),
					(gt, ":sound", -1),
					(agent_play_sound, ":agent_id", ":sound"),
				(try_end),
			(try_end),
			(try_begin),
				(gt, ":animation", -1),
				(eq, ":duration_ms", 0),
				(troop_get_slot, ":duration_ms", "trp_animation_durations", ":animation"),
			(try_end),
			(store_add, ":next_end_time_ms", ":time_ms", ":duration_ms"),
			(store_sub, ":next_animation_delay_ms", ":time_ms", ":end_time_ms"),
			(try_begin),
				(lt, ":next_animation_delay_ms", 40000),
				(store_sub, ":next_animation_delay_ms", 10000, ":next_animation_delay_ms"),
				(val_div, ":next_animation_delay_ms", 2),
				(agent_get_slot, ":last_animation_delay_ms", ":agent_id", slot_agent_recent_animations_delay_ms),
				(val_add, ":next_animation_delay_ms", ":last_animation_delay_ms"),
				(val_max, ":next_animation_delay_ms", 0),
			(else_try),
				(assign, ":next_animation_delay_ms", 0),
			(try_end),
			(agent_set_slot, ":agent_id", slot_agent_animation_end_time_ms, ":next_end_time_ms"),
			(agent_set_slot, ":agent_id", slot_agent_last_animation_string_id, ":string_id"),
			(agent_set_slot, ":agent_id", slot_agent_recent_animations_delay_ms, ":next_animation_delay_ms"),
			(try_begin),
				(neg|multiplayer_is_server),
				(multiplayer_send_int_to_server, client_event_request_animation, ":string_id"),
			(else_try),
				(store_sub, ":excessive_repetition_damage", ":next_animation_delay_ms", 12000),
				(gt, ":excessive_repetition_damage", 0),
				(store_agent_hit_points, ":hit_points", ":agent_id", 0),
				(gt, ":hit_points", 0),
				(val_div, ":excessive_repetition_damage", 1000),
				(val_sub, ":hit_points", ":excessive_repetition_damage"),
				(agent_set_hit_points, ":agent_id", ":hit_points", 0),
			(try_end),
			(assign, ":test_passed", 3),
		(try_end),
		(assign, reg0, ":test_passed"),
		(this_or_next|ge, ":test_passed", 3),
		(neq, ":only_test", 0),
		]),

])

# Fill a chest's inventory slot with a set load out of items at mission start.
# 'load_out_id' is the value 2 of the scene prop set in the scene editor.
# 'item_lists' is the rest of the parameters passed as lists: multiple lists passed are treated as alternate load outs to be randomly selected.
def chest_load_out(load_out_id, *item_lists):
	result = [(eq, ":load_out_id", load_out_id)]
	if len(item_lists) > 1:
		result.extend([(store_random_in_range, ":random", 0, len(item_lists)),
			(try_begin)])
		for i, item_list in enumerate(item_lists):
			result.append((eq, ":random", i))
			result.extend((scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + j, item_id)
				for j, item_id in enumerate(item_list))
			result.append((else_try))
		result[-1] = (try_end)
	else:
		result.extend((scene_prop_set_slot, ":instance_id", slot_scene_prop_inventory_begin + i, item_id)
			for i, item_id in enumerate(item_lists[0]))
	result.append((else_try))
	return lazy.block(result)

scripts.extend([

	("scene_fill_chests_starting_inventory",
	 [
		(call_script, "script_chests_fill_starting_inventory", "spr_pw_item_chest_a"),
		(call_script, "script_chests_fill_starting_inventory", "spr_pw_item_chest_b"),
		(call_script, "script_chests_fill_starting_inventory", "spr_pw_item_chest_invisible"),
		]),

	("chests_fill_starting_inventory",
	 [(store_script_param, ":scene_prop_id", 1),

		(scene_prop_get_num_instances, ":num_instances", ":scene_prop_id"),
		(try_for_range, ":instance_no", 0, ":num_instances"),
			(scene_prop_get_instance, ":instance_id", ":scene_prop_id", ":instance_no"),
			(prop_instance_get_variation_id_2, ":load_out_id", ":instance_id"),
			(gt, ":load_out_id", 0),
			(try_begin),

				chest_load_out(1, ["itm_bread"] * 3, ["itm_bread"] * 5, ["itm_cooked_fish"] * 4, ["itm_cooked_meat"] * 2),
				chest_load_out(2, ["itm_bread"] * 10, ["itm_bread"] * 16, ["itm_cooked_fish"] * 7, ["itm_cooked_meat"] * 6, ["itm_carrot"] * 3),
				chest_load_out(3, ["itm_bread"] * 5 + ["itm_cooked_fish"] * 5 + ["itm_cooked_meat"] * 5 + ["itm_meat_pie"] * 3,
					["itm_meat_pie"] * 4 + ["itm_cooked_fish"] * 6 + ["itm_cooked_meat"] * 2 + ["itm_bread"] * 10,
					["itm_grapes"] * 10 + ["itm_salted_fish"] * 3 + ["itm_salted_meat"] * 4 + ["itm_bread"] * 7),
				chest_load_out(4, ["itm_beer_cask"] + ["itm_cooked_meat"] * 5, ["itm_bread"] * 23,
					["itm_beer_cask"] + ["itm_cooked_meat"] * 7, ["itm_bread"] * 15,
					["itm_beer_cask"] * 2 + ["itm_cooked_meat"] * 8, ["itm_bread"] * 17),
				chest_load_out(5, ["itm_wine_barrel"] * 2 + ["itm_cooked_fish"] * 7, ["itm_bread"] * 12,
					["itm_wine_barrel"] + ["itm_cooked_meat"] * 4, ["itm_bread"] * 13,
					["itm_wine_barrel"] * 2 + ["itm_cooked_meat"] * 4 + ["itm_cooked_fish"] * 5 + ["itm_bread"] * 8),

				chest_load_out(10, ["itm_straw_hat", "itm_sickle", "itm_carrot"], ["itm_hood_c", "itm_knife", "itm_fish"], ["itm_wrapping_boots", "itm_club", "itm_grapes"]),
				chest_load_out(11, ["itm_linen_tunic", "itm_hide_boots"], ["itm_red_shirt", "itm_woolen_hose"], ["itm_rough_tunic", "itm_wrapping_boots"], ["itm_tunic_with_green_cape"]),
				chest_load_out(12, ["itm_tabard", "itm_hide_boots"] * 3, ["itm_black_robe", "itm_wrapping_boots"] * 5, ["itm_rough_tunic", "itm_wrapping_boots"] * 4),
				chest_load_out(13, ["itm_tabard", "itm_ankle_boots", "itm_pelt_coat", "itm_hide_boots", "itm_rawhide_coat", "itm_fur_coat", "itm_butchering_knife"],
					["itm_black_robe", "itm_friar_robe", "itm_friar_sandals", "itm_fur_coat", "itm_wrapping_boots", "itm_hunter_boots", "itm_fishing_spear"],
					["itm_rough_tunic", "itm_wrapping_boots", "itm_leather_apron", "itm_hide_boots", "itm_coarse_tunic", "itm_coarse_tunic", "itm_cleaver"]),
				chest_load_out(14, ["itm_rich_outfit", "itm_hide_boots", "itm_fur_coat", "itm_nomad_boots", "itm_lyre"], ["itm_priest_robe", "itm_priest_leggings"],
					["itm_friar_robe", "itm_friar_sandals"] * 3, ["itm_courtly_outfit", "itm_ankle_boots", "itm_lute"], ["itm_nobleman_outfit", "itm_khergit_leather_boots", "itm_die"]),
				chest_load_out(15, ["itm_fur_hat", "itm_fur_coat", "itm_nomad_boots"] * 3, ["itm_priest_coif", "itm_priest_robe", "itm_priest_leggings"] * 2,
					["itm_friar_robe", "itm_friar_sandals"] * 7, ["itm_nobleman_outfit", "itm_khergit_leather_boots", "itm_courtly_outfit", "itm_ankle_boots", "itm_leather_gloves"],
					["itm_surgeon_coif", "itm_surgeon_coat", "itm_blue_hose"] * 2, ["itm_leather_jacket", "itm_khergit_leather_boots", "itm_leather_gloves"] * 2),
				chest_load_out(16, ["itm_fur_hat", "itm_fur_coat", "itm_nomad_boots", "itm_bucket"], ["itm_common_hood", "itm_rough_tunic", "itm_hunter_boots", "itm_butchering_knife"],
					["itm_tunic_with_green_cape", "itm_nomad_boots", "itm_woodcutter_axe"] * 2, ["itm_woolen_cap", "itm_pelt_coat", "itm_ankle_boots", "itm_hunting_bow", "itm_arrows"],
					["itm_surgeon_coif", "itm_surgeon_coat", "itm_blue_hose", "itm_surgeon_scalpel"], ["itm_leather_jacket", "itm_khergit_leather_boots", "itm_herding_crook"] * 3),
				chest_load_out(17, ["itm_leather_apron", "itm_nomad_boots"] * 5 + ["itm_bucket", "itm_scythe", "itm_woodcutter_axe", "itm_butchering_knife", "itm_broom"],
					["itm_coarse_tunic", "itm_wrapping_boots"] * 6 + ["itm_sickle", "itm_bucket", "itm_mining_pick", "itm_fishing_net", "itm_cleaver", "itm_knife"],
					["itm_tunic_with_green_cape", "itm_nomad_boots"] * 4 + ["itm_small_mining_pick", "itm_herding_crook", "itm_butchering_knife", "itm_sickle"]),
				chest_load_out(18, ["itm_coarse_tunic", "itm_nomad_boots", "itm_knife"], ["itm_leather_jacket", "itm_khergit_leather_boots", "itm_lock_pick"],
					["itm_coarse_tunic", "itm_wrapping_boots", "itm_club"] + ["itm_broom"] * 6, ["itm_pilgrim_hood", "itm_pilgrim_disguise", "itm_wrapping_boots", "itm_quarter_staff"],
					["itm_gold_bar"], ["itm_silver_bar"], ["itm_coarse_tunic", "itm_hunter_boots", "itm_poisoned_dagger"], ["itm_tunic_with_green_cape", "itm_nomad_boots", "itm_dagger"]),

				chest_load_out(20, ["itm_nordic_veteran_archer_helmet", "itm_leather_jerkin", "itm_hide_boots", "itm_sword_viking_b_small",
					"itm_nordic_footman_helmet", "itm_byrnie", "itm_leather_boots", "itm_one_handed_battle_axe_a",
					"itm_nordic_fighter_helmet", "itm_mail_hauberk", "itm_leather_boots", "itm_leather_gloves", "itm_sword_viking_a_long",
					"itm_nordic_warlord_helmet", "itm_banded_armor", "itm_mail_boots", "itm_scale_gauntlets", "itm_shortened_voulge"],
					["itm_nordic_footman_helmet", "itm_leather_jerkin", "itm_leather_boots", "itm_leather_gloves", "itm_sword_viking_c"] * 3,
					["itm_nordic_archer_helmet", "itm_leather_armor", "itm_hunter_boots", "itm_one_handed_war_axe_b"] * 2 +
					["itm_nordic_fighter_helmet", "itm_byrnie", "itm_splinted_leather_greaves", "itm_leather_gloves",] * 2 + ["itm_one_handed_battle_axe_b", "itm_two_handed_axe"]),
				chest_load_out(21, ["itm_vaegir_fur_helmet", "itm_leather_vest_plain", "itm_hide_boots", "itm_scimitar",
					"itm_vaegir_spiked_helmet", "itm_lamellar_vest", "itm_mail_chausses", "itm_leather_gloves", "itm_scimitar_b",
					"itm_vaegir_noble_helmet", "itm_lamellar_armor", "itm_mail_boots", "itm_scale_gauntlets", "itm_bardiche"],
					["itm_vaegir_lamellar_helmet", "itm_studded_leather_coat", "itm_leather_boots", "itm_leather_gloves", "itm_khergit_sword_d"] * 3,
					["itm_khergit_war_helmet", "itm_arabian_armor_b", "itm_mail_chausses", "itm_mail_mittens"] * 3 + ["itm_khergit_sword_c", "itm_sarranid_axe_a", "itm_awlpike"]),
				chest_load_out(22, ["itm_mail_coif", "itm_arena_armor", "itm_mail_chausses", "itm_mail_mittens", "itm_sword_medieval_c_long"] * 4,
				["itm_skullcap", "itm_red_gambeson", "itm_splinted_greaves", "itm_winged_mace"] * 4,
				["itm_segmented_helmet", "itm_padded_leather", "itm_leather_boots", "itm_leather_gloves"] * 4 + ["itm_club_with_spike_head", "itm_long_hafted_spiked_mace"] * 2,
				["itm_flat_topped_helmet", "itm_haubergeon", "itm_mail_chausses", "itm_mail_mittens", "itm_military_cleaver_c"] * 4),
				chest_load_out(23, ["itm_leather_cap", "itm_leather_vest_plain", "itm_nomad_boots", "itm_sword_medieval_a"] * 3,
					["itm_leather_steppe_cap_a", "itm_khergit_armor", "itm_khergit_leather_boots", "itm_mace_4"] * 3,
					["itm_skullcap", "itm_red_gambeson", "itm_leather_boots"] * 3 + ["itm_military_pick", "itm_military_hammer", "itm_military_sickle"]),

				chest_load_out(30, ["itm_khergit_lady_hat_b", "itm_khergit_lady_dress_b", "itm_khergit_leather_boots", "itm_knife", "itm_bread"],
					["itm_khergit_lady_hat", "itm_khergit_lady_dress", "itm_khergit_leather_boots", "itm_knife", "itm_cooked_fish"]),
				chest_load_out(31, ["itm_sarranid_head_cloth", "itm_sarranid_lady_dress", "itm_woolen_hose", "itm_sickle", "itm_bread"],
					["itm_sarranid_head_cloth_b", "itm_sarranid_lady_dress_b", "itm_woolen_hose", "itm_bucket", "itm_grapes"]),
				chest_load_out(32, ["itm_bride_crown", "itm_bride_dress", "itm_bride_shoes"]),
				chest_load_out(33, ["itm_lady_dress_ruby", "itm_lady_dress_green", "itm_lady_dress_blue", "itm_wimple_a", "itm_wimple_b", "itm_barbette"],
					["itm_dress", "itm_blue_dress", "itm_peasant_dress", "itm_woolen_dress", "itm_ladys_hood"],
					["itm_sarranid_common_dress", "itm_sarranid_felt_head_cloth", "itm_sarranid_common_dress_b", "itm_sarranid_felt_head_cloth_b"]),

				chest_load_out(99, ["itm_great_helmet", "itm_plate_armor", "itm_plate_boots", "itm_gauntlets", "itm_steel_shield", "itm_morningstar"],
					["itm_winged_great_helmet", "itm_cuir_bouilli", "itm_iron_greaves", "itm_lamellar_gauntlets", "itm_bec_de_corbin_a"],
					["itm_full_helm", "itm_scale_armor", "itm_iron_greaves", "itm_scale_gauntlets", "itm_two_handed_cleaver"],
					["itm_vaegir_mask", "itm_vaegir_elite_armor", "itm_mail_boots", "itm_scale_gauntlets", "itm_two_handed_battle_axe"],
					["itm_bishop_helm", "itm_bishop_armor", "itm_bishop_chausses", "itm_bishop_gloves", "itm_bishop_mitre", "itm_bishop_crosier"]),

				(assign, reg0, ":load_out_id"),
				(display_message, "str_error_load_out_id_reg0_not_defined"),
			(try_end),
		(try_end),
		]),

])
